---
layout: default
title: "13.9 Отримання похідних класів винятків"
---

# 13.9 Отримання похідних класів винятків

Незважаючи на те, що вбудовані винятки охоплюють найпоширен ші програмні помилки, обробка виняткових ситуацій в C# не обмежується тільки цими помилками . Насправді, однією з сильних сторін прийнятого в C# підходу до обробки виняткових ситуацій є те, що в цій мові дозволяється використовувати винятки, визначені користувачем, тобто тими, хто про грамує на С#. Зокрема, такі спеціальні винятки можна використовувати для обробки помилок у власному коді, а створюються вони дуже просто. Для цього достатньо визначити клас, похідний від класу Exception . У таких класах зов сім не обов'язково щось реалізовувати — одного лише їх існування в систе мі типів вже достатньо, щоб використовувати їх як винятки.

Створювані користувачем класи автоматично отримуватимуть властивості та мето ди, визначені в класі Exception і доступні для них. Звичайно, будь-який з цих членів класу Exception можна перевизначити в створюваних класах винятків. Коли створюється власний клас винятків, зазвичай бажано, щоб в ньому підтримувалися всі конструктори, визначені в класі Exception . У простих спеціальних класах винятків цього нескладно досягти, оскільки для цього достатньо передати відповідні аргументи відповідному конструктору класу Exception , використовуючи ключове слово base . Але формально потрібно надати лише ті конструктори, які фактично використовуються в програмі.

Розглянемо приклад програми, в якій використовується виняток спеціального типу. Нагадаємо, що в кінці глави 10 був розроблений клас RangeArray , що підтримує одновимірні масиви, в яких початковий і кінцевий індекси визначаються користувачем. Так, наприклад, повністю допустимим вважається масив, індексований в межах від -5 до 27. Якщо ж індекс виходив за межі масиву, то для обробки цієї помилки в класі RangeArray була визначена спеціальна змінна. Така змінна встановлювалась і перевірялась після кожної операції доступу до масиву в коді, що використовував клас RangeArray. Безумовно, такий підхід до обробки помилок "незграбний" і повний додаткових помилок. У наведеному нижче вдосконаленому варіанті класу RangeArray обробка помилок порушення меж масиву виконується більш елегантним і надійним способом за допомогою спеціально генерованого винятку.

Лістинг 13.13 - Створити виняток для класу RangeArray.

class RangeArrayException : Exception

{

/* Реалізувати всі конструктори класу Exception. Такі конструктори просто

реалізують конструктор базового класу. А оскільки клас винятка

RangeArrayException нічого не додає до класу Exception, то ніяких

додаткових дій не потрібно. */

public RangeArrayException() : base() { }

public RangeArrayException(string str) : base(str) { }

public RangeArrayException(

string str, Exception inner) : base(str, inner) { }

protected RangeArrayException(

System.Runtime.Serialization.SerializationInfo si,

System.Runtime.Serialization.StreamingContext sc) :

base(si, sc)

{ }

// Перевизначити метод ToString() для класу винятка RangeArrayException.

public override string ToString()

{

return Message;

}

}

Зверніть увагу на те, що в тілі конструкторів класу винятка RangeArrayException відсутні будь-які оператори, але замість цього вони просто передають свої аргументи класу Exception , використовуючи ключове слово base . Як пояснювалося раніше, у тих випадках, коли похідний клас винятків не доповнює функції базового класу, весь процес створення винятків можна покласти на кон структори класу Exception . Адже похідний клас винятків зовсім не обов'язково повинен щось доповнювати функції, успадковані від класу Exception . Перш ніж переходити до подальшого читання, спробуйте трохи експериментувати з наведеною вище програмою. Зокрема, спробуйте закоментувати перевизначення методу ToString() і спостерігайте за результатами. Крім того, спробуйте створити виняток, використовуючи конструктор, який викликається за замовчуванням, і подивіться, яке повідомлення при цьому сформується стандартними засобами C#.
