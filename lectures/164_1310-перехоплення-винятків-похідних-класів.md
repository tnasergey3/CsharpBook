---
layout: default
title: "13.10 Перехоплення винятків похідних класів"
---

# 13.10 Перехоплення винятків похідних класів

При спробі перехопити типи винятків, що належать як до базових, так і до похідних класів, слід особливо уважно дотримуватися порядку слідування операторів catch , оскільки перехоплення винятка базового класу буде співпадати з перехопленням винятків будь-яких його похідних класів. Наприклад, клас Exception є базовим для всіх винятків, і тому разом з винятком типу Exception можуть бути перехоплені і всі інші винятки похідних від нього класів. Звичайно, для більш чіткого перехоплення всіх винятків можна скористатися згаданою раніше формою оператора catch без вказання конкретного типу винятка. Але питання перехоплення винятків похідних класів стає дуже актуальним і в інших ситуаціях, особливо при створенні власних винятків. Якщо потрібно перехоплювати винятки базового і похідного класів, то першим за порядком повинен йти оператор catch , який перехоплює виняток похідного класу. Це правило необхідно дотримуватися, оскільки при перехопленні винятка базового класу також будуть перехоплені винятки всіх похідних від нього класів. Справді , це правило дотримується автоматично: якщо першим розташувати в коді оператор catch , який перехоплює виняток базового класу, то під час компіляції цього коду буде видано повідомлення про помилку. У наведеному нижче прикладі програм створюються два класи винятків: ExceptA і ExceptB . Клас ExceptA є похідним від класу Exception , а клас ExceptB — похідним від класу ExceptA . Потім у програмі генеруються винятки кожного типу. З метою кратності в класах спеціальних винятків надається лише один конструктор, що приймає символьний рядок, що описує виняток. Але при розробці програм комерційного призначення в класах спеціальних винятків зазвичай потрібно надавати всі чотири конструктори, визначені в класі Exception.

Лістинг 13.14 - Приклад обробки своїх виключень

class ExceptA : Exception

{

public ExceptA(string str) : base(str) { }

public override string ToString()

{

return Message;

}

}

// Створити клас винятка, похідний від класу ExceptA.

class ExceptB : ExceptA

{

public ExceptB(string str) : base(str) { }

public override string ToString()

{

return Message;

}

}

class OrderMatters

{

static void Main()

{

for (int x = 0; x < 3; x++)

{

try

{

if (x == 0) throw new ExceptA("Перехоплення винятка типу ExceptA");

else if (x == 1) throw new ExceptB("Перехоплення винятка типу ExceptB");

else throw new Exception();

}

catch (ExceptB exc)

{

Console.WriteLine(exc);

}

catch (ExceptA exc)

{

Console.WriteLine(exc);

}

catch (Exception exc)

{

Console.WriteLine(exc);

}

}

}

}

Зверніть увагу на порядок виконання операторів catch . Саме в такому порядку вони й повинні виконуватися. Клас ExceptB є похідним від класу ExceptA , тому виняток типу ExceptB повинен перехоплюватися перед винятком типу ExceptA . Аналогічно, виняток типу Exception (тобто базового класу для всіх винятків) повинен перехоплюватися останнім. Для того, щоб переконатися в цьому, змініть порядок виконання операторів catch . В результаті це призведе до помилки під час компіляції. Прикладом використання оператора catch , який перехоплює винятки базового класу, є перехоплення всієї категорії винятків. Припустимо, що створюється низка винятків для керування певним пристроєм. Якщо зробити їх класами, що походять від загального базового класу, то в додатках, де не обов'язково визначати конкретну причину виникнення помилки, достатньо перехоплювати виняток базового класу і таким чином уникнути непотрібного дублювання коду.
