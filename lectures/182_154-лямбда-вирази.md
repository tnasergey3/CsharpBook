---
layout: default
title: "15.4 Лямбда-вирази"
---

# 15.4 Лямбда-вирази

Незважаючи на всю цінність анонімних методів, на зміну їм прийшов більш су верений підхід: лямбда-вираз. Не буде перебільшенням сказати, що лямбдавираз відноситься до одних з найважливіших нововведень в С#, починаючи з випуску початкової версії 1.0 цієї мови програмування. Лямбда-вираз базується на зовсім новому синтаксичному елементі і служить більш ефективною альтер нативою анонімному методу. І хоча лямбда-вирази знаходять застосування головним чином у роботі з LINQ (детальніше про це - у главі 19), вони часто використовуються і разом з делегатами і подіями. Саме про це застосування лямбда-виразів і піде мова в даному розділі.

Лямбда-вираз - це інший спосіб створення анонімної функції. (Перший її спосіб, анонімний метод, був розглянутий у попередньому розділі.) Отже, лямбда-вираз може бути призначений делегату. А оскільки лямбда-вираз вважається більш ефективним, ніж еквівалентний йому анонімний метод, то в більшості випадків рекомендується віддавати перевагу саме йому.

У всіх лямбда-виразах застосовується новий лямбда-оператор => , який розділяє лямбда-вираз на дві частини. У лівій його частині вказується вхідний параметр (або кілька параметрів), а в правій частині - тіло лямбда-виразу. Опера тор => іноді описується такими словами, як " переходить " або " становиться ". У C# підтримуються два види лямбда-виразів в залежності від тіла самого лямбда-виразу. Так, якщо тіло лямбда-виразу складається з одного ви разу, то утворюється одиночний лямбда-вираз. У цьому випадку тіло виразу не заключається у фігурні дужки. Якщо ж тіло лямбда-виразу складається з блоку операторів, заключених у фігурні дужки, то утворюєтьсяблочний лямбда-вираз. При цьому блочний лямбда-вираз може містити цілий ряд операторів, включаючи цикли, виклики методів та умовні оператори if. Обидві різновидності лямбда- виразів розглядаються далі окремо.

У одиночному лямбда-виразі частина, що знаходиться справа від оператора => впливає на параметр (або ряд параметрів), вказаний зліва. Поверненим результатом обчислення такого виразу є результат виконання лямбда- оператора. Нижче наведена загальна форма одиночного лямбда-виразу, що приймає єдиний параметр.

параметр => вираз

Якщо же потрібно вказати кілька параметрів, то використовується наступна форма. (список_параметрів) => вираз Отже, коли потрібно вказати два або більше параметри, їх слід заключити в дужки . Якщо вираз не потребує параметрів, то слід використовувати порожні дужки. Нижче наведено простий приклад одиночного лямбда-виразу.

сount  => count + 2

У цьому виразі count виступає параметром, на який впливає вираз count + 2 . В результаті значення параметра count збільшується на 2. Ось ще один приклад одиночного лямбда-виразу.

n => n % 2 == 0

У цьому випадку вираз повертає логічне значення true, якщо числове значення параметра n виявляється парним, а інакше - логічне значення false. Лямбда-вираз застосовується в два етапи. Спочатку оголошується тип делегата, який сумісний з лямбда-виразом, а потім екземпляр делегата, якому присвоюється лямбда-вираз. Після цього лямбда-вираз обчислюється при зверненні до екземпляру делегата. Результатом його обчислення стає повернене значення.

У наведеному нижче прикладі програми демонструється застосування двох оди ночних лямбда-виразів. Спочатку в цій програмі оголошуються два типи делега тів. Перший з них, Incr, приймає аргумент типу int і повертає результат того ж типу. Другий делегат, IsEven, також приймає аргумент типу int, але повертає результат типу bool. Потім екземплярам цих делегатів присвоюються одиночні лямбда-вирази. І нарешті, лямбда-вирази обчислюються за допомогою відповід них екземплярів делегатів.

Лістинг 15.7 - Застосувати два окремі лямбда вирази

delegate int Incr(int v);

delegate bool IsEven(int v);

class SimpleLambdaDemo

{

static void Main()

{

// Створити делегат Incr, який посилається на лямбдавираз.

// збільшуючи свій параметр на 2.

Incr incr = count => count + 2;

// Тепер використовуємо лямбдавираз incr.

Console.WriteLine("Використання лямбда-виразу incr: ");

int x = -10;

while (x <= 0)

{

Console.Write(x + " ");

x = incr(x); // збільшити значення x на 2

}

Console.WriteLine("\n");

// Створити екземпляр делегата IsEven, який посилається на лямбдавираз,

// що повертає логічне значення true, якщо його параметр є парним

// значенням, інакше - логічне значення false.

IsEven isEven = n => n % 2 == 0;

// А тепер використовуємо лямбдавираз isEven.

Console.WriteLine("Використання лямбда-виразу isEven: ");

for (int i = 1; i <= 10; i++)

if (isEven(i)) Console.WriteLine(i + " парне.");

}

}

У першому рядку оголошення екземпляру делегата incr присвоюється одиночне лямбда-вираз, що повертає результат збільшення на 2 значення параметра count . Цей вираз може бути присвоєний делегату Incr , оскільки він сумісний з оголошенням даного делегата. Аргумент, що вказується при зверненні до екзем пляру делегата incr , передається параметру count , який і повертає результат обчислення лямбда-виразу. У другому рядку оголошення делегату isEven при своюється вираз , що повертає логічне значення true , якщо переданий йому аргумент виявляється парним, а інакше — логічне значення false . Отже, цей лямбда-вираз сумісний з оголошенням делегата IsEven . У зв'язку з усім викладеним вище виникає розумне питання: яким чином компілятору стає відомо про типи даних, використовуваних у лямбда-виразі, наприклад, про тип int параметра count у лямбда-виразі, який призначається екземпляру делегата incr ? На це питання можна відповісти так: компіля тор робить висновок про тип параметра і тип результату обчислення виразу за типом делегата. Отже, параметри та повертаєме значення лямбда- виразу повинні бути сумісні за типом з параметрами та повертаємим зна ченням делегата.

Незважаючи на всю корисність логічного висновку про тип даних, у деяких випадках доводиться явно вказувати тип параметра лямбда-виразу. Для цього до достатньо ввести конкретну назву типу даних. В якості прикладу нижче наведений інший спосіб оголошення екземпляра делегата incr.

Incr incr = (int count) => count + 2;

Як бачите, count тепер явно оголошений як параметр типу int . Зверніть також увагу на використання дужок. Тепер вони необхідні. (Дужки можуть бути опу щені лише у випадку, якщо задається лише один параметр, а його тип явно не вказується .) У попередньому прикладі в обох лямбда-виразах використовувався єдиний параметр, але взагалі лямбда-вирази можуть мати будь-яку кількість параметрів, включаючи нульову. Якщо в лямбда-виразі використовується кілька параметрів, їх необхідно заключити в дужки. Нижче наведено приклад використання лямбдавиразу з метою визначити, чи знаходиться значення в заданих межах

(low, high, val) => val >= low && val <= high;

Ось як оголошується тип делегата, сумісного з цим лямбда-виразом.

delegate bool InRange(int lower, int upper, int v);

Отже, екземпляр делегата InRange може бути створений наступним чи ном образом.

InRange rangeOK = (low, high, val) => val >= low && val <= high;

Після цього одиночне лямбда-вираз може бути виконано так, як показано нижче

if(rangeOK(1, 5, 3))

І останнє зауваження: зовнішні змінні можуть використовуватися і захоплювати ся в лямбда-виразах так само, як і в анонімних методах.

Як зазначалося вище, існують два види лямбда-виразів. Перша з них, одиночне лямбда-вираз, була розглянута в попередньому розділі. Тіло такого лямбда-виразу складається лише з одного виразу. Другим видом є блочний лямбда-вираз. Для такого лямбда-виразу характерні розширені можливості виконання різних операцій, оскільки в його тілі допускається вказувати кілька операторів.. Наприклад, в блочному лямбда-виразі можна використовувати цикли і умовні оператори if , оголошувати змінні і т.д. Створити блочний лямбда-вираз нескладно. Для цього достатньо заключити тіло виразу в фігурні дужки. Крім можливості використовувати кілька опера торів, в іншому блочний лямбда-вираз, практично нічим не відрізняється від тільки що розглянутого одиночного лямбда-виразу.
