---
layout: default
title: "11.3 Організація захищеного доступу"
---

# 11.3 Організація захищеного доступу

Як пояснювалося вище, відкритий член базового класу недоступний для похідного класу. З цього можна припустити, що для доступу до деякого члена базового класу з похідного класу цей член необхідно зробити відкритим. Але якщо зробити член класу відкритим, то він стане доступним для всього коду, що далеко не завжди бажано. Правда, згадане припущення вірно лише частково, оскільки в C# допускається створення захищеного члена класу.

Захищений член є відкритим в межах ієрархії класів, але закритим поза цією ієрархією. Захищений член створюється за допомогою модифікатора доступу protected . Якщо член класу оголошується як protected , він стає закритим, за винятком одного випадку, коли захищений член успадковується. У цьому випадку захищений член базового класу стає захищеним членом похідного класу, тобто доступним для похідного класу. Отже, використовуючи модифікатор доступу protected , можна створювати члени класу, які є закритими для свого класу, але все ж доступними для похідного класу.

Лістинг 11.5 - Приклад застосування модифікатора доступу protected

class В

{

protected int i, j; // члени, закриті для класу В,

// але доступні для класу D

public void Set(int a, int b)

{

i = a;

j = b;

}

public void Show()

{

Console.WriteLine(i + " " + j);

}

}

class D : В

{

int k; // закритий член

// члени i і j класу В доступні для класу D

public void Setk()

{

k = i * j;

}

public void Showk()

{

Console.WriteLine(k);

}

}

У цьому прикладі клас В успадковується класом D, а його елементи iі jоголошені як protected, тому вони доступні для методу Setk(). Якби елементи iі jкласу В були оголошені як private, то вони були б недоступними для класу D, і при поданому вище коді його не можна було б скомпілювати. Аналогічно стану public і private , стан protected зберігається за елементом класу незалежно від кількості рівнів успадкування. Тому коли похідний клас використовується як базовий для іншого похідного класу, будь-який захищений елемент початкового базового класу, успадкований першим похідним класом, успадковується як захищений і другим похідним класом.

Незважаючи на всю свою корисність, захищений доступ придатний далеко не для всіх ситуацій. Так, в класі TwoDShape з показаного раніше прикладу потрібно, щоб значення його членів Width і Height були доступними відкрито, оскільки потрібно було керувати значеннями, які їм присвоювалися, що було б неможливо, якби вони були оголошені як protected . У даному випадку більш підходя щим рішенням виявилося застосування властивостей, щоб керувати доступом, а не пере дотворити його. Отже, модифікатор доступу protected слід застосовувати у випадку, якщо потрібно створити член класу, доступний для всієї ієрархії класів, але для решти коду він повинен бути закритим. А для керування доступом до значення члена класу краще скористатися властивістю.
