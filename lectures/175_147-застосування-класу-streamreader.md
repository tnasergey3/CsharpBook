---
layout: default
title: "14.7 Застосування класу StreamReader"
---

# 14.7 Застосування класу StreamReader

Для створення символьного потоку вводу достатньо упакувати байтовий потік у обгортку класу StreamReader . У класі StreamReader визначено кілька конструкторів . Нижче наведено найчастіше використовуваний конструктор:

StreamReader(Stream потік)

Де потік означає ім'я відкритого потоку. Цей конструктор генерує виняток ArgumentNullException , якщо потік порожній, а також виняток ArgumentException, якщопотікне відкритий для вводу. Після свого створення об'єкт класу StreamReader виконує автоматичне перетворення байтів в символи. Після завершення вводу з потоку типу StreamReader його потрібно закрити. При цьому закривається й базовий потік. У наведеному нижче прикладі створюється проста сервісна програма вводу з дис ку і виводу на екран вмісту текстового файлу test.txt. Вона служить доповнен ням до раніше представленої сервісної програми вводу з клавіатури і виводу на диск.

Лістинг 14.05 - Приклад StreamReader

class DtoS

{

static void Main()

{

FileStream fin;

string s;

try

{

fin = new FileStream("test.txt", FileMode.Open);

}

catch (IOException exc)

{

Console.WriteLine("Помилка відкриття файлу: " + exc.Message);

return;

}

StreamReader fstr_in = new StreamReader(fin);

try

{

while ((s = fstr_in.ReadLine()) != null)

{

Console.WriteLine(s);

}

}

catch (IOException exc)

{

Console.WriteLine("Помилка введеннявиведення: " + exc.Message);

}

finally

{

fstr_in.Close();

}

}

}

Зверніть увагу на те, як у цій програмі визначається кінець файлу. Коли метод ReadLine() повертає порожнє посилання, це означає, що досягнуто кінець файлу. Такий спосіб є повністю працездатним, але в класі StreamReader надається ще один засіб для виявлення кінця потоку — EndOfStream. Ця властивість доступна для читання і має логічне значення true, коли досягнуто кінець потоку, в іншому випадку — логічне значення false. Отже, властивість EndOfStream можна використовувати для відстеження кінця файлу. Як приклад нижче наведено інший спосіб організації циклу while для читання з файлу.

while(!fstr_in.EndOfStream) { s = fstr_in.ReadLine(); Console.WriteLine(s); }

У цьому випадку код трохи спрощується завдяки властивості EndOfStream , хоча загальний порядок виконання операції вводу з файлу не змінюється. Іноді застосування властивості EndOfStream дозволяє трохи спростити складну ситуацію, надаючи ясність і покращуючи структуру коду. Іноді файл легше відкрити , використовуючи безпосередньо клас StreamReader, аналогічно класуStreamWriter. Для цієї цілі слугує наступний конструктор:

StreamReader(string шлях)

де шлях — це ім'я відкриваного файлу, включаючи повний шлях до нього. Зазначений файл повинен існувати. У протилежному випадку генерується виняток FileNotFoundException. Якщо шлях виявляється порожнім, то генерується виняток ArgumentNullException. А якщо шлях містить порожній рядок, то генерується виняток ArgumentException. Крім того, можуть бути згенеровані винятки IOException і DirectoryNotFoundException.
