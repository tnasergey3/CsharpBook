---
layout: default
title: "6.8 Рядки"
---

# 6.8 Рядки

З точки зору регулярного програмування рядковий тип даних string належить до числа найважливіших в С#. Цей тип визначає і підтримує символьні рядки. У багатьох інших мовах програмування рядок представляє собою масив символів. А в C# рядки є об'єктами. Отже, тип string належить до числа посилальних.

Насправді клас типу string вже неодноразово застосовувався в прикладах програм, але це обставина виявляється тільки зараз, коли черга доходить до рядків. При створенні рядкового літерала насправді формується рядковий об'єкт. Наприклад, у наступному рядку коду:

Console.WriteLine("У C# рядки є об'єктами.");

текстовий рядок "У C# рядки є об'єктами." автоматично перетворюється в рядковий об'єкт за допомогою C#. Отже, застосування класу типу string відбувалося в попередніх прикладах програм неявним чином. А в цьому розділі буде показано, як працювати з рядками явним чином.

### 6.8.1 Побудова рядків

Найпростіший спосіб побудувати символьний рядок - скористатися рядковим літералом. Наприклад, у наступному рядку коду змінній посилання на рядок str присвоюється посилання на рядковий літерал.

string str = "Рядки в C# дуже ефективні.";

У даному випадку змінна str ініціалізується послідовністю символів "Рядки в C # дуже ефективні." .

Об'єкт типу string також можна створити з масиву типу char. Наприклад:

char[] charray = {'t', 'е', 's', 't'};

string str = new string(charray);

Як тільки об'єкт типу string буде створений, його можна використовувати скрізь, де тільки потрібен рядок тексту, заключеного в лапки. Як показано в наведеному нижче прикладі програми, об'єкт типу string може служити в якості аргументу при виклику методуWriteLine() (лістинг 6.19).

Лістинг 6.19 – Створення та виведення символьного рядка

// Створити і вивести символьний рядок.

using System;

class StringDemo

{

static void Main()

{

char[] charray = { 'A', ' ', 's', 't', 'r', 'i', 'n', 'g', '.' };

string str1 = new string(charray);

string str2 = "Ще один рядок.";

Console.WriteLine(str1);

Console.WriteLine(str2);

}

}

Результат виконання цієї програми наведено нижче.

A string.

Ще один рядок.

### 6.8.2 Обробка рядків

Клас типу string містить ряд методів для роботи з рядками. Деякі з цих методів перераховані в таблиці 6.1. Зверніть увагу на те, що деякі методи приймають параметр типу StringComparison. Це перераховуваний тип, що визначає різні значення, які визначають порядок порівняння символьних рядків. Не складно здогадатися, що символьні рядки можна порівнювати різними способами. Наприклад, їх можна порівнювати на основі двійкових значень символів, з яких вони складаються. Таке порівняння називається порядковим. Рядки також можна порівнювати з урахуванням різних особливостей культурного середовища, наприклад, в лексикографічному порядку. Це так зване порівняння з урахуванням культурного середовища (врахування культурного середовища особливо важливо в локалізованих додатках). Крім того, рядки можна порівнювати з урахуванням або без урахування регістру. Незважаючи на те, що існують перевантажувані варіанти методів Compare(), Equals(), IndexOf() і LastIndexOf(), які забезпечують використовуваний за замовчуванням підхід до порівняння символьних рядків, наразі вважається більш прийнятним явно вказувати спосіб потрібного порівняння, щоб уникнути неоднозначності, а також спростити локалізацію додатків. Саме тому тут розглядають різні способи порівняння символьних рядків.

Зазвичай, для порівняння символьних рядків з урахуванням культурного середовища (тобто мовних та регіональних стандартів), застосовується спосіб StringComparison.CurrentCulture. Якщо потрібно порівняти рядки лише на основі значень їх символів, то краще скористатися способом StringComparison.Ordinal , а для порівняння рядків без урахування регістру – одним з двох способів: StringComparison.CurrentCultureIgnoreCase чи StringComparison.OrdinalIgnoreCase. Крім того, можна вказати порівняння рядків без урахування культурного середовища. Зверніть увагу на те, що метод Compare() оголошується в таблиці 6.1 як static. Модифікатор static означає наступне: метод Compare() викликається за ім'ям свого класу, а не за його екземпляром. Отже, для виклику методу Compare() використовується наступна загальна форма:

результат = string.Compare(str1, str2, спосіб);

де спосіб означає конкретний підхід до порівняння символьних рядків.

Зверніть також увагу на методи ToUpper() та ToLower() , що перетворюють вміст рядка на символи верхнього та нижнього регістру відповідно. Їх форми, представлені в таблиці 6.1, містять параметр CultureInfо, що належить до класу, в якому описуються атрибути культурного середовища, що застосовуються для порівняння. У прикладах, наведених у цій книзі, використовуються поточні налаштування культурного середовища (тобто поточні мовні та регіональні стандарти). Ці налаштування вказуються при передачі аргументу методу CultureInfo.CurrentCulture. Клас CultureInfo належить до простору імен System.Globalization . Цікаво, що є варіанти розглянутих тут методів, в яких поточне культурне середовище використовується за замовчуванням, але для уникнення неоднозначності в прикладах з цієї книги аргумент CultureInfo.CurrentCulture вказується явно.

Об'єкти типу string також містять властивість Length, де зберігається довжина рядка.

Таблиця 6.1 – Деякі загальновживані методи роботи з рядками

Метод

Опис

static int Compare( string strA,

string strB,

StringComparison comparisonType)

Повертає від'ємне значення, якщо рядок strA менше рядка strB; позитивне значення, якщо рядок strA більше рядка strВ; і нуль, якщо порівнювані рядки рівні. Спосіб порівняння визначається аргументом comparisonType.

bool Equals(string value,

StringComparison comparisonType)

Повертає логічне значення true, якщо викликаючий рядок має таке ж значення, як і у аргумента value. Спосіб порівняння визначається аргументом comparisonType.

int IndexOf(char value)

Здійснює пошук у викликаючому рядку першого входження символу, визначеного аргументом value. Застосовується порядковий спосіб пошуку. Повертає індекс першого збігу з шуканим символом або -1, якщо його не знайдено.

int IndexOf(string value, StringComparison comparisonType)

Здійснює пошук у викликаючому рядку першого входження підрядка, визначеного аргументом value . Повертає індекс першого збігу з шуканим підрядком або -1, якщо його не знайдено. Спосіб пошуку визначається аргументом comparisonType.

int LastIndexOf(char value)

Здійснює пошук у викликаючому рядку останнього входження символу, визначеного аргумен том value. Застосовується порядковий спосіб пошуку. Повертає індекс останнього збігу з шуканим символом або -1, якщо його не знайдено.

int LastIndexOf(string value, StringComparison comparisonType)

Здійснює пошук у викликаючому рядку останнього входження підрядка, визначеного аргументом value. Повертає індекс останнього збігу з шуканим підрядком або -1, якщо його не знайдено. Спосіб пошуку визначається аргументом comparisonType.

string ToLower(CultureInfo. CurrentCulture culture)

Повертає варіант викликаючого рядка у нижньому регістрі. Спосіб перетворення визначається аргументом culture.

string ToUpper(CultureInfo. CurrentCulture culture)

Повертає варіант викликаючого рядка у верхньому регістрі. Спосіб перетворення визначається аргументом culture.

Окремий символ вибирається з рядка за допомогою індексу, як у наведеному нижче фрагменті коду.

string str = "тест"; Console.WriteLine(str[0]);

У цьому фрагменті коду виводиться символ "т" , який є першим у рядку "тест". Як і в масивах, індексування рядків починається з нуля. Проте, слід мати на увазі, що за допомогою індексу не можна присвоїти нове значення символу в рядку. Індекс може використовуватися лише для вибірки символу з рядка.

Для перевірки рівності двох рядків використовується оператор == . Зазвичай, якщо оператор == застосовується до посилань на об'єкт, то він визначає, чи є вони посиланнями на один і той самий об'єкт. Зовсім інакше стоїть справа з об'єктами типу string. Коли оператор == застосовується до посилань на дві рядки, він порівнює вміст цих рядків. Це стосується і оператора !=. У обох випадках виконується порядкове порівняння. Для перевірки двох рядків на рівність з урахуванням культурного середовища використовується метод Equals(), де обов'язково потрібно вказати спосіб порівняння у вигляді ар гумента StringComparison.CurrentCulture . Також слід мати на увазі, що ме тод Compare() використовується для порівняння рядків з метою визначення відношення порядку, наприклад для сортування. Якщо потрібно перевірити символьні рядки на рівність, то для цього краще скористатися методом Equals( ) або рядковими операторами.

У наведеному нижче прикладі програми демонструється кілька операцій з рядками (лістинг 6.20).

Лістинг 6.20 – Деякі операції з рядками

//  Деякі операції з рядками.

using System;

using System.Globalization;

class StrOps

{

static void Main()

{

string str1 = "Програмувати в .NET краще за все на С#.";

string str2 = "Програмувати в .NET краще за все на С#.";

string str3 = "Рядки в C# дуже ефективні.";

string strUp, strLow;

int result, idx;

Console.WriteLine("str1: " + str1);

Console.WriteLine("Довжина рядка str1: " + str1.Length);

//  Створити варіанти рядка str1, набрані

// прописними і строчними літерами.

strLow = str1.ToLower(CultureInfo.CurrentCulture);

strUp = str1.ToUpper(CultureInfo.CurrentCulture);

Console.WriteLine("Варіант рядка набраний малими літерами str1:\n    " +

strLow);

Console.WriteLine("Варіант рядка набраний великими літерами str1:\n    " +

strUp);

Console.WriteLine();

// Вивести рядок str1 посимвольно.

Console.WriteLine("Вивід рядка str1 посимвольно.");

for (int i = 0; i < str1.Length; i++)

Console.Write(str1[i]);

Console.WriteLine("\n");

// Порівняти рядки за порядком.

if (str1 == str2)

Console.WriteLine("str1 == str2");

else

Console.WriteLine("str1 != str2");

if (str1 == str3)

Console.WriteLine("str1 == str3");

else

Console.WriteLine("str1 != str3");

// Порівняти рядки з урахуванням культурного середовища.

result = string.Compare(str1, str3, StringComparison.CurrentCulture);

if (result == 0)

Console.WriteLine("Рядки str1 і str3 рівні");

else if (result < 0)

Console.WriteLine("Рядок str1 менший за рядок str3");

else

Console.WriteLine("Рядок str1 більший за рядок str3");

Console.WriteLine();

// Присвоїти новий рядок змінній str2.

str2 = "Один Два Три Один";

// Пошук підрядка.

idx = str2.IndexOf("Один", StringComparison.Ordinal);

Console.WriteLine("Індекс першого входження підрядка <Один>: " + idx);

idx = str2.LastIndexOf("Один", StringComparison.Ordinal);

Console.WriteLine("Індекс останнього входження підрядка <Один>: " + idx);

}

}

При виконанні цієї програми отримується наступний результат.

str1: Програмувати в .NET краще за все на С#.

Довжина рядка str1: 41

Варіант рядка str1, набраний малими літерами:

програмувати в .net краще за все на c#.

Варіант рядка str1, набраний прописними буквами:

ПРОГРАМУВАТИ В .NET КРАЩЕ ЗА ВСЕ НА C#.

Вивід рядка str1 посимвольно.

Програмувати в .NET краще за все на С#.

str1 == str2

str1 != str3

Рядок str1 більший за рядок str3

Індекс першого входження підрядка : 0

Індекс останнього входження підрядка : 13

Перед тим, як читати далі, зверніть увагу на те, що метод Compare() викликається наступним чином.

result = string.Compare(str1, str3, StringComparison.CurrentCulture);

Як пояснювалося раніше, метод Compare() оголошується як static, і тому він викликається за ім'ям, а не за екземпляром свого класу.

За допомогою оператора + можна з'єднати (тобто об'єднати разом) два рядки. Наприклад, у наступному фрагменті коду:

string str1 = "Один";

string str2 = "Два";

string str3 = "Три";

string str4 = str1 + str2 + str3;

змінна str4 ініціалізується рядком "ОдинДваТри".

### 6.8.3 Масиви рядків

Аналогічно даним будь-якого іншого типу, рядки можуть бути організовані в масиви. Нижче наведений відповідний приклад (лістинг 6.21).

Лістинг 6.21 – Масиви рядків

// Показати масиви рядків.

using System;

class StringArrays

{

static void Main()

{

string[] str = { "Це", "дуже", "простий", "тест."};

Console.WriteLine("Початковий масив: ");

for (int i = 0; i < str.Length; i++)

Console.Write(str[i] + " ");

Console.WriteLine("\n");

// Змінити рядок.

str[1] = "також";

str[3] = "до межі тест!";

Console.WriteLine("Змінений масив: ");

for (int i = 0; i < str.Length; i++)

Console.Write(str[i] + " ");

}

}

Ось який результат дає виконання наведеного вище коду.

Початковий масив:

Це дуже простий тест.

Змінений масив:

Це також простий до межі тест!

Розглянемо цікавіший приклад. У наведеній нижче програмі ціле число виводиться словами. Наприклад, число 19 виводиться словами "один дев'ять" (лістинг 6.22).

Лістинг 6.22 – Вивід окремих цифр цілого числа словами

// Вивести окремі цифри цілого числа словами.

using System;

class ConvertDigitsToWords

{

static void Main()

{

int num;

int nextdigit;

int numdigits;

int[] n = new int[20];

string[] digits = { "нуль", "один", "два",

"три", "чотири", "п'ять",

"шість", "сім", "вісім",

"дев'ять"  };

num = 1908;

Console.WriteLine("Число: " + num);

Console.Write("Число словами: ");

nextdigit = 0;

numdigits = 0;

// Отримати окремі цифри і зберегти їх у масиві n.

//  Ці числа зберігаються у зворотному порядку.

do

{

nextdigit = num % 10;

n[numdigits] = nextdigit;

numdigits++;

num = num / 10;

} while (num > 0);

numdigits--;

// Вивести отримані слова.

for (; numdigits >= 0; numdigits--)

Console.Write(digits[n[numdigits]] + " ");

Console.WriteLine();

}

}

Виконання цієї програми призводить до наступного результату.

Число: 1908

Число словами: один дев'ять нуль вісім

У даній програмі використовується масив рядків digits для зберігання словесних позначень цифр від 0 до 9. Під час виконання програми ціле число перетворюється в слова. Для цього спочатку отримуються окремі цифри числа, а потім вони зберігаються у зворотному порядку в масиві n типу int. Після цього виконується циклічний опит масиву n у зворотному порядку. При цьому кожне ціле значення з масиву п використовується як індекс, що вказує на слова, що відповідають отриманим цифрам числа і виводяться як рядки.

### 6.8.4 Стійкість рядків

Дивно, але вміст об'єкта типу string не підлягає зміні. Це означає, що одного разу створену послідовність символів не можна змінити. Але це обмеження сприяє більш ефективній реалізації символьних рядків. Тому цей, на перший погляд, очевидний недолік насправді перетворюється в перевагу. Так, якщо потрібен рядок як варіант вже існуючого рядка, то для цього потрібно створити новий рядок, що містить всі необхідні зміни. А оскільки невикористані рядкові об'єкти автоматично збираються в "сміття", то про подальшу долю непотрібних рядків можна навіть не турбуватися.

Слід, однак, підкреслити, що змінні посилання на рядки (тобто об'єкти типу string) підлягають зміні, і, отже, вони можуть посилатися на інший об'єкт. Але вміст самого об'єкта типу string не змінюється після його створення.

Для того, щоб стало зрозуміліше, чому незмінні рядки не є перешкодою, скористаємося ще одним методом обробки рядків: Substring(). Цей метод повертає новий рядок, що містить частину викликаючого рядка. В результаті створюється новий рядковий об'єкт, що містить вибрану підрядок, тоді як початковий рядок не змінюється, і, отже, дотримується принцип постійності рядків. Нижче наведена розглянута тут форма методу Substring():

string Substring(int індекс_початку, int довжина)

де індекс_початку означає початковий індекс вихідного рядка, а довжина –  довжину вибраного підрядка.

Нижче наведена програма, в якій принцип постійності рядків демонструється на прикладі використання методу Substring() (лістинг 6.23).

Лістинг 6.23 – Застосування метода Substring()

// Застосувати метод Substring().

using System;

class SubStr

{

static void Main()

{

string orgstr = "У C# спрощується обробка рядків.";

//  сформувати підрядок

string substr = orgstr.Substring(5, 20);

Console.WriteLine("orgstr: " + orgstr);

Console.WriteLine("substr: " + substr);

}

}

Ось до якого результату призводить виконання цієї програми.

orgstr: У C# спрощується обробка рядків.

substr: спрощується обробка

Як бачите, вихідний рядок змінної orgstr не змінюється, а вибраний з нього підрядок міститься в змінній substr.

І останнє зауваження: незважаючи на те, що постійність рядків зазвичай не є ні обмеженням, ні перешкодою для програмування на С#, іноді виявляється корисним мати можливість змінювати рядки. Для цієї цілі в C# існує клас StringBuilder, який визначений в просторі імен System.Text. Цей клас дозволяє створювати рядкові об' єкти, які можна змінювати. Але, як правило, у програмуванні на C# використовується тип string , а не клас StringBuilder.

### 6.8.5 Застосування рядків в операторах switch

Об'єкти типу string можуть використовуватися для керування оператором switch. Це єдиний нецілочисельний тип даних, який допускається застосовувати у операторі switch. Завдяки такому застосуванню рядків у деяких складних ситуаціях вдається знайти простіший вихід з положення, ніж може здатися на перший погляд. Наприклад, у наведеній нижче програмі виводяться окремі цифри, що відповідають словам "один", "два" і "три" (лістинг 6.24).

Лістинг 6.24 – Управління оператором switch за допомогою рядків

// Показати управління оператором switch за допомогою рядків.

using System;

class StringSwitch

{

static void Main()

{

string[] strs = { "один", "два", "три", "два", "один" };

foreach (string s in strs)

{

switch (s)

{

case "один":

Console.Write(1);

break;

case "два":

Console.Write(2);

break;

case "три":

Console.Write(3);

break;

}

}

Console.WriteLine();

}

}

При виконанні цієї програми отримується наступний результат.

12321
