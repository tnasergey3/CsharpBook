---
layout: default
title: "12.6 Структури"
---

# 12.6 Структури

Як вам вже повинно бути відомо, класи належать до посилальних типів даних. Це означає, що об'єкти конкретного класу доступні за посиланням, на відміну від значень простих типів, доступних безпосередньо. Але іноді прямий доступ до об'єктів як до значень простих типів виявляється корисним мати, наприклад, для підвищення ефективності програми. Адже кожен доступ до об'єктів (навіть найдрібніших) за посиланням пов'язаний з додатковими витратами на використання обчислювальних ресурсів та оперативної пам'яті. Для вирішення подібних проблем в C# передбачена структура, яка схожа на клас, але належить до типу значення, а не посилального типу даних. Структури оголошуються за допомогою ключового слова struct і з точки зору синтаксису схожі на класи. Нижче наведена загальна форма оголошення структури:

struct ім'я : інтерфейси { // оголошення членів }

Де ім'я позначає конкретне ім'я структури.

Деякі структури не можуть успадковувати інші структури та класи або служити як базові для інших структур і класів. (Звичайно, структури, так само як і всі інші типи даних в C#, успадковують клас object .) Однак у структурі мож на реалізувати один або кілька інтерфейсів, які вказуються після імені структури списком через кому. Як і у класів, у кожної структури є свої члени: методи, поля, індексатори, властивості, операторні методи та події.

У структурах також допускається визначати конструктори, але не деструктори. Тим часом для структури не можна визначити конструктор, що використовується за замовчуванням (тобто кон структор без параметрів). Справа в тому, що конструктор, який викликається за замовчуванням, визначається для всіх структур автоматично і не підлягає зміні. Такий кон структор ініціалізує поля структури значеннями, заданими за замовчуванням. Оскільки структури не підтримують успадкування, їх члени не можна вказувати як abstract, virtual або protected. Об'єкт структури може бути створений за допомогою оператора new так само, як і об'єкт класу, але це не є обов'язковим.

Адже коли використовується оператор new , то викликається конструктор, який використовується за замовчуванням. А коли цей оператор не використовується, об'єкт все одно створюється, хоча і не ініціалізується. У цьому випадку ініціалізацію будь-яких членів структури доведеться виконати вручну. У наведеному нижче прикладі програми демонструється застосування структури для зберігання інформації про книгу.

Лістинг 12.7 - Приклад структури

struct Book

{

public string Author;

public string Title;

public int Copyright;

public Book(string a, string t, int c)

{

Author = a;

Title = t;

Copyright = c;

}

}

class StructDemo

{

static void Main()

{

Book book1 = new Book("Герберт Шилдт",

"Повний довідник пo C# 4.0",

2010); // виклик явно заданого конструктора

Book book2 = new Book(); // виклик конструктора за замовчуванням

Book bоок3; // конструктор не викликається

Console.WriteLine(book1.Author + ", " +

book1.Title + ",(c) " + book1.Copyright);

Console.WriteLine();

if (book2.Title == null)

Console.WriteLine("Член book2.Title пуст.");

// А тепер ввести інформацію в структуру book2.

book2.Title = "Про дивний новий світ";

book2.Author = "Олдос Хакслі";

book2.Copyright = 1932;

Console.Write("Структура book2 тепер містить: ");

Console.WriteLine(book2.Author + ", " +

book2.Title + ", (c) " + book2.Copyright);

Console.WriteLine();

ЬоокЗ.Title = "Червона буря";

Console.WriteLine(ЬоокЗ.Title); // тепер правильно

}}

Як показує приклад програми вище, структуру можна ініціалізувати за допомогою оператора new для виклику конструктора або просто оголошення об'єкта. Так, якщо використовується оператор new, то поля структури ініціалізуються конструктором, який викликається за замовчуванням (у цьому випадку всі поля отримують значення за замовчуванням) або конструктором, визначеним користувачем. А якщо оператор new не використовується, як у випадку зі структурою bоок3 , то об'єкт структури не ініціалізується, а його поля повинні бути встановлені вручну перед використанням цього об'єкта. Коли одна структура присвоюється іншій, створюється копія її об'єкта. У цьому за ключається одна з основних відмінностей структури від класу.

Як пояснювалося раніше, коли посилання на один клас присвоюється посиланню на інший клас, в результаті посилання у лівій частині оператора присвоєння вказує на той самий об'єкт, що і посилання у правій його частині. А коли змінна однієї структури присвоюється змінній іншої структури, створюється копія об'єкта структури з правої частини оператора при присвоєнні. Розглянемо як приклад наступну програму.

Лістинг 12.8 - Приклад копіювання структури

struct MyStruct

{

public int x;

}

class StructAssignment

{

static void Main()

{

MyStruct a;

MyStruct b;

a.x = 10;

b.x = 20;

Console.WriteLine("a.x {0}, b.x {1}", a.x, b.x);

a = b;

b.x = 30;

Console.WriteLine("a.x {0}, b.x {1}", a.x, b.x);

}

}

Як показує вищезазначений результат, після присвоєння а = b; змінні структури а і b залишаються абсолютно відокремленими, тобто змінна а не вказує на змінну b і не пов'язана з нею, окрім того, що вона містить копію значення змінної b . Ситуація була б зовсім іншою, якби змінні а і b були посилального типу, вказуючи на об'єкти певного класу.

У зв'язку з викладеним вище виникає розумне питання: чому в C# включена структура, якщо вона має більш скромні можливості, ніж клас? Відповідь на це питання полягає в підвищенні ефективності та продуктивності програм. Структури відносяться до типів значень, і тому ними можна оперувати безпосередньо, а не за посиланням. Отже, для роботи зі структурою взагалі не потрібна змінна посилального типу, а це означає у ряді випадків значну економію оперативної пам'яті. Більше того, робота зі структурою не призводить до погіршення продуктивності, що є характерним для роботи з об'єктом класу. Оскільки класи відносяться до посилального типу даних, доступ до структури здійснюється безпосередньо, а до об'єктів - за посиланням. Непрямий доступ до об'єктів передбачає додаткові витрати обчислювальних ресурсів для кожного такого доступу , тоді як доступ до структур не супроводжується подібними витратами. Взагалі-то, якщо потрібно просто зберегти групу пов'язаних даних, які не потребують успадкування та доступу за посиланням, то з точки зору продуктивності краще вибрати структуру.
