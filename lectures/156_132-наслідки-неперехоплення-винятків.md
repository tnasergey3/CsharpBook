---
layout: default
title: "13.2 Наслідки неперехоплення винятків"
---

# 13.2 Наслідки неперехоплення винятків

Перехоплення одного зі стандартних винятків, як у вищезазначених прикладах, дає ще одну перевагу: воно уникне аварійного завершення програми. Як тільки виняток буде згенеровано, його потрібно перехопити якимось фрагментом коду в певному місці програми. Загалом, якщо виняток не перехоплюється в програмі, то його перехопить виконуюча система. Але справа в тому, що виконуюча система видасть повідомлення про помилку і припинить виконання програми. Так, у наведеному нижче прикладі програми виняток у зв'язку з виходом індексу за межі масиву не перехоплюється.

Лістинг 13.4 - Надати можливість виконавчій системі C# обробляти помилки самостійно

using System;

class NotHandled

{

static void Main()

{

int[] nums = new int[4];

Console.WriteLine("Перед генеруванням винятка.");

// Сгенерувати виняток у зв'язку з виходом індексу за межі масиву.

for (int i = 0; i < 10; i++)

{

nums[i] = i;

Console.WriteLine("nums[{0}]: {1}", i, nums[i]);

}

}

}

Коли виникає помилка індексування масиву, виконання програми припиняється і виводиться наступне повідомлення про помилку. Необроблене виняткове ситуація: System.IndexOutOfRangeException: Індекс знаходився поза межами масиву. в NotHandled.Main() в <ім'я_файлу>:рядок 16 Це повідомлення повідомляє про виявлення в методі NotHandled.Main() необробленого винятку типу System.IndexOutOfRangeException , яке пов'язане з виходом індексу за межі масиву. Такі повідомлення про помилки корисні для налагодження програми, але, принаймні, небажані при її використанні на практиці! Тому так важливо організувати обробку виняткових ситуацій у самій програмі.

Як зазначалося раніше, тип генерованого винятку повинен відповідати типу, вказаному в операторі catch. У протилежному випадку виняток не буде перехоплено. Наприклад, у наведеній нижче програмі здійснюється спроба перехопити помилку порушення меж масиву в блоку catch, що реагує на виняток DivideByZeroException, пов'язаний з діленням на нуль і є ще одним стандартним винятком. Коли індексування масиву виходить за його межі, генерується виняток IndexOutOfRangeException, але він не буде перехоплено блоком catch, що призведе до аварійного завершення програми.

Лістинг 13.5 - Приклад перехоплення не того виключення

class ExcTypeMismatch

{

static void Main()

{

int[] nums = new int[4];

try

{

Console.WriteLine("Перед генеруванням винятка.");

// Сгенерувати виняток у зв'язку з виходом індексу за межі масиву.

for (int i = 0; i < 10; i++)

{

nums[i] = i;

Console.WriteLine("nums[{0}]:{1}", i, nums[i]);

}

Console.WriteLine("He підлягає виводу");

}

/* Якщо перехоплення розраховане на виняток DivideByZeroException,

то перехопити помилку порушення межі масиву не вдасться. */

catch (DivideByZeroException)

{

// Перехопити виняток.

Console.WriteLine("Індекс вийшов за межі масиву!");

}

Console.WriteLine("Після блоку перехоплення винятка.");

}

}

Як видно з наведеного вище результату, в блоку catch, реагуючому на виняток DivideByZeroException, не вдалося перехопити виняток IndexOutOfRangeException.
