---
layout: default
title: "0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
---

# 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

Якщо встановити старший розряд цього числа рівним 1, щоб отримати значення зі знаком, то воно буде інтерпретовано як -1, враховуючи формат до заповнення до двох. Але якщо оголосити його як значення типу ushort, то після встановлення в 1 старшого розряду воно стане рівним 65 535.

Ймовірно, найпоширенішим цілочисельним типом у програмуванні є тип int. Змінні типу int часто використовуються для керування циклами, індексування масивів та математичних обчислень загального призначення. Коли потрібне цілочисельне значення з більшим діапазоном представлення чисел, ніж у типу int, то для цього існує цілий ряд інших цілочисельних типів. Так, якщо значення потрібно зберегти без знаку, то для нього можна вибрати тип uint, для великих значень зі знаком — тип long, а для великих значень без знаку — тип ulong. Нижче наведено приклад програми, яка обчислює відстань від Землі до Сонця в дюймах (лістинг 2.3). Для збереження такого великого значення використовується змінна типу long.

Лістинг 2.3 – Приклад програми

// Обчислити відстань від Землі до Сонця в дюймах.

using System;

class Inches

{

static void Main()

{

long inches;

long miles;

miles = 93000000; // 93 000 000 миль до Сонця

inches = miles * 5280 * 12; // 5 280 футів у милі, 12 дюймів у футі

Console.WriteLine("Відстань до Сонця: " + inches +" дюймів.");

}

}

Ось як виглядає результат виконання цієї програми.

Відстань до Сонця: 5892480000000 дюймів. Очевидно, що цей результат не можна було б зберегти в змінній типу int або uint. Найменшими цілими типами є byte і sbyte . Тип byte представляє цілі значення без знаку в межах від 0 до 255. Змінні типу byte особливо зручні для обробки вихідних двійкових даних, наприклад байтового потоку, що надходить від деякого пристрою. А для представлення малих цілих значень зі знаком слугує тип sbyte. У лістингу 2.4 наведено приклад програми, в якій змінна типу byte використовується для керування циклом, де сумуються числа від 1 до 100.

Лістинг 2.4 – Приклад програми для обчислення суми чисел від 1 до 100

using System;

class Use_byte

{

static void Main()

{

byte x;

int sum;

sum = 0;

for (x = 1; х <= 100; х++)

sum = sum + х;

Console.WriteLine("Сума чисел від 1 до 100 дорівнює " + sum);

}

}

Результат виконання цієї програми виглядає наступним чином. Сума чисел від 1 до 100 дорівнює 5050 У наведеному вище прикладі програми цикл виконується лише від 1 до 100, що не перевищує діапазон представлення чисел для типу byte, і тому для керування цим циклом не потрібна змінна більшого типу. Якщо потрібне ціле значення, більше, ніж значення типу byte або sbyte, але менше, ніж значення типу intабо uint, то для нього можна вибрати тип short або ushort.

Типи для представлення чисел з плаваючою комою

Типи з плаваючою точкою дозволяють представляти числа з дробовою частиною. У C# існує дві різновидності типів даних з плаваючою точкою: float і double . Вони представляють числові значення з одинарною і подвійною точністю відповідно. Так, розрядність типу float становить 32 біти, що приблизно відповідає діапазону представлення чисел від 5Е-45 до 3,4Е+38. А розрядність типу double становить 64 біти, що приблизно відповідає діапазону представлення чисел від 5Е-324 до 1,7Е+308.

У програмуванні на С# частіше застосовується тип double , зокрема, через те, що в багатьох математичних функціях з бібліотеки класів С#, яка одночасно є бібліотекою класів для середовища .NET Framework, використовуються числові значення типу double . Наприклад, метод Sqrt() , визначений в бібліотеці класів System.Math , повертає значення типу double, яке представляє собою квадратний корінь з аргумента типу double, переданого даному методу. У наведеному нижче прикладі програми метод Sqrt() використовується для обчислення ра діуса кола за площею круга (лістинг 2.5).

Лістинг 2.5 – Приклад програми для визначення радіуса кола

// Визначити радіус кола за площею круга.

using System;

class FindRadius

{

static void Main()

{

double r;

double area;

area = 10.0;

r = Math.Sqrt(area / 3.1416);

Console.WriteLine("Радіус дорівнює " + r);

}

}

Результат виконання цієї програми виглядає наступним чином. Радіус дорівнює 1.78412203012729 У вищезазначеному прикладі програми слід звернути увагу на виклик ме тода Sqrt() . Як зазначалося вище, метод Sqrt() належить до класу Math, тому у його виклику перед ім'ям методу йде ім'я самого класу Math. Аналогічним чином перед ім'ям методу WriteLine() у його виклику йде ім'я класу Console. При виклику деяких, хоча й не всіх, стандартних методів зазвичай вказується ім'я їх класу, як показано у наступному прикладі.

У наступному прикладі програми демонструється застосування кількох тригонометричних функцій, які належать до класу Math і входять в стандартну бібліотеку класів C#. Вони також оперують даними типу double. У цьому прикладі на екран виводяться значення синуса, косинуса і тангенса кута, вимірюваного в межах від 0,1 до 1,0 радіана (лістинг 2.6).

Лістинг 2.6 – Приклад застосування тригонометричних функцій

// Показати застосування тригонометричних функцій.

using System;

class Trigonometry

{

static void Main()

{

double theta; // кут у радіанах

for (theta = 0.1; theta <= 1.0; theta = theta + 0.1)

{

Console.WriteLine("Синус кута " + theta +

" = " + Math.Sin(theta));

Console.WriteLine("Косинус кута " + theta +

" = " + Math.Cos(theta));

Console.WriteLine("Тангенс кута " + theta +

" = " + Math.Tan(theta));

Console.WriteLine();

}

}

}

Нижче наведено лише частина результату виконання даної програми.

Синус кута 0.1 дорівнює 0.0998334166468282

Косинус кута 0.1 дорівнює 0.995004165278026

Тангенс кута 0.1 дорівнює 0.100334672085451

Синус кута 0.2 дорівнює 0.198669330795061

Косинус кута 0.2 дорівнює 0.980066577841242

Тангенс кута 0.2 дорівнює 0.202710035508673

Синус кута 0.3 дорівнює 0.29552020666134

Косинус кута 0.3 дорівнює 0.955336489125606

Тангенс кута 0.3 дорівнює 0.309336249609623

Для обчислення синуса, косинуса і тангенса кута в показаному вище прикладі були використані стандартні методи Math.Sin(), Math.Cos() і Math.Tan(). Так само, як і метод Math.Sqrt(), ці тригонометричні методи викликаються з аргументом типу double і повертають результат того ж типу. Обчислювані кути повинні бути вказані в радіанах.

### 2.2.2 Десятковий тип даних

Ймовірно, найцікавішим серед усіх числових типів даних в C# є тип decimal, який призначений для застосування в фінансових розрахунках. Цей тип має розрядність 128 біт для представлення числових значень в межах від 1Е-28 до 7,9Е+28. Вам, ймовірно, відомо, що для звичайних арифметичних обчислень з плаваючою точкою характерні помилки округлення десяткових значень. Ці помилки виключаються при використанні типу decimal, який дозволяє представити числа з точністю до 28 (а іноді і 29) десяткових розрядів. Завдяки тому, що цей тип даних здатний представляти десяткові значення без помилок округлення, він особливо зручний для розрахунків, пов'язаних з фінансами. Нижче наведено приклад програми, в якій тип decimal використовується в конкретному фінансовому розрахунку. У цій програмі ціна зі знижкою розраховується на основі початкової ціни та знижки в відсотках (лістинг 2.7).

Лістинг 2.7 – Програма для розрахунку знижки

// Використовувати тип decimal для розрахунку знижки.

using System;

class UseDecimal

{

static void Main()

{

decimal price;

decimal discount;

decimal discounted_price;

// Розрахувати ціну зі знижкою.

price = 19.95m;

discount = 0.15m; // норма знижки становить 15%

discounted_price = price - (price * discount);

Console.WriteLine("Ціна зі знижкою: $" + discounted_price);

}

}

Результат виконання цієї програми виглядає наступним чином:

Ціна зі знижкою: $16.9575.

Зверніть увагу на те, що значення констант типу decimal у наведеному вище прикладі програми вказуються з суфіксом m . Справа в тому, що без суфікса m ці значення інтерпретувалися б як стандартні константи з плаваючою точкою, які несумісні з типом даних decimal . Тим не менше змінній типу decimal можна присвоїти ціле значення без суфікса m , наприклад 10.

Розглянемо ще один приклад застосування типу decimal . У цьому прикладі розраховується майбутня вартість капіталовкладень з фіксованою нормою прибутку протягом декількох років (лістинг 2.8).

Лістинг 2.8 – Приклад для розрахунку майбутньої вартості капіталовкладень

/*

Застосувати тип decimal для розрахунку майбутньої вартості капіталовкладень.

*/

using System;

class FutVal

{

static void Main()

{

decimal amount;

decimal rate_of_return;

int years, i;

amount = 1000.0M;

rate_of_return = 0.07M;

years = 10;

Console.WriteLine("Початкові капіталовкладення: $" + amount);

Console.WriteLine("Норма прибутку: " + rate_of_return);

Console.WriteLine("Протягом " + years + " років");

for (i = 0; i < years; i++)

amount = amount + (amount * rate_of_return);

Console.WriteLine("Майбутня вартість дорівнює $" + amount);

}

}

Ось як виглядає результат виконання цієї програми.

Початкові капіталовкладення: $1000

Норма прибутку: 0.07

Протягом 10 років

Майбутня вартість становить $1967.151357289565322490000

Зверніть увагу на те, що результат виконання наведеної вище програми представлений з точністю до цілого ряду десяткових розрядів, тобто з явним надлишком порівняно з тим, що зазвичай потрібно.

### 2.2.3 Символи

У C# символи представлені не 8-розрядним кодом, як у багатьох інших мовах програмування, наприклад C++, а 16-розрядним кодом, який називається унікодом (Unicode). У Unicode набір символів представлений настільки широко, що він охоплює символи практично з усіх природних мов світу. Якщо для багатьох природних мов, зокрема англійської, французької та німецької, характерні відносно невеликі алфавіти, то в деяких інших мовах, наприклад китайській, вживаються досить обширні набори символів, які неможливо представити 8-розрядним кодом. Для подолання цього обмеження в C# визначений тип char , що представляє 16-розрядні значення без знаку в межах від 0 до 65 535. При цьому стандартний набір символів в 8-розрядному коді ASCII є підмножиною унікоду в межах від 0 до 127. Отже, символи в коді ASCII залишаються дійсними в C#.

Для того, щоб присвоїти значення символьній змінній, достатньо заключити це значення (тобто символ) в одинарні лапки. Так, у наведеному нижче фрагменті коду змінній ch присвоюється символ X (лістинг 2.9).

Лістинг 2.9 – Присвоєння значення символьній змінній

char ch;

ch = 'X';

Значення типу char можна вивести на екран за допомогою методу WriteLine(). Наприклад, у наступному рядку коду на екран виводиться значення змінної ch (лістинг 2.10).

Лістинг 2.10 – Вивід значення

Console.WriteLine("Значення ch дорівнює: " + ch);

Незважаючи на те, що тип char визначений в C# як цілочисельний, його не слід плутати з усіма іншими цілочисельними типами. Справа в тому, що в C# відсутнє автоматичне перетворення символьних значень в цілочисельні і навпаки. Наприклад, наступний фрагмент коду містить помилку (лістинг 2.11).

Лістинг 2.11 – Фрагмент коду з помилкою

char ch;

ch = 88; // помилка, не вийде

Неправильність наведеного вище фрагмента коду пояснюється тим, що 88 — це ціле значення, яке не перетворюється автоматично в символьне. При спробі скомпілювати цей фрагмент коду буде виведено відповідне повідомлення про помилку. Для того щоб операція присвоєння цілого значення символьній змінній була допустимою, необхідно здійснити приведення типу, про яке йтиметься далі.

### 2.2.4 Логічний тип даних

Тип bool представляє два логічні значення: "істина" і "хиба". Ці логічні значення позначаються в C# зарезервованими словами true і false відповідно. Отже, змінна або вираз типу bool буде приймати одне з цих логічних значень. Крім того, в C# не визначено взаємне перетворення логічних і цілих значень. Наприклад, 1 не перетвориться в значення true , а 0 — в значення false (лістинг 2.12).

Лістинг 2.12 – Приклад використання типу bool

// Показати використання типу bool.

using System;

class BoolDemo

{

static void Main()

{

bool b;

b = false;

Console.WriteLine("b дорівнює " + b);

b = true;

Console.WriteLine("b дорівнює " + b);

// Логічне значення може керувати оператором if.

if (b) Console.WriteLine("Виконується.");

b = false;

if (b) Console.WriteLine("Не виконується.");

// Результатом виконання оператора відношення

// є логічне значення.

Console.WriteLine("10 > 9 дорівнює " + (10 > 9));

}

}

Програма дає наступний результат:

b дорівнює False

b дорівнює True

Виконується.
