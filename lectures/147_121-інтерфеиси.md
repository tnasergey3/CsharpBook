---
layout: default
title: "12.1 Інтерфейси"
---

# 12.1 Інтерфейси

Іноді в об'єктно-орієнтованому програмуванні корисно визначити, що саме повинен робити клас, але не як він повинен це робити. Прикладом цього може служити згадуваний раніше абстрактний метод. У абстрактному методі визначаються повернений тип і сигнатура методу, але не надається його реалізація. А в похідному класі повинна бути забезпечена власна реалізація кожного абстрактного методу, визначеного в його базовому класі. Отже, абстрактний метод визначає інтерфейс, але не реалізацію методу. Звичайно, абстрактні класи і методи приносять певну користь, але принцип, на якому вони базуються, може бути розвиток продовжується. У C# передбачено розділення інтерфейсу класу та його реалізації за допомогою ключового слова interface . З синтаксичної точки зору інтерфейси схожі на абстрактні класи. Але в інтер фейсі жоден з методів не повинен мати тіла. Це означає, що в інтерфейсі взагалі не надається жодної реалізації. В ньому вказується тільки, що саме слід робити, але не як це робити. Як тільки інтерфейс буде визначений, його можна реалізувати в будь-якій кількості класів. Крім того, в одному класі може бути реалізовано будь-яку кількість інтерфейсів. Для реалізації інтерфейсу в класі повинні бути надані тіла (тобто кон кретні реалізації) методів, описаних у цьому інтерфейсі. Кожному класу надається повна свобода для визначення деталей своєї власної реалізації інтерфейсу. Отже, один і той самий інтерфейс може бути реалізований у двох класах по-різному. Проте в кожному з них повинен підтримуватися один і той самий набір методів даного інтерфейсу. А в тому коді, де відомий такий інтерфейс, можуть використовуватися об'єкти будь-якого з цих двох класів, оскільки інтерфейс для всіх цих об'єктів залишається однаковим. Завдяки підтримці інтерфейсів у C# може бути повністю реалізований головний принцип поліморфізму: один інтер фейс - множина методів.

Інтерфейси оголошуються за допомогою ключового слова interface. Нижче наведено спрощена форма оголошення інтерфейсу.

interface ім'я {

повертаємий_тип ім'я_методу1(список_параметрів);

повертаємий_тип ім'я_методу2(список_параметрів);

// ... повертаємий_тип ім'я_методуN{список_параметрів);

}

де ім'я — це конкретне ім'я інтерфейсу. У оголошенні методів інтерфейсу використовуються тільки їх повертаємий_тип та сигнатура. Вони, по суті, є абстрактними методами. Як пояснювалося вище, в інтерфейсі не може бути жодної реалізації. Тому всі методи інтерфейсу повинні бути реалізовані в кожному класі, що включає цей інтерфейс. У самому інтерфейсі методи неявно вважаються відкритими, тому доступ до них не потрібно вказувати явно. Нижче наведено приклад оголошення інтерфейсу для класу, що генерує послідовний ряд чисел.

Лістинг 12.1 - Приклад інтерфейсу

public interface ISeries

{

int GetNext(); // повернути наступне за порядком число

void Reset(); // перезапустити

void SetStart(int х); // задати початкове значення

}

Як тільки інтерфейс буде визначений, його можна реалізувати в одному або декількох класах. Для реалізації інтерфейсу достатньо вказати його ім'я після імені класу, аналогічно базовому класу. Нижче наведена загальна форма реалізації інтерфейсу в класі.

class ім'я_класу : ім'я_інтерфейсу { // тіло класу }

Де ім'я_інтерфейсу —це конкретне ім'я реалізованого інтерфейсу. Якщо ін терфейс реалізується в класі, то це повинно бути зроблено повністю. Зокрема, реалізувати інтерфейс вибірково і тільки частково не можна. У класі можна реалізувати кілька інтерфейсів. У цьому випадку всі реалізовані в класі інтерфейси вказуються списком через кому. У класі можна успадкувати базовий клас і водночас реалізувати один або більше інтерфейс. У такому випадку ім'я базового класу повинно бути вказано перед списком інтерфейсів, розділених комою. Методи, що реалізують інтерфейс, повинні бути оголошені як public . Справа в тому, що в самому інтерфейсі ці методи неявно підразуміваються як відкриті, тому їх реалізація також повинна бути відкритою. Крім того, повернений тип і сигнатура реалізованого методу повинні точно відповідати поверненому типу і сигнатурі, зазначеним у визначенні інтерфейсу. Нижче наведений приклад програми, в якій реалізується представлений раніше інтерфейс ISeries . У цій програмі створюється клас ByTwos , що генерує послідовний ряд чисел, в якому кожне наступне число на два більше попереднього.

Лістинг 12.2 - Приклад класу що реалізує інтерфейс

class ByTwos : ISeries

{

int start;

int val;

public ByTwos()

{

start = 0;

val = 0;

}

public int GetNext()

{

val += 2;

return val;

}

public void Reset()

{

val = start;

}

public void SetStart(int x)

{

start = x;

val = start;

}

}

Як бачите, в класі ByTwos реалізуються три методи, визначені в інтерфейсі ISeries. Як пояснювалося вище, це доводиться робити тому, що в класі неможливо реалізувати інтерфейс частково.
