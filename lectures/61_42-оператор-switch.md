---
layout: default
title: "4.2 Оператор switch"
---

# 4.2 Оператор switch

Другим оператором вибору в C# є оператор switch, який забезпечує багатоспрямоване розгалуження програми. Отже, цей оператор дозволяє зробити вибір серед кількох альтернативних варіантів подальшого виконання програми. Незважаючи на те, що багатоспрямована перевірка може бути організована за допомогою послідовного ряду вкладених операторів if , у багатьох випадках більш ефективним виявляється застосування оператора switch. Цей оператор діє наступним чином. Значення виразу послідовно порівнюється з константами вибору з заданого списку. Як тільки буде виявлено співпадіння з одним з умов вибору, виконується послідовність операторів, пов'язаних з цією умовою. Нижче наведена загальна форма оператора switch.

switch(вираз) {

case константа1:

послідовність операторів

break;

case константа2:

послідовність операторів

break;

case константа3:

послідовність операторів

break;

default:

послідовність операторів

break;

}

Заданий вираз в операторі switch повинен бути цілочисельного типу ( char, byte, short або int), перерахованого або рядкового. А вирази інших типів, наприклад з плаваючою точкою, в операторі switch не допускаються. Часто вираз, що керує оператором switch, просто зводиться до однієї змінної. Крім того, константи вибору повинні мати тип, сумісний з типом виразу. У одному операторі switch не допускається наявність двох однакових за значенням констант вибору.

Послідовність операторів з гілки default виконується у випадку, якщо жодна з констант вибору не збігається з заданим виразом. Гілка default не є обов'язковою. Якщо вона відсутня і вираз не збігається з жодним з умов вибору, то жодних дій взагалі не виконується. Якщо ж відбувається збіг з однією з умов вибору, то виконуються оператори, пов'язані з цією умовою, аж до оператора break.

Нижче наведений приклад програми, в якому демонструється застосування оператора switch (лістинг 4.5).

Лістинг 4.5 – Застосування switch

// Показати застосування оператора switch.

using System;

class SwitchDemo

{

static void Main()

{

int i;

for (i = 0; i < 10; i++)

switch (i)

{

case 0:

Console.WriteLine("i дорівнює нулю");

break;

case 1:

Console.WriteLine("i дорівнює одиниці");

break;

case 2:

Console.WriteLine("i  дорівнює двом");

break;

case 3:

Console.WriteLine("i дорівнює трьом");

break;

case 4:

Console.WriteLine("i дорівнює чотирьом");

break;

default:

Console.WriteLine("i дорівнює або більше п'яти");

break;

}

}

}

Результат виконання цієї програми виглядає наступним чином.

i дорівнює нулю.

i дорівнює одиниці.

i дорівнює двом.

i дорівнює трьом.

i дорівнює чотирьом.

i дорівнює або більше п'яти.

i дорівнює або більше п'яти.

i дорівнює або більше п'яти.

i дорівнює або більше п'яти.

i дорівнює або більше п'яти.

Як бачите, на кожному кроці циклу виконуються оператори, пов'язані зі співпадаючою константою вибору, обходячи всі інші оператори. Коли значення змінної i становиться рівним або більшим п'яти, то воно не співпадає з жодною з констант вибору, і, отже, виконуються оператори з гілки default.

У вищезазначеному прикладі оператором switch керувала змінна i типу int. Як пояснювалося раніше, для керування оператором switch може бути використано вираз будь-якого цілочисельного типу, включаючи char. Нижче наведено приклад застосування виразу і констант вибору типу char у операторі switch (лістинг 4.6).

Лістинг 4.6 – Застосування switch, використовуючи char у операторі

// Використовувати елементи типу char для

// керування оператором switch.

using System;

class SwitchDemo2

{

static void Main()

{

char ch;

for (ch = 'A'; ch <= 'E'; ch++)

switch (ch)

{

case 'A':

Console.WriteLine("ch містить A");

break;

case 'B':

Console.WriteLine("ch містить B");

break;

case 'C':

Console.WriteLine("ch містить C");

break;

case 'D':

Console.WriteLine("ch містить D");

break;

case 'E':

Console.WriteLine("ch містить E");

break;

}

}

}

Ось який результат дає виконання цієї програми.

ch містить А

ch містить В

ch містить С

ch містить D

ch містить Е

Зверніть увагу в даному прикладі на відсутність гілки default в операторі switch. Нагадаємо, що гілка default не є обов'язковою. Коли вона не потрібна, її можна просто пропустити. Перехід послідовності операторів, пов'язаних з однією гілкою case , в наступну гілку case вважається помилкою, оскільки в C# обов'язково дотримуватися правила недопущення "провалів" в передачі керування ходом виконання програми. Саме тому послідовність операторів в кожній гілці case оператора switch закінчується оператором break. Коли у послідовності операторів окремої гілки case зустрічається оператор break, відбувається вихід не тільки з цієї гілки, але з усього оператора switch, а виконання програми продовжується з наступного оператора, що знаходиться поза межами оператора switch. Послідовність операторів у гілці default також повинна бути позбавлена "провалів", тому вона завершується, як правило, оператором break.

Правило недопущення "провалів" стосується тих особливостей мови С#, які він відрізняється від С, C++ і Java. У цих мовах програмування одна гілка case може переходити (тобто "провалюватися") в іншу. Це правило встановлено в C# для гілок case з двох причин. По-перше, воно дає компілятору можливість вільно змінювати порядок послідовностей операторів з гілок case з метою оптимізації. Така реорганізація була б неможливою, якби одна гілка case могла переходити в іншу. І по-друге, вимога завершувати кожну гілку case явно виключає мимовільні помилки програмування, що допускають перехід однієї гілки case в іншу.

Незважаючи на те, що правило недопущення "провалів" не допускає перехід однієї гілки case в іншу, в двох або більше гілках case все ж дозволяється посилатися за допомогою міток на одну й ту саму кодову послідовність, як показано в наступному прикладі програми (лістинг 4.7).

Лістинг 4.7 – Приклад «провалу» порожніх гілок

// Приклад "провалу" порожніх гілок case.

using System;

class EmptyCasesCanFall

{

static void Main()

{

int i;

for (i = 1; i < 5; i++)

switch (i)

{

case 1:

case 2:

case 3:

Console.WriteLine("i дорівнює 1, 2 або 3");

break;

case 4:

Console.WriteLine("i дорівнює 4");

break;

}

}

}

Нижче наведено результат виконання цієї програми.

i дорівнює 1, 2 або 3

i дорівнює 1, 2 або 3

i дорівнює 1, 2 або 3

i дорівнює 4

Якщо значення змінної i у даному прикладі дорівнює 1, 2 або 3, то виконується пер ший оператор, що містить виклик методу WriteLine(). Таке розташування кількох міток гілок case поспіль не порушує правило недопущення "провалів"; оскільки в усіх цих гілках використовується одна й та сама послідовність операторів.

Розташування кількох міток гілок case послідовно застосовується у випадку, якщо кілька гілок мають спільний код. Завдяки цьому уникнуто зайвого дублювання кодових послідовностей.

### 4.2.1 Вкладені оператори switch

Один оператор switch може бути частиною послідовності операторів іншого, зовнішнього оператора switch. Такий оператор switch називається вкладеним. Константи вибору внутрішнього і зовнішнього операторів switch можуть містити спільні значення, не викликаючи конфліктів. Наприклад, наступний фрагмент коду є допустимим (лістинг 4.8).

Лістинг 4.8 – Приклад вкладеного оператора switch

switch(ch1) {

case 'A': Console.WriteLine("Ця гілка А - Частина " +

"зовнішнього оператора switch.");

switch(ch2){

case 'A':

Console.WriteLine("Ця гілка A - частина " +

"внутрішнього оператора switch");

break;

case 'В': // ...

} // кінець внутрішнього оператора switch

break;

case 'В': // ...
