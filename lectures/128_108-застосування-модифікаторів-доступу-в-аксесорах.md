---
layout: default
title: "10.8 Застосування модифікаторів доступу в аксесорах"
---

# 10.8 Застосування модифікаторів доступу в аксесорах

За замовчуванням доступність аксесорів set і get показується такою ж, як і у індексатора і властивості, частиною яких вони є. Так, якщо властивість оголошується як public , то за замовчуванням її аксесори set і get також стають відкритими ( public ). Проте для аксесора set або get можна вказати власний модифікатор доступу, наприклад private . Але в будь-якому випадку доступність аксесора, визначена таким модифікатором, повинна бути більш обмеженою, ніж доступність, вказана для його властивості або індексатора. Існує цілий ряд причин, чому потрібно обмежити доступність аксесора. Припустимо, що потрібно надати вільний доступ до значення властивості, але водночас дати можливість встановлювати цю властивість тільки членам його класу. Для цього достатньо оголосити аксесор даної властивості як private. У наведеному нижче прикладі використовується властивість MyProp, аксесор setякої вказаний як private.

Лістинг 10.11 - Застосувати модифікатор доступу в аксесорі.

class PropAccess

{

int prop; // поле, кероване властивістю МуРrор

public PropAccess() { prop = 0; }

public int МуРrор

{

get

{

return prop;

}

private set

{ // тепер це закритий аксесор

prop = value;

}

}

// Цей член класу інкрементує значення властивості МуРrор.

public void IncrProp()

{

MyProp++; // Допускається в. тому ж самому класі.

}

}

class PropAccessDemo

{

static void Main()

{

PropAccess ob = new PropAccess();

Console.WriteLine("Початкове значення ob.МуРrор: " + ob.МуРrор);

// ob.МуРrор = 100; // недоступно для встановлення

ob.IncrProp();

Console.WriteLine("Значення ob.МуРrор після інкрементування: " +

ob.МуРrор);

}

}

В класі PropAccess аксесор set вказаний як private . Це означає, що він доступний тільки іншим членам цього класу, наприклад методу IncrProp() , але недоступний для коду поза класом PropAccess . Саме тому спроба Присвоїти властивості ob.МуРrор значення в класі PropAccessDemo закоментована. Ймовірно, обмеження доступу до аксесорів є найважливішим для роботи з автоматично реалізованими властивостями. Як пояснювалося вище, створити автоматично реалізована властивість тільки для читання або ж тільки для запису неможливо, оскільки обидва аксесори, get і set, повинні бути вказані при оголошенні такої властивості. Проте досягти бажаного результату все ж можна, оголосивши один з аксесорів автоматично реалізованої властивості як private. В якості прикладу нижче наведено оголошення автоматично реалізованої властивості Length для класу FailSoftArray, яке фактично стає доступним тільки для читання.

public int Length { get; private set; }

Властивість Lengthможе бути встановлена тільки з коду в його класі, оскільки його аксесор set оголошений як private. А змінювати властивість Lengthза межами його класу не дозволяється. Це означає, що за межами свого класу властивість, по суті, стає доступною тільки для читання. Аналогічним чином можна оголосити і властивість Error, як показано нижче.

public bool Error { get; private set; }

Завдяки цьому властивість Error становиться доступною для читання, але не для встановлення за межами класу FailSoftArray . Для перевірки автоматично реалізованих варіантів властивостей Length і Error в класіFailSoftArray видалимо спочатку змінні lenі ErrFlag, оскільки вони більше не потрібні, а потім замінимо кожне використання змінних lenі ErrFlag властивостями Lengthі Errorв класіFailSoftArray. Нижче наведено оновлений варіант класу FailSoftArray разом з методом Main(), що демонструє його застосування.

Лістинг 10.12 - Застосувати автоматично реалізовані та доступні тільки для читання властивості Length і Error.

class FailSoftArray

{

int[] a; // посилання на базовий масив

// Побудувати масив за заданим розміром.

public FailSoftArray(int size)

{

a = new int[size];

Length = size;

}

// Автоматично реалізована та доступна тільки для читання властивість Length.

public int Length { get; private set; }

// Автоматично реалізована та доступна тільки для читання властивість Error.

public bool Error { get; private set; }

// Це індексатор для масиву FailSoftArray.

public int this[int index]

{

// Це аксесор get.

get {

if (ok(index))

{

Error = false;

return a[index];

}

else

{

Error = true;

return 0;

}

}

// Це аксесор set.

set

{

if (ok(index))

{

a[index] = value;

Error = false;

}

else Error = true;

}

}

// Повернути логічне значення true, якщо

// індекс знаходиться в установлених межах.

private bool ok(int index)

{

if (index >= 0 & index < Length) return true;

return false;

}

}

// Показати застосування вдосконаленого

// масиву з відмовостійкістю.

class FinalFSDemo

{

static void Main()

{

FailSoftArray fs = new FailSoftArray(5);

// Використовувати властивість Error.

for (int i = 0; i < fs.Length + 1; i++)

{

fs[i] = i * 10;

if (fs.Error)

Console.WriteLine("Помилка в індексі " + i);

}

}

}

Цей варіант класу FailSoftArray діє так само, як і попередній, але в ньому відсутні підтримуючі поля, оголошені явно. На застосування модифікаторів доступу в аксесорах накладаються наступні обмеження. По-перше, дії модифікатора доступу підлягає тільки один ак сесор: set або get , але не обидва одночасно. По-друге, модифікатор повинен забезпечувати більш обмежений доступ до аксесора, ніж доступ на рівні властивості або індексато ра. І нарешті, модифікатор доступу не можна використовувати при оголошенні аксесора в інтерфейсі або при реалізації аксесора, вказаного в інтерфейсі.
