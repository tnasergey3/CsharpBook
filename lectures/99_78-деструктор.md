---
layout: default
title: "7.8 Деструктор"
---

# 7.8 Деструктор

У мові C# є можливість визначити метод, який буде викликатися не прямо передостаточним знищенням об'єкта системою "збірки сміття". Такий метод називається деструктором і може використовуватися в деяких особливих випадках, щоб гарантувати чітке закінчення терміну дії об'єкта. Наприклад, деструктор може бути використаний для гарантованого звільнення системного ресурсу, задіяного звільняємим об'єктом. Слід, однак, відразу під креслити, що деструктори - дуже специфічні засоби, застосовувані тільки у рідкісних, особливих випадках. І, як правило, вони не потрібні. Але тут вони розглядаються у кількох словах для повноти уявлення про можливості

мови C#. Нижче наведена загальна форма деструктора:

~ім'я_класу() {

// код деструктора

}

де ім'я_класу означає ім'я конкретного класу. Отже, деструктор оголошується аналогічно конструктору, за винятком того, що перед його ім'ям вказується знак "тильда" ( ~ ). Зверніть увагу на те, що у деструктора відсутній повертаємий тип і передавані йому аргументи. Для того, щоб додати деструктор до класу, достатньо включити його в клас як члена. Він викликається кожного разу, коли передбачається утилізувати об'єкт його класу. У деструкторі можна вказати ті дії, які слід виконати перед тим, як знищувати об'єкт. Слід, однак, мати на увазі, що деструктор викликається безпосередньо перед "збором сміття ".

Він не викликається, наприклад, в той момент, коли змінна, що містить посилання на об'єкт, опиняється поза областю дії цього об'єк та. (У цьому відношенні деструктори в C# відрізняються від деструкторів в C++, де вони викликаються в той момент, коли об'єкт опиняється поза областю своєї ді ї.) Це означає, що наперед неможливо знати, коли саме слід викликати деструк тор. Крім того, програма може завершитися до того, як відбудеться "збірка сміття", а отже, деструктор може взагалі не бути викликаний. Нижче наведено приклад програми, що демонструє застосування деструктора. У цій програмі створюється і знищується велика кількість об'єктів. В якийсь моментпід час цього процесу активізується "збірка сміття" і викликаються деструктори для знищення непотрібних об'єктів.

Лістинг 7.16 - Приклад класу с деструктором

using System;
class Destruct {
    public int x;
    public Destruct(int i) {
        x = i;
    }
// Викликається при утилізації об'єкта.
    ~Destruct() {
        Console.WriteLine("Знищити " + х);
    }
// Створює об'єкт і одразу ж знищує його.
    public void Generator(int i) {
        Destruct о = new Destruct(i);
    }
}
class DestructDemo {
    static void Main() {
        int count;
        Destruct ob = new Destruct(0);
/* А тепер створити велику кількість об'єктів В якийсь момент відбудеться . "збірка сміття". Примітка: для того, щоб активувати
"збірку сміття", можливо, доведеться збільшити
кількість створюваних об'єктів. */
        for(count=1; count < 100000; count++)
            ob.Generator(count);
        Console.WriteLine( "Готово!");
    }
}

Ця програма працює наступним чином. Конструктор ініціалізує змінну х відомим значенням. У даному прикладі змінна х виступає в якості ідентифікатора об'єкта. А деструктор виводить значення змінної х , коли об'єкт утилізується. Особливий інтерес викликає метод Generator() , який створює і одразу ж знищує об'єкт типу Destruct. Спочатку в класі DestructDemo створюється початковий об'єкт ob типу Destruct, а потім здійснюється послідовне створення і знищення 100 тис. об'єктів. В різні моменти цього процесу відбувається "збірка сміття".

Наскільки часто вона відбувається - залежить від кількох факторів, включаючи початковий об'єм вільної пам'яті, тип використовуваної операційної си стеми і т.д. Проте в якийсь момент починають з'являтися повідомлення, формо вані деструктором. Якщо вони не з'являться до закінчення програми, тобто до того моменту, коли буде видано повідомлення "Готово!", спробуйте збільшити кількість створю ваних об'єктів, підвищивши максимальну кількість підраховуваних кроків у циклі for. І ще одне важливе зауваження : метод WriteLine() викликається в деструкторі ~Destruct() виключно для наочності даного прикладу його використання.

Зазвичай, деструктор повинен впливати лише на змінні екземпляра, визначені в його класі. У зв'язку з тим, що порядок виклику деструкторів не визначений точно, їх не слід застосовувати для виконання дій, які повинні відбуватися в певний момент виконання програми. У той же час є можливість запитувати " збірку сміття ", як буде показано в частині II цієї книги при розгляді бібліо теки класів С#. Проте ініціалізація "збірки сміття " вручну у більшості випадків не рекомендується, оскільки це може призвести до зниження ефектив ності програми. Крім того, у системи "збірки сміття " є свої особливості — навіть якщо запитати " збірку сміття " явно, все

одно неможливо заздалегідь знати, коли саме буде утилізований конкретний об'єкт.
