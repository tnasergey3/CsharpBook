---
layout: default
title: "5 6 7 8"
---

# 5 6 7 8

Відгук програміста: "Мені подобається C#."

Слід особливо підкреслити, що літеральні рядкові літерали виводяться у тому же вигляді, в якому вони введені у вихідному тексті програми.

Перевага літеральних рядкових літералів полягає в тому, що вони дозволяють вказати в програмі виведений результат саме так, як він повинен виглядати на екрані. Але якщо виводиться кілька рядків, то перехід на новий рядок може порушити порядок набору початкового тексту програми з відступами. Саме з цієї причини в прикладах програм, наведених у цій книзі, використання літеральних рядкових літералів обмежено. Тим не менш, вони приносять багато чудових переваг у багатьох випадках, коли потрібне форматування виведених результатів.

І останнє зауваження: не плутайте рядки з символами. Символьний літерал, на приклад 'X', позначає одиночну букву типу char. А рядок, що складається з одного символу, наприклад "X", залишається текстовим рядком.

### 2.2.10 Неявно типізовані змінні

Як пояснювалося вище, всі змінні в C# повинні бути оголошені. Зазвичай, при оголошенні змінної спочатку вказується тип, наприклад int або bool , а потім ім'я змінної. Але починаючи з версії C# 3.0, компілятору надається можливість самому визначити тип локальної змінної, виходячи зі значення, яким вона ініціалізується. Така змінна називається неявно типізованою.

Неявно типізована змінна оголошується за допомогою ключового слова var і обов'язково повинна бути ініціалізована. Для визначення типу цієї змінної компілятору служить тип її ініціалізатора, тобто значення, яким вона ініціюється. Розглянемо такий приклад (лістинг 2.30).

Лістинг 2.31 – Оголошення неявно типізованої змінної

var е = 2.7183;

У даному прикладі змінна е ініціалізується літералом з плаваючою крапкою, який за замовчуванням має тип double, тому вона відноситься до типу double. Якби змінна е була оголошена таким чином, як у лістингу 2.31, то вона була віднесена до типу float.

Лістинг 2.32 – Оголошення неявно типізованої змінної

var е = 2.7183F;

У наведеному нижче прикладі програми демонструється застосування неявно типізованих змінних. Він представляє собою варіант програми з попереднього розділу, змінений таким чином, щоб всі змінні були типізовані неявно.

Лістинг 2.33 – Застосування неявно типізованих змінних

// Показати застосування неявно типізованих змінних.

using System;

class ImplicitlyTypedVar

{

static void Main()

{

// Ці змінні типізовані неявно. Вони віднесені

// до типу double, оскільки ініціалізуючі їх

// вирази самі відносяться до типу double.

var s1 = 4.0;

var s2 = 5.0;

// Отже, змінна hypot неявно типізована і

// належить до типу double, оскільки результат,

// повернутий методом Sqrt(), має тип double.

var hypot = Math.Sqrt((s1 * s1) + (s2 * s2));

Console.Write("Гіпотенуза трикутника зі сторонами " +

s1 + " by " + s2 + " дорівнює ");

Console.WriteLine("{0:#.###}.", hypot);

// Наступний оператор не може бути скомпільований,

// оскільки змінна s1 має тип double і

// їй не можна присвоїти десяткове значення.

// s1 = 12.2М; // Помилка!

}

}

Результат виконання цієї програми виявляється таким самим, як і раніше. Важливо підкреслити, що неявно типізована змінна все ще залишається строго типізованою. Зверніть увагу на наступний закоментований рядок з вищезазначеної програми:

// s1 = 12.2М; // Помилка!

Ця операція присвоєння недійсна, оскільки змінна s1належить до типу double. Отже, їй не можна присвоїти десяткове значення. Єдина відмінність неявно типізованої змінної від звичайної, явно типізованої змінної, - у способі визначення її типу. Як тільки цей тип буде визначений, він закріплюється за змінною до кінця її існування. Це, зокрема, означає, що тип змінної s1 не може бути змінений під час виконання програми. Неявно типізовані змінні впроваджені в C# не для того, щоб замінити звичайні оголошення змінних. Навпаки, неявно типізовані змін ні призначені для особливих випадків, і найбільш помітний з них стосується мови інтегрованих запитів (LINQ). Отже, більшість оголошень змінних повинні і надалі залишатися явно типізованими, оскільки вони полегшують читання і розуміння вихідного тексту програми.

І останнє зауваження: одночасно можна оголосити лише одну неявно типізовану змінну. Тому оголошення є неправильним і не може бути скомпільованим (лістинг 2.33).

Лістинг 2.34 – Помилкове оголошення

var s1 = 4.0, s2 = 5.0; // Помилка!

Адже в ньому здійснюється спроба оголосити обидві змінні, s1 і s2, одночасно.

### 2.2.11 Область дії та час існування змінних

Усі змінні, що використовувалися в попередніх прикладах програм, оголошувалися на початку методу Main(). Але в C# дозволяється оголошувати локальну змінну в будь-якому кодовому блоці. Кодовий блок починається відкриваючою фігурною дужкою і закінчується закриваючою фігурною дужкою. Цей блок і визначає область дії. Отже, кожного разу, коли починається блок, утворюється нова область дії. Перш за все, область дії визначає видимість імен окремих елементів, включаючи змінні, в інших частинах про грами без додаткового уточнення. Вона також визначає час існування локальних змінних.

У C# до числа найважливіших належать області дії, визначені класом і методом. Розгляд області дії класу (і оголошених в ній змінних) доведеться відкласти до того моменту, коли в цій книзі будуть описуватися класи. А до того часу будуть розглядатися лише ті області дії, які визначаються методом або в самому методі.

Область дії, визначена методом, починається відкриваючою фігурною дужкою і закінчується закриваючою фігурною дужкою. Але якщо у цього методу є параметри, то вони також входять в область дії, визначену цим методом. Зазвичай, локальні змінні оголошуються в області дії, невидимій для коду, що знаходиться поза цією областю. Тому, оголошуючи змінну в певній області дії, ви таким чином захищаєте її від доступу або зміни за межами цієї області. Звичайно, правила області дії служать основою для інкапсуляції. Області дії можуть бути вкладеними. Наприклад, кожного разу, коли створюється кодовий блок, одночасно утворюється і нова, вкладена область дії. У цьому випадку зовнішня область дії охоплює внутрішню область. Це означає, що локальні змінні, оголошені в зовнішній області дії, будуть видимі для коду внутрішньої області дії. Але навпаки не є правдою: локальні змінні, оголошені внутрішньою областю дії, не будуть видимі поза цією областю.

Для того щоб стала більш зрозумілою сутність вкладених областей дії, розглянемо наступний приклад програми (лістинг 2.34).

Лістинг 2.35 – Область дії кодового блоку

// Показати область дії кодового блоку.

using System;

class ScopeDemo

{

static void Main()

{

int x; // Ця змінна доступна для всього коду всередині методу Main().

х = 10;

if (x == 10)

{ // почати нову область дії

int у = 20; // Ця змінна доступна тільки в даному кодовому блоку.

// Тут доступні обидві змінні, х і у.

Console.WriteLine("х і у: " + х + " " + у);

х = у * 2;

}

// у = 100; // Помилка! Змінна у тут недоступна.

// А змінна х тут все ще доступна.

Console.WriteLine("х дорівнює " + х);

}

}

Як пояснюється в коментарях до наведеної вище програми, змінна х оголошується на початку області дії методу Main() , і тому вона доступна для усього наступного коду в межах цього методу. У блоку умовного оператора if оголошується змінна у. А оскільки цей кодовий блок визначає свою власну область дії, то змінна у видима тільки для коду в межах даного блоку. Саме тому рядок line у = 100;, що знаходиться поза межами цього блоку, закоментований. Якщо видалити знаходяться перед нею символи коментаря ( // ), то під час компіляції програми станеться помилка, оскільки змінна у невидима за межами свого кодового блоку. У той же час змінна х може використовуватися в блоку умовного оператора if, оскільки коду з цього блоку, знаходячись у вкладеній області дії, доступні змінні, оголошені у зовнішній області дії, яка її оточує.

Змінні можуть бути оголошені в будь-якому місці кодового блоку, але вони стають дійсними лише після свого оголошення. Так, якщо оголосити змінну на початку методу, то вона буде доступна для всього іншого коду в межах цього методу. А якщо оголосити змінну в кінці блоку, то вона, по суті, буде непотрібною, оскільки не буде доступна жодному коду.

Якщо в оголошення змінної включається ініціалізатор, то така змінна ініціалізується повторно при кожному вході в той блок, в якому вона оголошена.

Розглянемо наступний приклад програми (лістинг 2.35).

Лістинг 2.36 – Демонстрація часу існування змінної

// Продемонструвати час існування змінної.

using System;

class VarInitDemo

{

static void Main()

{

int x;

for (x = 0; x < 3; x++)

{

int у = -1; // Змінна у ініціалізується при кожному вході в блок.

Console.WriteLine("у дорівнює: " + у); // Тут завжди виводиться -1

y = 100;

Console.WriteLine("у тепер дорівнює: " + у);

}

}

}

Нижче наведено результат виконання цієї програми.

у дорівнює: -1 у тепер дорівнює: 100

у дорівнює: -1 у тепер дорівнює: 100

у дорівнює: -1 у тепер дорівнює: 100

Як бачите, змінна уповторно ініціалізується одним і тим самим значенням -1 при кожному вході во внутрішній цикл for. І незважаючи на те, що після цього циклу їй присвоюється значення 100, воно втрачається при повторній її ініціалізації.

У мові C# є ще одна особливість дотримання правил області дії: незалежно від того, що блоки можуть бути вкладені, жодна змінна з внутрішньої області дії не повинна мати таке саме ім'я, як і змінна з зовнішньої області дії. У наведеному нижче прикладі програми підприємство пробує оголосити дві різні змінні з одним і тим самим ім'ям, і тому програма не може бути скомпільована (лістинг 2.36).

Лістинг 2.37 – Приклад неправильного оголошення

/*У цій програмі намагаються оголосити змінну з таким самим ім'ям, як і змін-

на, визначена в зовнішній області дії.

*** Цю програму не можна скомпілювати. ***

*/

using System;

class NestVar

{

static void Main()

{

int count;

for (count = 0; count < 10; count = count + 1)

{

Console.WriteLine("Це підрахунок: " + count);

int count; // Неприпустимо!!!

for (count = 0; count < 2; count++)

Console.WriteLine("У цій програмі є помилка!");

}

}

}

Якщо у вас є деякий досвід програмування на С або C++, то вам повинно бути відомо, що в цих мовах немає обмежень на присвоєння імен змінним, оголошеним во внутрішній області дії. Отже, в С і C++ оголошення змінної count в кодовому блоку, що входить в зовнішній цикл for , як у наведеному вище прикладі, вважається повністю допустимим. Але в С і C++ таке оголошення одночасно означає приховування зовнішньої змінної. Розробники C# вважають, що таке приховування імен може легко призвести до програмних помилок, і тому вирішили заборонити його.

### 2.2.12 Перетворення та приведення типів

У програмуванні часто значення змінних одного типу присвоюються змінним іншого типу. Наприклад, у наведеному нижче фрагменті коду ціле значення типу int присвоюється змінній з плаваючою точкою типу float (лістинг 2.37).

Лістинг 2.38 – Приклад неправильного оголошення

int i;

float f;

i = 10;

f = i; // присвоїти ціле значення змінній типу float

Якщо в одній операції присвоювання змішуються сумісні типи даних, то значення в правій частині оператора присвоювання автоматично перетворюється в тип, зазначений в лівій його частині. Тому в наведеному вище фрагменті коду значення змінної i спочатку перетворюється в тип float, а потім присвоюється змінній f . Але внаслідок строгого контролю типів далеко не всі типи даних у C# виявляються повністю сумісними, а отже, не всі перетворення типів дозволені в неявному вигляді. Наприклад, типи bool і int несумісні.

На жаль, перетворення несумісних типів все ж може бути здійснено шляхом приведення. Приведення типів, по суті, означає явне їх перетворення. У цьому розділі розглядається як автоматичне перетворення, так і при ведення типів.

### 2.2.13 Автоматичне перетворення типів

Коли дані одного типу присвоюються змінній іншого типу, неявне перетворення типів відбувається автоматично за наступних умов:

обидва типи сумісні;

діапазон представлення чисел цільового типу ширший, ніж у вихідного типу.

Якщо обидва ці умови виконуються, то відбуваєтьсярозширююче перетворення. Наприклад, тип int достатньо великий, щоб вміщати всі дійсні значення типу byte, а крім того, обидва типи, int і byte, є сумісними цілими числовими типами, і тому для них цілком можливе неявне перетворення.

Числові типи, як цілочисельні, так і з плаваючою точкою, повністю сумісні один з одним для виконання розширюючих перетворень. Так, наведена нижче програма складена абсолютно правильно, оскільки перетворення типу long в тип double є розширюючим і виконується автоматично (лістинг 2.38).

Лістинг 2.39 – Приклад автоматичного перетворення

// Показати неявне перетворення типу long в тип double.

using System;

class LtoD

{

static void Main()

{

long L;

double D;

L = 100123285L;

D = L;

Console.WriteLine("L і D: " + L + " " + D);

}

}

Якщо тип long може бути перетворений в тип double неявно, то зворотне перетворення типу double в тип long неявно неможливо, оскільки воно не є розширюючим. Отже, наведений нижче варіант попередньої програми складений неправильно (лістинг 2.39).

Лістинг 2.40 – Приклад програми з помилкою

// *** Ця програма не може бути скомпільована. ***

using System;

class LtoD

{

static void Main()

{

long L;

double D;

D = 100123285.0;

L = D; // Неприпустимо!!!

Console.WriteLine("L і D: " + L + " " + D);

}

}

Крім згаданих вище обмежень, не допускається неявне взаємне перетворення типів decimal і float або double, а також числових типів і char або bool. Крім того, типи char і bool несумісні один з одним.

### 2.2.14 Приведення несумісних типів

Незважаючи на всю корисність неявних перетворень типів, вони не здатні задовольнити всі потреби в програмуванні, оскільки допускають лише розширюючі перетворення сумісних типів. А в усіх інших випадках доводиться звертатися до приведення типів. Приведення — це команда компілятору перетворити результат обчислення виразу в зазначений тип. А для цього потрібне явне перетворення типів. Нижче наведена загальна форма приведення типів.

(цільовий_тип) вираз

Тут цільовий_тип означає той тип, в який бажано перетворити вказаний вираз. Розглянемо для прикладу наступне оголошення змінних.

double х, у;

Якщо результат обчислення виразу х/у повинен бути типу int , то слід написати наступне.

(int) (х / у)

Незважаючи на те, що змінні х і у належать до типу double , результат обчислення виразу х/у перетворюється в тип int завдяки приведенню. У даному прикла ді вираз х/у слід обов'язково вказувати в дужках, інакше приведення до типу int буде поширюватися тільки на змінну х , а не на результат її ділення на змінну у. Приведення типів у даному випадку потрібне, оскільки неявне перетворення типу double в тип int неможливе.

Якщо приведення типів приводить до звужувального перетворення, то частина інформації може бути втрачена. Наприклад, в результаті приведення типу long до типу int частина інформації буде втрачена, якщо значення типу long буде більше діапазону представлення чисел для типу int , оскільки старші розряди цього числового значе ння будуть відкинуті. Коли значення з плаваючою точкою приводиться до цілочисель ного, то в результаті обрізання втрачається дробова частина цього числового значення. Так, якщо присвоїти значення 1,23 цілочисельній змінній, то в результаті в ній залишиться лише ціла частина початкового числа (1), а дробова його частина (0,23) буде втрачена.

У наступному прикладі програми демонструється ряд перетворень типів, які потребують приведення. У цьому прикладі також показано ряд ситуацій, в яких приведення типів призводить до втрати даних (лістинг 2.40).

Лістинг 2.41 – Приклад приведення типів

// Показати приведення типів.

using System;

class CastDemo

{

static void Main()

{

double x, y;

byte b;

int i;

char ch;

uint u;

short s;

long 1;

x = 10.0;

у = 3.0;

// Приведення типу double до типу int, дробова частина числа втрачається.

i = (int)(х / у);

Console.WriteLine("Цілочисельний результат ділення х / у: " + i);

Console.WriteLine();

// Приведення типу int до типу byte без втрати даних,

i = 255;

b = (byte)i;

Console.WriteLine("b після присвоєння 255: " + b +

"--без втрати даних.");

// Приведення типу int до типу byte з втратою даних,

i = 257;

b = (byte)i;

Console.WriteLine("b після присвоєння 257: " + b +

"--з втратою даних.");

Console.WriteLine();

// Приведення типу uint до типу short без втрати даних.

u = 32000;

s = (short)u;

Console.WriteLine("s після присвоєння 32000: " +

s + "--без втрати даних.");

// Приведення типу uint до типу short з втратою даних,

u = 64000;

s = (short)u;

Console.WriteLine("s після присвоєння 64000: " +

s + "--з втратою даних.");

Console.WriteLine();

// Приведення типу long до типу uint без втрати даних.

l = 64000;

u = (uint)l;

Console.WriteLine("u після присвоєння 64000: " + u +

"--без втрати даних.");

// Приведення типу long до типу uint з втратою даних.

l = -12;

u = (uint)l;

Console.WriteLine("і після присвоєння -12: " + u +

"--з втратою даних.");

Console.WriteLine();

// Приведення типу int до типу char,

b = 88; // код ASCII символу X

ch = (char)b;

Console.WriteLine("ch після присвоєння 88: " + ch);

}

}

Ось який результат дає виконання цієї програми.

Цілочисельний результат ділення х / у: 3

b після присвоєння 255: 255 -- без втрати даних.

b після присвоєння 257: 1 -- з втратою даних.

s після присвоєння 32000: 32000 -- без втрати даних.

s після присвоєння 64000: -1536 -- з втратою даних.

u після присвоєння 64000: 64000 -- без втрати даних.

u після присвоєння -12: 4294967284 -- з втратою даних.

ch після присвоєння 88: X

Розглянемо кожну операцію присвоєння в показаному вище прикладі програми окремо. Внаслідок приведення результату ділення х/у до типу int відкидається дробова частина числа, а отже, втрачається частина інформації.

Коли змінній b присвоюється значення 255, то інформація не втрачається, оскільки це значення входить в діапазон представлення чисел для типу byte . Але коли змінній b присвоюється значення 257, то частина інформації втрачається, оскільки це значення перевищує діапазон представлення чисел для типу byte. Приведення типів потрібне в обох випадках, оскільки неявне перетворення типу int в тип byte неможливе.

Коли змінній s типу short присвоюється значення 32 000 змінній і типу uint, втрати даних не відбувається, оскільки це значення входить в діапазон представлення чисел для типу short. Але в наступній операції присвоєння змінній і має значення 64 000, яке виявляється поза діапазоном представлення чисел для типу short, і тому дані втрачаються. Приведення типів потрібне в обох випадках, оскільки неявне перетворення типу uint в тип short неможливе.

Далі змінній u присвоюється значення 64 000 змінній l типу long.

У цьому випадку дані не втрачаються, оскільки значення 64 000 виявляється поза діапазоном представлення чисел для типу uint . Але коли змінній u присвоюється значення -12, дані втрачаються, оскільки від'ємні числа також виявляються поза діапазоном представлення чисел для типу uint . Приведення типів потрібне в обох випадках, оскільки неявне перетворення типу long в тип uint неможливе.

І нарешті, коли змінній char присвоюється значення типу byte , інформація не втрачається, але приведення типів все ж потрібне.

### 2.2.15 Перетворення типів у виразу

Крім операцій присвоєння, конвертація типів відбувається і в самому виразі. У виразі можна вільно змішувати два або більше типи даних, за умови їх сумісності один з одним. Наприклад, в одному виразі допускається застосування типів short і long, оскільки обидва типи є числовими. Коли в виразі змішуються різні типи даних, вони перетворюються в один і той самий тип згідно з порядком операцій.

Конвертація типів виконується згідно з прийнятими в C# правилами просування типів. Нижче наведено алгоритм, визначений цими правилами для операцій з двома операндами.

ЯКЩО один операнд має тип decimal, ТО другий операнд просувається до типу decimal (але якщо другий операнд має тип floatабо double, результат буде неправильним).

ЯКЩО один операнд має тип double, ТО другий операнд просувається до типу double.

ЯКЩО один операнд має тип float, ТО другий операнд просувається до типу float.

ЯКЩО один операнд має тип ulong, ТО другий операнд просувається до типу ulong(але якщо другий операнд має тип sbyte, short, intабо long, результат буде неправильним).

ЯКЩО один операнд має тип long, ТО другий операнд просувається до типу long.

ЯКЩО один операнд має тип uint, а другий - тип sbyte, short або int, ТО обидва операнди просуваються до типу long.

ЯКЩО один операнд має тип uint, ТО другий операнд просувається до типу uint.

ІНАКШЕ обидва операнди просуваються до типу int.

Щодо правил продвиження типів необхідно зробити кілька важливих зауважень. По-перше, не всі типи можуть змішуватися в виразі. Зокрема, неявне перетворення типу float або double в тип decimal неможливе, як і змішування типу ulong з будь-яким цілочисельним типом зі знаком. Для змішування цих типів потрібне явне їх приведення.

По-друге, особливої уваги потребує останнє з наведених вище правил. Воно гласить: якщо жодне з попередніх правил не застосовується, то всі операнди переносяться до типу int. Отже, всі значення типу char, sbyte, byte, ushort і short переносяться до типу int для обчислення виразу. Таке перенесення типів називається цілочисельним. Це також означає, що результат виконання всіх арифметичних операцій матиме тип не нижче int.

Слід мати на увазі, що правила перенесення типів застосовуються лише до значень, якими операціють при обчисленні виразу. Так, якщо значення змінної типу byte переносяться до типу int всередині виразу, то поза виразом ця змінна все ще належить до типу byte. Перенесення типів стосується лише обчислення виразу.

Але просування типів іноді може призвести до неочікуваних результатів. Якщо, наприклад, в арифметичній операції використовуються два значення типу byte, то відбувається наступне. Спочатку операнди типу byte просуваються до типу int. А потім виконується операція, що дає результат типу int . Отже, результат виконання операції, в якій беруть участь два значення типу byte , буде мати тип int. Але це не той результат, який можна було б очікувати з очевидністю.

Розглянемо наступний приклад програми (лістинг 2.41).

Лістинг 2.42 – Приклад неочікуваного результату просування типів

// Приклад неочікуваного результату просування типів!

using System;

class PromDemo

{

static void Main()

{

byte b;

b = 10;

b = (byte)(b * b); // Необхідне приведення типів!!

Console.WriteLine("b: " + b);

}

}

Дивно, але коли результат обчислення виразу b*b присвоюється зворотно змінній b , виникає потреба в приведенні до типу byte! Це пояснюється тим, що в виразі b*b значення змінної b переміщується до типу int і тому не може бути присвоєне змінній типу byte без приведення типів. Майте це на увазі, якщо отримаєте неочікуване повідомлення про помилку несумісності типів в виразах, які, на перший погляд, здаються абсолютно правильними.

Аналогічна ситуація виникає при виконанні операцій з символьними операндами. Наприклад, у наступному фрагменті коду потрібне зворотне приведення до типу char, оскільки операнди ch1 і ch2 у виразі просуваються до типу int (лістинг 2.42).

Лістинг 2.43 – Приклад зворотного приведення

char ch1 = 'a', ch2 = 'b';

ch1 = (char) (ch1 + ch2);

Без приведення типів результат додавання операндів ch1і ch2 буде мати тип int, і тому його не можна присвоїти змінній типу char.

Просування типів відбувається і при виконанні унарних операцій, наприклад з унарним мінусом. Операнди унарних операцій меншого типу, ніж int(byte, sbyte, short і ushort), тобто з більш вузьким діапазоном представлення чисел, про двигаються до типу int. Те саме відбувається і з операндом типу char. Крім того, якщо виконується унарна операція заперечення значення типу uint, то результат про двигається до типу long.

### 2.2.16 Приведення типів у виразах

Приведення типів можна застосовувати і до окремих частин великого виразу. Це дозволяє точніше керувати перетвореннями типів при обчисленні виразу. Розглянемо наступний приклад програми, в якій виводяться квадратні корені чисел від 1 до 10 та окремо цілі та дробові частини кожного числового результату. Для цього в даній програмі застосовується приведення типів, завдяки якому результат, повернений методом Math.Sqrt(), перетворюється в тип int (лістинг 2.43).

Лістинг 2.44 – Приведення типів у виразах

// Приклад приведення типів у виразах.

using System;

class CastExpr

{

static void Main()

{

double n;

for (n = 1.0; n <= 10; n ++) {

Console.WriteLine("Квадратний корінь з {0} дорівнює {1}",

n, Math.Sqrt(n));

Console.WriteLine("Ціла частина числа: (0)",

(int)Math.Sqrt(n));

Console.WriteLine("Дробова частина числа:(0)",

Math.Sqrt(n) - (int)Math.Sqrt(n));

}

Console.WriteLine();

}

}

Ось як виглядає результат виконання цієї програми.

Квадратний корінь з дорівнює 1

Ціла частина числа: 1

Дробова частина числа: 0

Квадратний корінь з дорівнює 1.4142135623731

Ціла частина числа: Дробова частина числа1: 0.414213562373095

Квадратний корінь з дорівнює 1.73205080756888

Ціла частина числа: 1 Дробова частина числа: 0.732050807568877

Квадратний корінь з дорівнює 2

Ціла частина числа: 2

Дробова частина числа: 0

Квадратний корінь з дорівнює 2.23606797749979

Ціла частина числа: 2 Дробова частина числа: 0.23606797749979

Квадратний корінь з дорівнює 2.44948974278318

Ціла частина числа: 2 Дробова частина числа: 0.449489742783178

Квадратний корінь з дорівнює 2.64575131106459

Ціла частина числа: 2 Дробова частина числа: 0.645751311064591

Квадратний корінь з дорівнює 2.82842712474619

Ціла частина числа: 2 Дробова частина числа: 0.82842712474619

Квадратний корінь з дорівнює 3

Ціла частина числа: 3

Дробова частина числа: 0

Квадратний корінь з дорівнює 3.16227766016838

Ціла частина числа: 3 Дробова частина числа: 0.16227766016838

Як бачите, приведення результату, що повертає методMath.Sqrt(), до типу int дозволяє отримати цілу частину числа. Так, у виразі Math.Sqrt(n) - (int) Math.Sqrt(n),

приведення до типу int дає цілу частину числа, яка потім віднімається від всього числа, і в результаті отримується дробова його частина. Отже, результат обчислення цього виразу має тип double. Але до типу int приводиться лише значення, повернене другим методом Math.Sqrt().
