---
layout: default
title: "13.5 Перехоплення всіх винятків"
---

# 13.5 Перехоплення всіх винятків

Час від часу виникає потреба в перехопленні всіх винятків незалежно від їх типу. Для цієї цілі служить оператор catch, в якому тип і змінна винятку не вказуються. Нижче наведена загальна форма такого оператора. За допомогою такої форми створюється "універсальний" обробник всіх винятків, які перехоплюються в програмі. Нижче наведено приклад такого "універсального" обробника винятків. Зверніть увагу на те, що він перехоплює і обробляє обидва винятки, IndexOutOfRangeException і DivideByZeroException , які генеруються в програмі.

Лістинг 13.8 - Приклад обробки всіх винятків

class ExcDemo5

{

static void Main()

{

// Тут масив numer довший за масив denom.

int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };

int[] denom = { 2, 0, 4, 4, 0, 8 };

for (int i = 0; i < numer.Length; i++)

{

try

{

Console.WriteLine(numer[i] + " / " +

denom[i] + " дорівнює " +

numer[i] / denom[i]);

}

catch

{ // "Універсальний" перехоплювач.

Console.WriteLine("Виникла деяка виняткова ситуація.");

}

}

}

}

Застосовуючи "універсальний" перехоплення, слід мати на увазі, що його блок повинен розташовуватися останнім за порядком серед усіх блоків catch.
