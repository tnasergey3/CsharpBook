---
layout: default
title: "16.4 Директива using"
---

# 16.4 Директива using

Якщо в програмі часто використовуються посилання на члени конкретного простору імен, то вказувати цей простір імен кожного разу, коли потрібне посилання на нього, не дуже зручно. Директива using допомагає подолати це ускладнення. У більшості прикладів програм, які були наведені раніше, за допомогою цієї директиви було зроблено видимим глобальний простір імен System для C#, тому вона вже вам знайома. Як і очікувалося, за допомогою директиви using можна зробити видимими новостворені простори імен. Існують дві форми директиви using. Нижче наведена перша з них:

using ім'я;

де ім'я означає ім'я простору імен, до якого потрібно отримати доступ. Всі члени, визначені в зазначеному просторі імен, стають видимими і, отже, можуть використовуватися без додаткового визначення їх імені. Директиву using необхідно вводити на початку кожного файлу вихідного коду перед будь-якими іншими оголошеннями або на початку тіла простору імен. Наведена нижче програма є варіантом попереднього прикладу, переробленим з метою продемонструвати застосування директиви using, що робить видимим створюваний простір імен.

Лістинг 16.04 - Приклад використання директиви using

using System;
// Зробити видимим простір імен Counter.
using Counter;
// Оголосити простір імен для лічильників.
namespace Counter {
// Простий віднімаючий лічильник.
    class CountDown {
        int val;
        public CountDown(int n) {
            val = n;
        }
        public void Reset(int n) {
            val = n;
        }
        public int Count() {
            if(val > 0) return val++;
            else return 0;
        }
    }
}
class NSDemo3 {
    static void Main() {
// Тепер клас CountDown може бути використаний безпосередньо.
        CountDown cd1 = new CountDown(10);
        int i;
        do {
            i = cd1.Count();
            Console.Write(i + " ");
        } while(i > 0);
        Console.WriteLine();
        CountDown cd2 = new CountDown(20);
        do {
            i = cd2.Count();
            Console.Write(i + " ");
        } while(i > 0);
        Console.WriteLine();
        cd2.Reset(4);
        do {
            i = cd2.Count();
            Console.Write(i + " ");
        } while(i > 0);
        Console.WriteLine();
    }
}

У цій версії програми внесено дві суттєві зміни. Перше з них полягає в застосуванні директиви using на початку програми, як показано нижче. using Counter; Завдяки цьому стає видимим простір імен Counter. Друга зміна полягає в тому, що клас CountDown більше не потрібно додатково визначати з допомогою простору імен Counter, як показано нижче в рядку коду з методу Main(). CountDown cd1 = new CountDown(10); Тепер простір імен Counter становиться видимим , і тому клас CountDown може бути використаний безпосередньо.

Розглянута тут програма ілюструє ще одну важливу обставину: застосування одного простору імен не скасовує дію іншого. Коли простір імен стає видимим, це просто дає можливість використовувати його вміст без додаткового визначення імені. Отже, у цьому прикладі обидва простори імен, System і Counter , стають видимими.

Друга форма директиви using дозволяє визначити ще одне ім'я (так зване псевдонім ) типу даних або простору імен. Ця форма наведена нижче:

using псевдонім = ім'я;

Де псевдонім становиться ще одним ім'ям типу (наприклад, класу) або про стору імен, позначеного як ім'я. Після того, як псевдонім буде створений, його можна використовувати замість початкового імені. Нижче наведено варіант програми з попереднього прикладу, змінений з метою показати створення та використання псевдоніма MyCounter замість складеного імені Counter.CountDown.

Лістинг 16.05 - Приклад використання псевдоніма

// Створити псевдонім для складеного імені Counter.CountDown.
using MyCounter = Counter.CountDown;

class NSDemo4 {
    static void Main() {
// Тут і надалі псевдонім MyCounter використовується
// замість складеного імені Counter.CountDown.
        MyCounter cd1 = new MyCounter(10);
        int i;
        do {
            i = cd1.Count();
            Console.Write(i + " ");
        } while(i > 0);
        Console.WriteLine();
        MyCounter cd2 = new MyCounter(20);
        do {
            i = cd2.Count();
            Console.Write(i + " ");
        } while(i > 0);
        Console.WriteLine();
        cd2.Reset(4);
        do {
            i = cd2.Count();
            Console.Write(i + " ");
        } while(i > 0);
        Console.WriteLine();
    }
}

Псевдонім MyCounter створюється за допомогою наступного оператора. using MyCounter = Counter.CountDown; Після того, як псевдонім буде визначений як інше ім'я класу Counter.CountDown, його можна використовувати для оголошення об'єктів без додаткового визначення імені цього класу. Наприклад, у наступному рядку коду з розглянутої тут програми створюється об'єкт класу CountDown.
