---
layout: default
title: "13.1 Основи обробки виняткових ситуацій"
---

# 13.1 Основи обробки виняткових ситуацій

Обробка виняткових ситуацій в C# організовується за допомогою чотирьох ключових слів: try, catch, throw та finally. Вони утворюють взаємопов'язану підсистему, в якій застосування одного з ключових слів передбачає застосування іншого. Протягом цього розділу буде розглянуто призначення та застосування кожного згаданих вище ключових слів в деталях. Але спочатку необхідно дати загальне уявлення про роль кожного з них у обробці виняткових ситуацій. Тому нижче коротко описано принцип їх дії.

Оператори програми, які потрібно контролювати на появу винятків, заключаються в блок try. Якщо всередині блоку try виникає виняткова ситуація, генерується виняток. Цей виняток може бути перехоплений та оброблений якимось раціональним способом у коді програми за допомогою оператора, позначеного ключовим словом catch. Винятки, що виникають на рівні системи, генеруються виконавчою системою автоматично. А для генерування винятків вручну служить ключове слово throw. Будь-який код, який повинен бути обов'язково виконаний після виходу з блоку try , поміщається в блок finally.

Основу обробки виняткових ситуацій в C# складає пара ключових слів try і catch. Ці ключові слова діють разом і не можуть бути використані окремо. Нижче наведена загальна форма визначення блоків try/catch для обробки виняткових ситуацій.

Лістинг 13.1 - приклад try/catch

try {

// Блок коду, перевіряється на наявність помилок.

} catch (ExcepType1 exOb) {

// Обробник винятка типу ExcepType1.

}

catch (ExcepType2 exOb) {

// Обробник винятка типу ExcepType2.

}

де ExcepType – це тип виникаючої виняткової ситуації. Коли виняток генерується оператором try , він перехоплюється його парним оператором catch , який потім обробляє цей виняток. Залежно від типу винятка виконується відповідний оператор catch. Так, якщо типи генеруємого винятка й того, що вказується в операторі catch , співпадають, то виконується саме цей оператор, а всі інші пропускаються. Коли виняток перехоплюється, змінна винятка exOb отримує своє значення.

Насправді, вказувати змінну ехОb необов'язково. Так, її необов'язково вказувати, якщо обробнику винятків не потрібний доступ до об'єкту винятка, що часто буває. Для обробки винятка достатньо знати його тип. Саме тому в багатьох прикладах програм, наведених у цій главі, змінна ехОb пропускається.

Слід, однак, мати на увазі, що якщо виняток не генерується, то блок оператора try завершується як звичайно, і всі його оператори catch пропускаються. Виконання програми продовжується з першого оператора, що йде після завершального оператора catch. Таким чином, оператор catch виконується лише у випадку, якщо генерується виняток.

Розглянемо простий приклад, що демонструє відстеження та перехоплення винятка. Як вам має бути вже відомо, спроба індексувати масив за його межами призводить до помилки. Коли виникає подібна помилка, система CLR генерує виняток IndexOutOfRangeException, який визначений як стандартний для середовища .NET Framework. У наведеній нижче програмі такий виняток генерується навмисно і потім перехоплюється.

Лістинг 13.2 - Приклад перехоплення виключення IndexOutOfRangeException

using System;

class ExcDemol

{

static void Main()

{

int[] nums = new int[4];

try

{

Console.WriteLine("Перед генеруванням винятка.");

// Сгенерувати виняток у зв'язку з виходом індексу за межі масиву.

for (int i = 0; i < 10; i++)

{

nums[i] = i;

Console.WriteLine("nums[{0)]: {1}", i, nums[i]);

}

Console.WriteLine("He підлягає виводу");

}

catch (IndexOutOfRangeException)

{

// Перехопити виняток.

Console.WriteLine("Індекс вийшов за межі масиву!");

}

Console.WriteLine("Після блоку перехоплення винятка.");

}

}

У даному прикладі масив nums типу int складається з чотирьох елементів. Але в циклі for приймається спроба індексувати цей масив від 0 до 9, що і призводить до появи винятка IndexOutOfRangeException , коли звертається до елементу масиву за індексом 4. Незважаючи на всю свою краткість, наведений вище приклад наочно демонструє ряд основних моментів процесу обробки виняткових ситуацій. По-перше, код, який потрібно контролювати на наявність помилок, міститься в блоку try . По-друге, коли виникає виняткова ситуація (у даному випадку - при спробі індексувати масив nums за його межами в циклі for ), в блоку try генерується виняток, який потім перехоплюється в блоку catch . В цей момент виконання коду в блоку try завершується і керування передається блоку catch . Це означає, що оператор catch не викликається спеціально, а виконання коду переходить до нього автоматично. Отже, оператор, що містить метод WriteLine() і йде безпосередньо після циклу for , де відбувається вихід індексу за межі масиву, взагалі не виконується. А в завдання обробника винятків входить виправлення помилки, що призвела до виняткової ситуації, щоб продовжити виконання програми в нормальному режимі.

Зверніть увагу на те, що в операторі catch вказано лише тип винятку (у даному випадку — IndexOutOfRangeException ), а змінна винятку відсутня. Як зазначалося раніше, змінну винятку потрібно вказувати лише у випадку, якщо потрібний доступ до об'єкту винятку. У деяких випадках значення об'єкта винятку може бути використано обробником винятків для отримання додаткової інформації про саму помилку , але часто для обробки виняткової ситуації достатньо просто знати, що вона сталася . Тому змінна винятку часто відсутня в обробниках винятків, як у розглянутому тут прикладі.

Слід особливо підкреслити, що весь код, що виконується в блоку try, контролюється на предмет виняткових ситуацій, включаючи ті, які можуть виникнути в результаті виклику методу з самого блоку try. Виняток, що генерується методом в блоку try, може бути перехоплений в тому ж блоку, якщо, звичайно, цього не буде зроблено в самому методі.

Як ще один приклад розглянемо наступну програму, де блок try розміщується в методі Main() . З цього блоку викликається метод GenException() , в якому генерується виняток IndexOutOfRangeException. Цей виняток не перехоплюється методом GenException() . Але оскільки метод GenException() викликається з блоку try в методі Main() , то виняток перехоплюється в блоку catch , пов'язаному безпосередньо з цим блоком try .

Лістинг 13.3 - Виняток може бути згенерований одним методом і перехоплений іншим

class ExcTest

{

// Згенерувати виняток.

public static void GenException()

{

int[] nums = new int[4];

Console.WriteLine("Перед генеруванням винятка.");

// Згенерувати виняток через вихід індексу за межі

масиву.

for (int i = 0; i < 10; i++)

{

nums[i] = i;

Console.WriteLine("nums [{0}] : {1}", i, nums[i]);

}

Console.WriteLine("He підлягає виводу");

}

}

class ExcDemo2

{

static void Main()

{

try

{

ExcTest.GenException();

}

catch (IndexOutOfRangeException)

{

// Перехопити виняток.

Console.WriteLine("Індекс вийшов за межі масиву!");

}

Console.WriteLine("Після блоку перехоплення винятка.");

}

}

Як пояснювалося вище, метод GenException() викликається з блоку try, і тому генероване ним виняток перехоплюється не в ньому, а в блоку catch всередині методу Main(). А якби виняток перехоплювався в методі GenException(), він не був би переданий назад методу Main().
