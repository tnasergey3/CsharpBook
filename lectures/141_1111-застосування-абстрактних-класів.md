---
layout: default
title: "11.11 Застосування абстрактних класів"
---

# 11.11 Застосування абстрактних класів

Іноді потрібно створити базовий клас, в якому визначається лише найзагальніша форма для всіх його похідних класів, а наповнення її деталями надається кожному з цих класів. У такому класі визначається лише характер методів, які повинні бути конкретно реалізовані в похідних класах, а не в самому базовому класі. Подібна ситуація виникає, наприклад, у зв'язку з неможливістю отримати змістовну реалізацію методу в базовому класі. Саме така ситуація була продемонстрована у варіанті класу TwoDShape з попереднього прикладу, де метод Area() був просто визначений як заповнювач. Такий метод не обчислює і не виводить площу двовимірного об'єкта будь-якого типу.

Створюючи власні класи бібліотек, ви можете переконатися, що метод часто не має конкретного визначення в контексті його базового класу. Таку ситуацію можна вирішити двома способами. Один з них, як показано у попередньому прикладі, полягає в тому, щоб просто вивести попереджувальне повідомлення. Такий спосіб може бути корисним у певних ситуаціях, наприклад, при налагодженні, але в практиці програмування він зазвичай не застосовується. Адже в базовому у класі можуть бути оголошені методи, які повинні бути перевизначені в похідному класі, щоб цей клас став значущим. Розглянемо для прикладу клас Triangle. Він був би неповним, якби в ньому не був перевизначений метод Area() . У подібних випадках потрібний якийсь спосіб, що гарантує, що в похідному класі дійсно будуть перевизначені всі необхідні методи. І такий спосіб у C# існує. Він полягає в використанні абстрактного методу.

Абстрактний метод створюється за допомогою модифікатора типу abstract . У абстрактного методу відсутнє тіло, і тому він не реалізується в ба зовому класі. Це означає, що він повинен бути перевизначений в похідному класі, оскільки його варіант з базового класу просто непридатний для використання. Не складно здогадатися , що абстрактний метод автоматично стає віртуальним і не потребує вказівки модифікатора virtual . Насправді спільне використання модифікаторів virtual і abstract вважається помилкою

Для визначення абстрактного методу використовується загальна форма, наведена нижче. abstract тип ім'я(список_параметрів);

Як бачите, у абстрактного методу відсутнє тіло. Модифікатор abstract може застосовуватися тільки в методах екземпляра, а не в статичних методах ( static ). Абстрактними можуть бути також індексатори і властивості. Клас, що містить один або більше абстрактних методів, також повинен бути оголошений як абстрактний, і для цього перед його оголошенням class вказується модифікатор abstract . А оскільки реалізація абстрактного класу не визначається повністю , то у нього не може бути об'єктів.

Отже, спроба створити об'єкт аб страктного класу за допомогою оператора new призведе до помилки під час компіляції. Коли похідний клас успадковує абстрактний клас, в ньому повинні бути реалізовані всі абстрактні методи базового класу. У протилежному випадку похідний клас також повинен бути визначений як abstract . Отже, атрибут abstract успадковується до тих пір, поки не буде досягнута повна реалізація класу. Використовуючи абстрактний клас, ми можемо вдосконалити розглянутий раніше клас TwoDShape.

Для невизначеної двовимірної фігури поняття площі не має жодного сенсу, тому в наведеному нижче варіанті класу TwoDShape метод Area() і сам клас TwoDShape оголошуються як abstract . Це, звичайно, означає, що в усіх класах, похідних від класу TwoDShape , повинен бути перевизначений метод Area().

Лістинг 11.18 - Приклад абстрактного класу

using System.Xml.Linq;

abstract class TwoDShape

{

double pri_width;

double pri_height;

// Конструктор, використовуваний за замовчуванням.

public TwoDShape()

{

Width = Height = 0.0;

name = "null";

}

// Параметризований конструктор.

public TwoDShape(double w, double h, string n)

{

Width = w;

Height = h;

name = n;

}

// Побудувати об'єкт з однаковою шириною і висотою.

public TwoDShape(double х, string n)

{

Width = Height = x;

name = n;

}

// Сконструювати копію об'єкта TwoDShape.

public TwoDShape(TwoDShape ob)

{

Width = ob.Width;

Height = ob.Height;

name = ob.name;

}

// Властивості ширини і висоти об'єкта.

public double Width

{

get { return pri_width; }

set { pri_width = value < 0 ? value: value; }

}

public double Height

{

get { return pri_height; }

set { pri_height = value < 0 ? value: value; }

}

public string name { get; set; }

public void ShowDim()

{

Console.WriteLine("Ширина і висота дорівнюють " +

Width + " і " + Height);

}

// Тепер метод Area() є абстрактним.

public abstract double Area();

}

// Клас для трикутників, похідний від класу TwoDShape.

class Triangle : TwoDShape

{

string Style;

// Конструктор, використовуваний за замовчуванням.

public Triangle()

{

Style = "null";

}

// Конструктор для класу Triangle.

public Triangle(string s, double w, double h) :

base(w, h, "трикутник")

{

Style = s;

}

// Побудувати рівнобедрений трикутник,

public Triangle(double х) : base(x, "трикутник")

{

Style = "рівнобедрений";

}

// Побудувати копію об'єкта типу Triangle.

public Triangle(Triangle ob) : base(ob)

{

Style = ob.Style;

}

// Перевизначити метод Area() для класу Triangle.

public override double Area()

{

return Width * Height / 2;

}

// Показати тип трикутника.

public void ShowStyle()

{

Console.WriteLine("Трикутник " + Style);

}

}

// Клас для прямокутників, похідний від класу TwoDShape

class Rectangle : TwoDShape

{

// Конструктор для класу Rectangle.

public Rectangle(double w, double h) :

base(w, h, "прямокутник")

{ }

// Побудувати квадрат.

public Rectangle(double x) :

base(x, "прямокутник")

{ }

// Сконструювати копію об'єкта типу Rectangle.

public Rectangle(Rectangle ob) : base(ob) { }

// Повернути логічне значення true, якщо

// прямокутник виявиться квадратом.

public bool IsSquare()

{

if (Width == Height) return true;

return false;

}

// Перевизначити метод Area() для класу Rectangle.

public override double Area()

{

return Width * Height;

}

}

class AbsShape

{

static void Main()

{

TwoDShape[] shapes = new TwoDShape[4];

shapes[0] = new Triangle("прямокутний", 8.0, 12.0);

shapes[1] = new Rectangle(10);

shapes[2] = new Rectangle(10, 4);

shapes[3] = new Triangle(7.0);

for (int i = 0; i < shapes.Length; i++)

{

Console.WriteLine("Об'єкт — " + shapes[i].name);

Console.WriteLine("Площа дорівнює " + shapes[i].Area());

Console.WriteLine();

}

}

}

Як показує наведений вище приклад програми, в усіх похідних класах метод Area () повинен бути обов'язково перевизначений, а також оголошений аб страктним. Переконайтеся в цьому самі, спробувавши створити похідний клас, в якому не перевизначений метод Area() . У результаті ви отримаєте повідомлення про помилку під час компіляції. Звичайно, можливість створювати посилання на об'єкти типу TwoDShape по- прежньому існує, і це було зроблено в наведеному вище прикладі програми, але оголошувати об'єкти типу TwoDShape вже не можна. Саме тому масив shapes скорочений в методі Main() до 4 елементів, а об'єкт типу TwoDShape для загальної двох вимірної форми більше не створюється. Зверніть увагу, що класі TwoDShape надалі містить метод ShowDim() і він не оголошується з модифікатором abstract . В абстрактних класах допускається (і часто практикується) включення конкретних методів, які можуть бути використані в похідному класі у своєму початковому вигляді. Перевизначенню підлягають тільки ті методи в похідних класах, які оголошені як abstract.
