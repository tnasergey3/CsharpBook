---
layout: default
title: "14.5 Читання байтів з потоку файлового введення-виведення"
---

# 14.5 Читання байтів з потоку файлового введення-виведення

В класі FileStream визначені два методи для читання байтів з файлу : ReadByte() і Read(). Так, для читання одного байта з файлу використовується метод ReadByte(), загальна форма якого наведена нижче.

int ReadByte()

Кожного разу, коли цей метод викликається, з файлу зчитується один байт, який потім повертається у вигляді цілого значення. До числа ймовірних винятків, які генеруються при цьому, відносяться NotSupportedException (потік не відкритий для вводу) і ObjectDisposedException (потік закритий).

Для читання блоку байтів з файлу служить метод Read(), загальна форма якого виглядає так.

int Read(byte[ ] array, int offset, int count)

У методі Read() здійснюється спроба прочитати кількість count байтів в масив array, починаючи з елемента array [ offset ] . Він повертає кількість бай тів, успішно прочитаних з файлу. Якщо виникає помилка введення-виведення, то гене рується виняток IOException. До числа інших можливих винятків, які генеруються при цьому, відноситься NotSupportedException. Цей виняток гене рується у випадку, якщо читання з файлу не підтримується в потоці. У наведеному нижче прикладі програми метод ReadByte() використовується для введення та відображення вмісту текстового файлу, ім'я якого вказується в якості аргумента командного рядка. Зверніть увагу на те, що в цій програмі перевіряється, чи вказано ім'я файлу, перед тим як намагатися відкрити його.

Лістинг 14.2 -  Відобразити вміст текстового файлу

class ShowFile

{

static void Main(string[] args)

{

int i;

FileStream fin;

if (args.Length != 1)

{

Console.WriteLine("Застосування: ShowFile Файл");

return;

}

try

{

fin = new FileStream(args[0], FileMode.Open);

}

catch (IOException exc)

{

Console.WriteLine("Не вдається відкрити файл");

Console.WriteLine(exc.Message);

return; // Файл не відкривається, завершити програму

}

// Читати байти до кінця файлу.

try

{

do

{

i = fin.ReadByte();

if (i != -1) Console.Write((char)i);

} while (i != -1);

}

catch (IOException exc)

{

Console.WriteLine("Помилка читання файлу");

Console.WriteLine(exc.Message);

}

finally

{

fin.Close();

}

}

}

Зверніть увагу на те, що в наведеній вище програмі використовуються два блоки try. У першому з них перехоплюються винятки, що виникають при введенні- виведенні і можуть завадити відкриттю файлу. Якщо станеться помилка введення-виведення, виконання програми завершиться. У протилежному випадку в другому блоці try буде продовжено контроль винятків, що виникають у операціях введення- виведення. Отже, другий блок try виконується тільки у випадку, якщо в змінній fin міститься посилання на відкритий файл. Зверніть також увагу на те, що файл закривається в блоку finally , пов'язаному з другим блоком try . Це означа є, що незалежно від того, як завершиться цикл do-while (нормально або аварійно через помилку), файл все одно буде закритий. І хоча в даному конкретному прикладі це і так важливо, оскільки програма все одно завершиться в даній точці, перевага такого підходу, взагалі кажучи, полягає в тому, що файл закривається в за вершальному блоку finally у будь-якому випадку — навіть якщо виконання коду доступу до цього файлу завершується передчасно через який-небудь виняток.
