---
layout: default
title: "6.1 Масиви"
---

# 6.1 Масиви

Масив представляє собою сукупність змінних одного типу з загальним ім'ям для доступу до них. У C# масиви можуть бути як одновимірними, так і багатовимірними , хоча найчастіше використовуються одновимірні масиви. Масиви використовуються для різних цілей, оскільки вони надають зручні засоби для об'єднання пов'язаних змінних. Наприклад, у масиві можна зберігати максимальні денні температури, зареєстровані протягом місяця, перелік біржових курсів або назви книг з програмування з домашньої бібліотеки. Основна перевага масиву полягає в організації даних таким чином, щоб ними було легше маніпулювати. Наприклад, якщо є масив, що містить дивіденди, виплачувані за певною групою акцій, то, організувавши циклічний доступ до елементів цього масиву, можна без особливих зусиль розрахувати середній дохід від цих акцій. Крім того, масиви дозволяють організувати дані таким чином, щоб легко відсортувати їх. Масивами в C# можна користуватися практично так само, як і в інших мовах програмування. Тим не менш у них є одна особливість: вони реалізовані у вигляді об'єктів. Реалізація масивів у вигляді об'єктів надає ряд суттєвих переваг, і далеко не останнім серед них є можливість утилізувати невикористані масиви за допомогою "збору сміття".

### 6.1.1 Одновимірні масиви

Одновимірний масив представляє собою список зв'язаних змінних. Такі списки часто використовуються в програмуванні. Наприклад, в одновимірному масиві можна зберігати облікові номери активних користувачів мережі або поточні середні рівні досягнень бейсбольної команди.

Для того, щоб скористатися масивом у програмі, потрібна двоетапна процедура, оскільки в C# масиви реалізовані у вигляді об'єктів. По-перше, необхідно оголосити змінну, яка може звертатися до масиву. І по-друге, потрібно створити екземпляр масиву, використовуючи оператор new. Так, для оголошення одновимірного масиву зазвичай застосовується наступна загальна форма:

тип[] ім'я_масиву = new тип[розмір];

де тип оголошує конкретний тип елемента масиву. Тип елемента визначає тип даних кожного елемента, що складає масив. Зверніть увагу на квадратні дужки, які супроводжують тип . Вони вказують на те, що оголошується одновимірний масив. А розмір визначає кількість елементів масиву.

ПРИМІТКА. Якщо у вас є деякий досвід програмування на С або C++, зверніть особливу увагу на те, як оголошуються масиви в С#. Зокрема, квадратні дужки йдуть після назви типу, а не імені масиву.

Звернемося до конкретного прикладу. У наведеному нижче коді створюється масив типу int, який складається з десяти елементів і пов'язується зі змінною посилання на масив, що називається sample.

int[] sample = new int[10];

У змінній sample зберігається посилання на область пам'яті, виділену для масиву оператором new. Ця область пам'яті повинна бути достатньо великою, щоб в ній могли зберігатися десять елементів масиву типу int.

Як і при створенні екземпляра класу, наведене вище оголошення масиву можна розділити на два окремі оператори. Наприклад:

int[] sample;

sample = new int[10];

У цьому випадку змінна sample не посилається на який-небудь конкретний фі зичний об'єкт, коли вона створюється в першому операторі. І лише після виконання другого оператора ця змінна посилається на масив.

Доступ до окремого елемента масиву здійснюється за індексом: Індекс позначає положення елемента в масиві. У мові C# індекс першого елемента всіх масивів виявляється нульовим. Зокрема, масив sample складається з 10 елементів з індексами від 0 до 9. Для індексування масиву достатньо вказати номер потрібного елемента в квадратних дужках. Так, перший елемент масиву sample позначається як sample [0], а останній його елемент — як sample[9]. Нижче наведено приклад програми, в якій заповнюються всі 10 елементів масиву sample (лістинг 6.1).

Лістинг 6.1 – Відобразити одновимірний масив

// Показати одновимірний масив.

using System;

class ArrayDemo

{

static void Main()

{

int[] sample = new int[10];

int i;

for (i = 0; i < 10; i = i + 1)

sample[i] = i;

for (i = 0; i < 10; i = i + 1)

Console.WriteLine("sample[" + i + "]: " + sample[i]);

}

}

При виконанні цієї програми отримується наступний результат.

sample[0]: 0

sample[1]: 1

sample[2]: 2

sample[3]: 3

sample[4]: 4

sample[5]: 5

sample[6]: 6

sample[7]: 7

sample[8]: 8

sample[9]: 9

Схематично масив sample можна представити таким чином (рисунок 6.1).

Рисунок 6.1 – Схематичне представлення масиву

Масиви часто використовуються в програмуванні, оскільки вони дають можливість легко оперувати великою кількістю взаємопов'язаних змінних. Наприклад, у наведеній нижче програмі виявляється середнє арифметичне ряду значень, що зберігаються в масиві nums, який циклічно опитується за допомогою оператора циклу for (лістинг 6.2).

Лістинг 6.2 – Обчислення середнього арифметичного ряду значень

// Обчислити середнє арифметичне ряду значень.

using System;

class Average

{

static void Main()

{

int[] nums = new int[10];

int avg = 0;

nums[0] = 99;

nums[1] = 10;

nums[2] = 100;

nums[3] = 18;

nums[4] = 78;

nums[5] = 23;

nums[6] = 63;

nums[7] = 9;

nums[8] = 87;

nums[9] = 49;

for (int i = 0; i < 10; i++)

avg = avg + nums[i];

avg = avg / 10;

Console.WriteLine("Середнє: " + avg);

}

}

Результат виконання цієї програми виглядає наступним чином.

Середнє: 53

### 6.1.2 Ініціалізація масиву

У вищезазначеній програмі початкові значення були задані для елементів масиву nums вручну в десяти окремих операторах присвоєння. Звичайно, така ініціалізація масиву абсолютно правильна, але те саме можна зробити набагато простіше. Адже масиви можуть ініціалізуватися при їх створенні. Нижче наведена загальна форма ініціалізації одновимірного масиву:

тип[] ім'я_масиву = {vall, val2, val3, ..., valN};

де val1-valN означають початкові значення, які присвоюються по черзі, зліва направо і за порядком індексування. Для зберігання ініціалізаторів масиву в C# автоматично розподіляється достатня кількість пам'яті. А необхідність користуватися оператором new явно відпадає само собою. Як приклад нижче наведено поліпшену версію програми, що обчислює середнє арифметичне (лістинг 6.3).

Лістинг 6.3 – Обчислення середнього арифметичного ряду значень

// Обчислити середнє арифметичне ряду значень.

using System;

class Average

{

static void Main()

{

int[] nums = { 99, 10, 100, 18, 78, 23,

63, 9, 87, 49 };

int avg = 0;

for (int i = 0; i < 10; i++)

avg = avg + nums[i];

avg = avg / 10;

Console.WriteLine("Середнє: " + avg);

}

}

Цікаво, що при ініціалізації масиву також можна скористатися оператором new, хоча особливої потреби в цьому немає. Наприклад, наведений нижче фрагмент коду вважається правильним, але зайвим для ініціалізації масиву nums у згаданій вище програмі.

int[] nums = new int[] { 99, 10, 100, 18, 78, 23, 63, 9, 87, 49 };

Незважаючи на свою надмірність, форма ініціалізації масиву з оператором new виявляється корисною у випадку, якщо новий масив присвоюється вже існуючій змінній посилання на масив. Наприклад:

int[] nums;

nums = new int[] { 99, 10, 100, 18, 78, 23, 63, 9, 87, 49 };

У даному випадку змінна nums оголошується в першому операторі і ініціалізується в другому.

І останнє зауваження: при ініціалізації масиву його розмір можна вказувати явно, але цей розмір повинен збігатися з кількістю ініціалізаторів. Як приклад нижче наведено ще один спосіб ініціалізації масиву nums.

int[] nums = new int[10] { 99, 10, 100, 18, 78, 23, 63, 9, 87, 49 );

У цьому оголошенні розмір масиву nums задається явно рівним 10.

### 6.1.3 Дотримання меж масиву

Межі масиву в C# строго дотримуються. Якщо межі масиву не досягаються або перевищуються, то виникає помилка при виконанні. Щоб переконатися в цьому, спробуйте виконати наведену нижче програму, в якій навмисно перевищуються межі масиву (лістинг 6.4).

Лістинг 6.4 – Перевищення меж масиву

// Показати перевищення меж масиву.

using System;

class ArrayErr

{

static void Main()

{

int[] sample = new int[10];

int i;

// Відтворити перевищення меж масиву.

for (i = 0; i < 100; i = i + 1)

sample[i] = i;

}

}

Як тільки значення змінної i досягає 10, виникне виняткова ситуація типуIndexOutOfRangeException, пов'язана з виходом за межі індексування масиву, і програма передчасно завершиться.
