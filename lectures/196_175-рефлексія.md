---
layout: default
title: "17.5 Рефлексія"
---

# 17.5 Рефлексія

Рефлексія — це засіб, що дозволяє отримувати відомості про тип даних. Термін рефлексія, або відображення, походить від принципу дії цього засобу: об'єкт класу Туре відображає базовий тип, який він представляє. Для отримання інфор мації про тип даних об'єкту класу Туре роблять запити, а він повертає (відо бражає) назад інформацію, пов'язану з визначуваним типом. Рефлексія є ефективним механізмом, оскільки вона дозволяє виявляти і використовувати можли вості типів даних, відомі лише під час виконання. Багато класів, що підтримують відображення, входять до складу прикладного інтер фейсу .NET Reflection API, що належить до простору імен System.Reflection. Тому для застосування відображення в коді програми зазвичай вводиться наступний рядок.

using System.Reflection;

Клас System.Туре складає ядро підсистеми відображення , оскільки він ін капсулює тип даних. Він містить багато властивостей і методів, якими можна користуватися для отримання інформації про тип даних під час виконання. Клас Туре є похідним від абстрактного класу System.Reflection. MemberInfo. У класі MemberInfo визначені наведені нижче властивості, доступні тільки для читання.

Малюнок 17.1 - опис властивостей MemberInfo

Слід мати на увазі, що властивість MemberType повертає тип MemberTypes — перелік, в якому визначаються значення, що позначають різні типи членів. До них відносяться наступні.

MemberTypes.Constructor

MemberTypes.Method

MemberTypes.Field

MemberTypes.Event

MemberTypes.Property

Отже, тип члена можна визначити, перевіривши властивість MemberType. Так, якщо властивість MemberType має значення MemberTypes.Method, то перевіряється член, який є методом. До класу MemberInfo входять два абстрактних методи: GetCustomAttributes() і IsDefined() . Обидва методи пов'язані з атрибутами. Перший з них отримує список спеціальних атрибутів, що стосуються викликаючого об'єкта, а другий встановлює, чи визначений атрибут для викликаючого методу. У версію .NET Framework Version 4.0 введено метод GetCustomAttributesData() , що повертає інформацію про спеціальні атрибути. (Детальніше про атрибути буде розглянуто пізніше в цій главі.) Клас Туредодає багато власних методів і властивостей до тих, що визначені в класі MemberInfo. Нижче наведено приклади найбільш часто використовуваних методів класу ТуреМалюнок 17.2 - методи класу MemberInfo

Малюнок 17.3 - методи класу Type

За допомогою методів і властивостей класу Туре можна отримати детальну інформацію про тип даних під час виконання програми. Це досить ефективний засіб. Адже, отримавши інформацію про тип даних, можна відразу викликати його конструктори та методи або скористатися його властивостями. Отже, рефлексія дозволяє використовувати код, який не був доступний під час компіляції. Прикладний інтерфейс Reflection API досить обширний і тому не може бути повністю розглянутий у цій главі. Адже для цього знадобилася б ціла книга! Але прикладний інтерфейс Reflection API має зрозумілу логічну структуру, а тому, зрозумівши одну його частину, нескладно зрозуміти і все інше. Зважаючи на цю обставину, у наступних розділах демонструються чотири основні способи застосування рефлексії: отримання інформації про методи, виклик методів, кон струювання об'єктів та завантаження типів даних зі збірок.

Маючи в своєму розпорядженні об'єкт класу Туре, можна отримати список методів, підтримуваних окремим типом даних, використовуючи метод GetMethods(). Нижче наведена одна з форм, підходящих для цієї цілі.

MethodInfo[] GetMethods()

Цей метод повертає масив об'єктів класу MethodInfo , які описують методи, підтримувані викликаючим типом. Клас MethodInfo знаходиться в просторі імен System.Reflection. Клас MethodInfo є похідним від абстрактного класу MethodBase , який в свою чергу успадковує клас MemberInfо . Це дає можливість користуватися всіма властивостями і методами, визначеними в цих трьох класах. Наприклад, для отримання імені метода служить властивість Name . Особливий інтерес викликають два члени класу MethodInfo:ReturnType і GetParameters(). Повернений тип методу знаходиться в доступному тільки для читання властивості ReturnType, яка є об'єктом класу Туре. Метод GetParameters() повертає список параметрів, пов'язаних з аналізованим методом. Нижче наведена його загальна форма.

ParameterInfо[] GetParameters();

Інформація про параметри міститься в об'єкті класу ParameterInfо. У класі ParameterInfо визначено багато властивостей і методів , що описують параметри . Особливе значення мають дві властивості: Name — представляє собою рядок, що містить ім'я параметра, a ParameterType — описує тип параметра, який інкапсулюється в об'єкті класу Туре . Нижче наведено програму, в якій використовується відображення для отримання методів, підтримуваних класом MyClass . У цій програмі виводиться повернений тип і ім'я кожного методу, а також імена і типи будь-яких параметрів, які може мати кожен метод.

Лістинг 17.6 - Аналіз методів за допомогою відображення

using System;
using System.Reflection;
class MyClass {
    int x;
    int y;
    public MyClass(int i, int j) {
        x = i;
        у = j;
    }
    public int Sum() {
        return x+y;
    }
    public bool IsBetween(int i) {
        if(x < i && i < y) return true;
        else return false;
    }
    public void Set(int a, int b) {
        x = a;
        у = b;
    }
    public void Set(double a, double b) {
        x = (int) a;
        y = (int) b;
    }
    public void Show() {
        Console.WriteLine(" x: {0}, у: {1}", x, y);
    }
}
class ReflectDemo {
    static void Main() {
        Type t = typeof(MyClass); // отримати об'єкт класу Type,
// що представляє клас MyClass
        Console.WriteLine("Аналіз методів, визначених " +
                          "в класі " + t.Name);
        Console.WriteLine();
        Console.WriteLine("Підтримувані методи: ");
        MethodInfo[] mi = t.GetMethods();
// Вивести методи, підтримувані в класі MyClass.
        foreach(MethodInfo m in mi) {
// Вивести повернений тип і ім'я кожного методу.
            Console.Write(" " + m.ReturnType.Name + " " + m.Name + "(");
// Вивести параметри.
            ParameterInfo[] pi = m.GetParameters();
            for(int i=0; i < pi.Length; i++) {
                Console.Write(pi[i].ParameterType.Name + " " + pi[i],Name);
                if(i+1 < pi.Length) Console.Write(", ");
            }
            Console.WriteLine(")");
            Console.WriteLine();
        }
    }
}

Як тільки методи, підтримувані певним типом даних, стають відомими, їх можна викликати. Для цієї цілі служить метод Invoke() , що входить до складу класу MethodInfo . Нижче наведено одну з форм цього методу:

object Invoke(object obj, object[] parameters)

де obj позначає посилання на об'єкт, для якого викликається метод. Для виклику статичних методів ( static ) в якості параметра obj передається порожнє значення ( null ). Будь-які аргументи, які повинні бути передані методу, вказуються в масиві parameters. Якщо аргументи не потрібні, то замість масиву parameters вказується порожнє значення ( null ). Крім того, кількість елементів масиву parameters повинна точно відповідати кількості передаваних аргументів. Так, якщо потрібно передати два аргументи, то масив parameters повинен складатися з двох елементів, а не з трьох або чотирьох. Значення, яке повертається викликаним методом, передається методу Invoke(), який і повертає його. Для виклику конкретного методу достатньо викликати метод Invoke() для екземпляра об'єкта типу MethodInfo, отриманого при виклику методу GetMethods(). Ця процедура демонструється в наведеному нижче прикладі програми.

У попередньому прикладі при виклику методів, визначених у класі MyClass , переваги рефлексії не використовувалися, оскільки об'єкт типу MyClass створювався явно. У такому випадку було б набагато простіше викликати для нього методи звичайним способом. Але сильні сторони рефлексії проявляються найбільш помітно лише у випадку, якщо об'єкт створюється динамічно під час виконання. І для цього спочатку потрібно отримати список конструкторів, а потім екземпляр об'єкта заданого типу, викликавши один з цих конструкторів. Такий механізм дозволяє отримувати під час виконання екземпляр об'єкта будь-якого типу, навіть не вказуючи його ім'я у операторі оголошення. Конструктори конкретного типу отримуються при виклику метода GetConstructors() для об'єкта класу Туре . Нижче наведено одна з найбільш часто використовуваних форм цього методу.

ConstructorInfо[] GetConstructors()

Метод GetConstructors() повертає масив об'єктів класу ConstructorInfо, що описують конструктори. Клас ConstructorInfo є похідним від абстрактного класу MethodBase, який у свою чергу успадковує клас MemberInfо. В ньому також визначений ряд власних методів. До них відноситься цікавий нам метод GetConstructors(), що повертає список параметрів, пов'язаних з конструк тором. Цей метод діє так само, як і згадуваний раніше метод GetParameters(), визначений в класі MethodInfo. Як тільки буде знайдений відповідний конструктор, для створення об'єкта викликається метод Invoke() , визначений в класі ConstructorInfo . Нижче наведена одна з форм цього методу.

object Invoke(object[] parameters)

Будь-які аргументи, які потрібно передати методу, вказуються в масиві parameters. Якщо аргументи не потрібні, то замість масиву parameters використовується пусте значення ( null ). Але в будь-якому випадку кількість елементів масиву parameters повинна співпадати з кількістю передаваних аргументів, а типи аргументів - з типами параметрів. Метод Invoke() повертає посилання на сконструйований об'єкт. У наведеному нижче прикладі програми використовується рефлексія для створення екземпляра об'єкта класу MyClass.

Лістинг 17.7 - приклад аналізу конструкторів

using System;
using System.Reflection;class MyClass {
    int x;
    int y;
    public MyClass(int i) {
        Console.WriteLine("Конструювання класу MyClass(int, int). ");
        x = у = i;
    }
    public MyClass(int i, int j) {
        Console.WriteLine("Конструювання класу MyClass(int, int). ");
        x = i;
        У = j;
        Show();
    }
    public int Sum() {
        return x+y;
    }
    public bool IsBetween(int i) {
        if((x < i) && (i < y)) return true;
        else return false;
    }
    public void Set(int a, int b) {
        Console.Write("В методі Set(int, int). ");
        x = a;
        У = b;
        Show();
    }
// Перевантажити метод Set.
    public void Set(double a, double b) {
        Console.Write("У методі(double, double). ");
        x = (int) a;
        у = (int) b;
        Show();
    }
    public void Show() {
        Console.WriteLine("Значення x: {0}, значення у: {1}", x, у);
    }
}

class InvokeConsDemo {
    static void Main() {
        Type t = typeof(MyClass);
        int val;
// Отримати інформацію про конструктор.
        ConstructorInfо[] ci = t.GetConstructors();
        Console.WriteLine("Доступні конструктори: ");
        foreach(ConstructorInfo с in ci) {
// Вивести повернений тип і ім'я.
            Console.Write(" " + t.Name + "(");
// Вивести параметри.
            ParameterInfо[] pi = с.GetParameters();
            for(int i=0; i< pi.Length; i++) {
                Console.Write(pi[i].ParameterType.Name + " " + pi[i].Name);
                if(i+1 < pi.Length) Console.Write(", ");
            }
            Console.WriteLine (")");
        }
        Console.WriteLine();
        // Знайти відповідний конструктор.
        int х;
        for(x=0; х < ci.Length; х++) {
            ParameterInfо[] pi = ci[х].GetParameters();
            if(pi.Length == 2) break;
        }
        if(x == ci.Length) {
            Console.WriteLine("Відповідний конструктор не знайдено.");
            return;
        }
        else
            Console.WriteLine("Знайдено конструктор з двома параметрами. ");
// Сконструювати об'єкт.
        object[] consargs = new object[2];
        consargs[0] = 10;
        consargs[1] = 20;
        object reflectOb = ci[x].Invoke(consargs);
        Console.WriteLine(" Виклик методів для об'єкта reflectOb.");
        Console.WriteLine();
        MethodInfo[] mi = t.GetMethods();
// Викликати кожен метод.
        foreach(MethodInfo m in mi) {
// Отримати параметри.
            ParameterInfо[] pi = m.GetParameters();
            if(m.Name.CompareTo("Set")==0 &&
               pi[0].ParameterType == typeof(int)) {
// Це метод Set(int, int).
                object[] args = new object[2];
                args[0] = 9;
                args[1] = 18;
                m.Invoke(reflectOb, args);
            }
            else if(m.Name.CompareTo("Set")==0 &&
                    pi[0].ParameterType == typeof(double)) {
                // Це метод Set(double, double).
                object[] args = new object[2];
                args[0] = 1.12;
                args[1] = 23.4;
                m.Invoke(reflectOb, args);
            }
            else if(m.Name.CompareTo("Sum")==0) {
                val = (int) m.Invoke(reflectOb, null);
                Console.WriteLine("Сума дорівнює " + val);
            }
            else if(m.Name.CompareTo("IsBetween")==0) {
                object[] args = new object[1];
                args[0] = 14;
                if((bool) m.Invoke(reflectOb, args))
                    Console.WriteLine("Значення 14 знаходиться між x і у");
            }
            else if(m.Name.CompareTo("Show")==0) {
                m.Invoke(reflectOb, null);
            }
        }
    }
}

У попередньому прикладі всі дані про клас MyClass були отримані за допомогою рефлексії, за винятком одного елемента: типу самого класу MyClass . Незважаючи на те, що дані про клас отримувалися у попередньому прикладі динамічно, цей приклад базувався на тому факті, що ім'я типу MyClass було відомо наперед і використовувалося в операторі typeof для отримання об'єкта класу Туре , відносно якого здійснювалося косвенне або безпосереднє звернення до методів рефлексії. У деяких випадках такий підхід може бути досить придатним, але справжні переваги рефлексії проявляються лише тоді, коли доступні в програмі типи даних визначаються динамічно в результаті аналізу вмісту інших збірок.

Як випливає з розділу 16, збірка містить інформацію про класи, структури та інші елементи даних, які в ній містяться. Інтерфейс відображення Reflection API дозволяє завантажити збірку, отримати інформацію про неї та отримати екземпляри об'єктів будь-яких відкритих типів, що містяться в ній. З використанням цього механізму, програма може виявляти своє середовище та використовувати функціональні можливості, які можуть бути доступні без явного визначення під час компіляції. Це дуже ефективний і привабливий принцип. Уявіть собі, наприклад, програму, яка виконує роль "браузера типів", відображаючи типи даних, доступні в системі, або інструментальний засіб розробки, який дозволяє візуально складати програми з різних типів даних, що підтримуються в системі. І оскільки всю інформацію про типи можна отримати та перевірити, то обмежень на використання рефлексії практично не існує. Для отримання інформації про збірку спочатку потрібно створити об'єкт класу Assembly. У класі Assembly відкритий конструктор не визначається. Замість цього об'єкт класу Assembly отримується в результаті виклику одного з його методів. Таким чином, для завантаження збірки за її заданим ім'ям використовується метод LoadFrom() . Нижче наведена його відповідна форма:

static Assembly LoadFrom(string файл_збірки)

дефайл_збіркиозначає конкретне ім'я файлу збірки. Як тільки буде отриманий об'єкт класу Assembly , з'явиться можливість виявити певні типи даних в ньому, викликавши для нього метод GetTypes() у наведеній нижче загальній формі.

Туре[] GetTypes()

Цей метод повертає масив типів, що містяться в збірці. Для того, щоб продемонструвати порядок виявлення типів в збірці, потрібні два вихідних файли. Перший файл буде містити ряд класів, виявлених у коді з другого файлу.
