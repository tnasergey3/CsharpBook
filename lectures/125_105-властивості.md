---
layout: default
title: "10.5 Властивості"
---

# 10.5 Властивості

Ще одним видом члена класу є властивість. Зазвичай, властивість поєднує в собі поле з методами доступу до нього. Як було показано в попередніх прикладах програм , поле часто створюється, щоб стати доступним для користувачів об'єкта, але при цьому бажано зберегти контроль над операціями, дозволеними для цього поля, наприклад, обмежити діапазон значень, присвоєних даному полю. Цієї мети можна, звичайно, досягти і за допомогою закритої змінної, а також методів доступу до її значення, але властивість надає більш повний і раціональний шлях для досягнення тієї ж самої мети. Властивості дуже схожі на індексатори. Зокрема, властивість складається з імені та аксесорів get і set . Аксесори використовуються для отримання та встановлення значення змінної. Головною перевагою властивості є те, що її ім'я може бути використане в виразах та операторах присвоєння аналогічно імені звичайної змінної, але фактично при зверненні до властивості за ім'ям автоматично викликаються її аксесори get і set . Аналогічним чином використовуються аксесори get і set індексатора. Нижче наведено загальна форма властивості:

тип ім'я {

get { // код аксесора для читання з поля }

set { // код аксесора для запису в поле }

}

де тип означає конкретний тип властивості, наприклад int, а ім'я — присвоєне властивості ім'я. Як тільки властивість буде визначена, будь-яке звернення до властивості за іменем призведе до автоматичного виклику відповідного аксесора. Крім того, аксесор set приймає неявний параметр value, який містить значення, при присвоєному властивості.

Слід, однак, мати на увазі, що властивості не визначають місце в пам'яті для зберігання полів, а лише керують доступом до полів. Це означає, що сама властивість не надає поле, і тому поле повинно бути визначене незалежно від властивості. Нижче наведено простий приклад програми, в якій визначається властивість MyProp, призначена для доступу до поля prop. У цьому прикладі властивість допу скає присвоєння лише позитивних значень.

Лістинг 10.8 - Простий приклад застосування властивості.

class SimpProp

{

int prop; // поле, кероване властивістю МуРrор

public SimpProp() { prop = 0; }

/* Ця властивість забезпечує доступ до закритої змінної екземпляра prop.

Вона дозволяє присвоювати лише позитивні значення. */

public int MyProp

{

get

{

return prop;

}

set

{

if (value >= 0) prop = value;

}

}

}

class PropertyDemo

{

static void Main()

{

SimpProp ob = new SimpProp();

Console.WriteLine("Початкове значення ob.МуРrор: " + ob.МуРrор);

ob.МуРrор = 100; // присвоїти значення

Console.WriteLine("Поточне значення ob.МуРrор: " + ob.МуРrор);

// Змінній prop не можна присвоїти від'ємне значення.

Console.WriteLine("Спроба присвоїти значення " +

"-10 властивості ob.МуРrор");

ob.МуРrор = -10;

Console.WriteLine("Поточне значення ob.МуРrор: " + ob.МуРrор);

}

}

Розглянемо наведений вище код більш детально. У цьому коді визначається одне закрите поле propі властивість MyProp, що керує доступом до поля prop. Як пояснювалося вище, сама властивість не визначає місце в пам'яті для зберігання поля, а лише керує доступом до поля. Крім того, поле prop є закритим, а отже, воно доступне тільки через властивість MyProp. Властивість MyProp вказано як public, тому вона доступна з коду за межами його класу. І в цьому є своя логіка, оскільки дана властивість забезпечує доступ до поля prop, яке є закритим. Аксесор get цієї властивості просто повертає значення з поля prop, тоді як аксесор set встановлює зна чення в поле prop тільки у випадку, якщо це значення є додатнім. Отже, властивість MyProp контролює значення , які можуть зберігатися в полі prop. В цьому, власне, і полягає основне призначення властивостей. Тип властивості MyProp визначається як для читання, так і для запису, оскільки вона дозволяє читати і записувати дані в базове поле. Проте властивості можна створювати доступними тільки для читання або тільки для запису. Так, якщо потрібно створити властивість, доступну тільки для читання, то достатньо визначити єдиний аксесор get. А якщо потрібно створити властивість, доступну тільки для запису, то достатньо визначити єдиний аксесор set. Скористаємося властивістю для подальшого вдосконалення надійного масиву. Як вам має бути відомо, у всіх масивів є відповідне властивість довжини (Length). До цього часу в класіFailSoftArray для цієї цілі іс пользовалося відкрите цілочисельне поле Length. Але це далеко не найкращий підхід, оскільки він дозволяє встановлення значень, відмінних від довжини надійно стійкого масиву.  Для того щоб виправити це положення, перетворимо поле Length в властивість "тільки для читання", як по казано в наведеному нижче, зміненому варіанті класу FailSoftArray.

Лістинг 10.9 - Додати властивість Length в клас FailSoftArray

class FailSoftArray

{

int[] a; // посилання на базовий масив

int len; // довжина масиву - основа для властивості Length

public bool ErrFlag; // позначає результат останньої операції

// Побудувати масив заданого розміру.

public FailSoftArray(int size)

{

a = new int[size];

len = size;

}

// Властивість Length тільки для читання.

public int Length

{

get

{

return len;

}

}

// Це індексатор для класу FailSoftArray.

public int this[int index]

{

// Це аксесор get.

get

{

if (ok(index))

{

ErrFlag = false;

return a[index];

}

else

{

ErrFlag = true;

return 0;

}

}

// Це аксесор set.

set

{

if (ok(index))

{

a[index] = value;

ErrFlag = false;

}

else ErrFlag = true;

}

}

// Повернути логічне значення true, якщо

// індекс знаходиться в установлених межах.

private bool ok(int index)

{

if (index >= 0 & index < Length) return true;

return false;

}

}

// Показати застосування вдосконаленого

// масиву з відмовостійкістю.

class ImprovedFSDemo

{

static void Main()

{

FailSoftArray fs = new FailSoftArray(5);

int x;

// Дозволити читання властивості Length.

for (int i = 0; i < fs.Length; i++)

fs[i] = i * 10;

for (int i = 0; i < fs.Length; i++)

{

x = fs[i];

if (x != 1) Console.Write(x + " ");

}

Console.WriteLine();

}

// fs.Length = 10; // Помилка, запис заборонено!

}

Тепер Length - це властивість, в якій місцем для зберігання даних слугує закрита змінна len. А оскільки в цій властивості визначений єдиний акceccop get , то воно доступно тільки для читання. Це означає, що значення властивості Length можна тільки читати, але не змінювати. Для того, щоб переконатися в цьому, спробуйте видалити символи коментаря на початку наступного рядка з наведеного вище коду.
