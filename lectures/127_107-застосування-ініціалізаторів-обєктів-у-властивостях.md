---
layout: default
title: "10.7 Застосування ініціалізаторів об'єктів у властивостях"
---

# 10.7 Застосування ініціалізаторів об'єктів у властивостях

Як пояснювалося в розділі 8, ініціалізатор об'єкта застосовується як альтернатива явному виклику конструктора при створенні об'єкта. За допомогою ініціалізаторів об'єктів задаються початкові значення полів або властивостей, які потрібно ініціалізувати. При цьому синтаксис ініціалізаторів об'єктів виявляється однаковим як для властивостей, так і для полів. Як приклад нижче наведена програма з розділу 8, змінена з метою продемонструвати застосування ініціалізаторів об'єктів в властивостях. Нагадаємо, що в версії цієї програми з розділу 8 використовувалися поля, а наведена нижче версія відрізняється лише тим, що в ній поля Count і Str перетворені в властивості. У той же час синтаксис ініціалізаторів об'єктів не змінився.

Лістинг 10.10 - Застосувати ініціалізатори об'єктів в властивостях.

class MyClass

{

// Тепер це властивості.

public int Count { get; set; }

public string Str { get; set; }

}

class ObjInitDemo

{

static void Main()

{

// Побудувати об'єкт типу MyClass за допомогою ініціалізаторів об'єктів.

MyClass obj =

new MyClass { Count = 100, Str = "Тестування" };

Console.WriteLine(obj.Count + " " + obj.Str);

}

}

Як бачите, властивості Countі Strвстановлюються в виразах з ініціалізато ром об'єкта. Представлена вище програма дає такий самий результат, як і програма з глави 8, а саме: 100 Тестування Як пояснювалося в главі 8, синтаксис ініціалізатора об'єкта виявляється найбільш зручним для роботи з анонімними типами, формованими в LINQ-виразах. А в інших випадках найчастіше використовується синтаксис звичайних конструкторів.

Властивостям притаманний ряд суттєвих обмежень. По-перше, властивість не визначає місце для зберігання даних, тому не може бути передана методу як параметр ref або out . По-друге, властивість не підлягає перевантаженню. Допускається наявність двох різних властивостей з доступом до однієї й тієї ж змінної, але це, скоріше, виняток, ніж правило. І нарешті, властивість не повинна змінювати стан базо вої змінної при виклику аксесора get . І хоча компілятор не дотримується цього обмежувального правила, його порушення вважається семантичною помилкою. Дія аксесора get не повинна мати характер втручання в функціонування змінної.
