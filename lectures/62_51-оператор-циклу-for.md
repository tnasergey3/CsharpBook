---
layout: default
title: "5.1 Оператор циклу for"
---

# 5.1 Оператор циклу for

Оператор for вже був представлений, а тут він розглядається більш детально. Вас повинна приємно здивувати ефективність і гнучкість цього оператора. Перш за все, звернемося до найбільш основних і традиційних форм оператора for.

Нижче наведена загальна форма оператора for для повторного виконання єдиного оператора.

for (ініціалізація; умова; ітерація) оператор;

Ось як виглядає його форма для повторного виконання кодового блоку:

for (ініціалізація; умова; ітерація)

{

послідовність операторів;

}

де ініціалізація, зазвичай, представлена оператором присвоєння, що задає початкове значення змінної, яка виконує роль лічильника і керує циклом; умова— це логічний вираз, що визначає необхідність повторення циклу; а ітерація— вираз, що визначає величину, на яку має змінюватися значення змінної, яка керує циклом, при кожному повторенні циклу.

Зверніть увагу на те, що ці три основні частини оператора циклу for повинні бути розділені крапкою з комою. Виконання циклу for буде тривати до тих пір, поки перевірка умови дає істинний результат. Як тільки ця перевірка дасть хибний результат, цикл завершиться, а виконання програми буде продовжено з оператора, наступного після циклу for. Цикл for може тривати як у позитивному, так і у від'ємному напрямку, змінюючи значення змінної управління циклом на будь-яку величину.

У наведеному нижче прикладі програми виводяться числа поступово зменшуються від 100 до -100 на величину 5 (лістинг 5.1).

Лістинг 5.1 – Вивід чисел від 100 до -100, зменшуючи на величину 5

// Виконання циклу for в негативному напрямку.

using System;

class DecrFor

{

static void Main()

{

int x;

for (x = 100; x >= -100; x -= 5)

Console.WriteLine(x);

}

}

Щодо циклів for слід особливо підкреслити, що умовний вираз завжди перевіряється на початку циклу. Це означає, що код у циклі може взагалі не виконуватися, якщо перевірочний вираз з самого початку є хибним. Розглянемо наступний приклад (лістинг 5.2).

Лістинг 5.2 – Приклад, коли оператор не виконується

for (count=10; count < 5; count++)

x += count; // цей оператор не буде виконуватися

Даний цикл взагалі не буде виконуватися, оскільки початкове значення змінної count, яка ним керує, відразу стає більше 5. Це означає, що умовний вираз count < 5 виявляється хибним з самого початку, тобто ще до виконання першого кроку циклу.

Оператор циклу for –  найбільш корисний для повторного виконання операцій відому кількість разів. У наступному прикладі програми використовуються два цикли for для виявлення простих чисел в межах від 2 до 20. Якщо число виявляється не простим, то виводиться його найбільший множник (лістинг 5.3).

Лістинг 5.3 – Визначення чи є число простим

// Визначити, чи є число простим. Якщо воно

// непросте, вивести його найбільший множник.

using System;

class FindPrimes

{

static void Main()

{

int num;

int i;

int factor;

bool isprime;

for (num = 2; num < 20; num++)

{

isprime = true;

factor = 0;

// Визначити, чи ділиться значення змінної num націло.

for (i = 2; i <= num / 2; i++)

{

if ((num % i) == 0)

{

// Значення змінної num ділиться націло.

// Отже, це непросте число.

isprime = false;

factor = i;

}

}

if (isprime)

Console.WriteLine(num + " - просте число.");

else

Console.WriteLine("Найбільший множник числа " + num +

" дорівнює " + factor);

}

}

}

Нижче наведено результат виконання цієї програми.
