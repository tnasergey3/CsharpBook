---
layout: default
title: "15.1 Делегати"
---

# 15.1 Делегати

Почнемо з визначення поняття делегата. Просто кажучи, делегат представляє собою об'єкт, який може посилатися на метод. Отже, коли створюється делегат, то в результаті отримується об'єкт, що містить посилання на метод. Більше того, метод можна викликати за цим посиланням. Іншими словами, делегат дозволяє викликати метод, на який він посилається. Нижче буде показано, наскільки ефективним виявляється такий принцип.

Слід особливо підкреслити, що один і той самий делегат може бути використаний для виклику різних методів під час виконання програми, для чого достатньо змінити метод, на який посилається делегат. Отже, метод, який викликається делегатом, визначається під час виконання, а не в процесі компіляції. У цьому, саме, і полягає головна перевага делегата.

Тип делегата оголошується за допомогою ключового слова delegate. Нижче наведена загальна форма оголошення делегата: делегат повертаємий_тип ім'я(список_параметрів); де повертаємий_тип означає тип значення, яке повертають методи, які будуть викликатися делегатом; ім'я — конкретне ім'я делегата; список_параметрів — параметри, необхідні для методів, які викликаються делегатом. Як тільки буде створено екземпляр делегата, він може викликати і посилатися на ті методи, повертаємий тип і параметри яких відповідають зазначеним у оголошенні делегата. Найголовніше, що делегат може служити для виклику будь-якого методу з відповідною сигнатурою і повертаємим типом. Більше того, викликаний метод може бути методом екземпляра, пов'язаним з окремим об'єктом, або ж статичним методом, пов 'язаним з конкретним класом. Значення має лише одне: повертаємий тип і сигнатура методу повинні бути узгоджені з тими, які зазначені в оголошенні делегата.

Лістинг 15.1 - Простий приклад застосування делегата

using System;

// Оголосити тип делегата.

delegate string StrMod(string str);

class DelegateTest

{

// Замінити пробіли дефісами.

static string ReplaceSpaces(string s)

{

Console.WriteLine("Заміна пробілів дефісами.");

return s.Replace(' ', '');

}

// Видалити пробіли.

static string RemoveSpaces(string s)

{

string temp = "";

int i;

Console.WriteLine("Видалення пробілів.");

for (i = 0; i < s.Length; i++)

if (s[i] != ' ') temp += s[i];

return temp;

}

// Обернути рядок.

static string Reverse(string s)

{

string temp = "";

int i, j;

Console.WriteLine("Обертання рядка.");

for (j = 0, i = s.Length-1; i >= 0; i--, j++)

temp += s[i];

return temp;

}

static void Main()

{

// Створити делегат.

StrMod strOp = new StrMod(ReplaceSpaces);

string str;

// Викликати методи за допомогою делегата.

str = strOp("Це простий тест.");

Console.WriteLine("Результуючий рядок: " + str);

Console.WriteLine();

strOp = new StrMod(RemoveSpaces);

str = strOp("Це простий тест.");

Console.WriteLine("Результуючий рядок: " + str);

Console.WriteLine();

strOp = new StrMod(Reverse);

str = strOp("Це простий тест.");

Console.WriteLine("Результуючий рядок: " + str);

}}

Розглянемо данний приклад більш детально. У його коді спочатку оголошується делегат StrMod типу string , як показано нижче. delegate string StrMod(string str); Як бачите, делегат StrMod приймає один параметр типу string і повертає одне значення того ж типу.

Далі в класі DelegateTest оголошуються три статичні методи з одним параметром типу string і повертають значення того ж типу. Отже, вони відповідають делегату StrMod . Ці методи змінюють рядок у різних формах. Зверніть увагу, що в методі ReplaceSpaces() для заміни пробілів дефісами використовується один з методів типу string — Replace() . У методі Main()створюється змінна екземпляра strOp посиланням на тип StrMod і потім їй присвоюється посилання на методReplaceSpaces(). Зверніть особливу увагу на наступний рядок коду.

StrMod strOp = new StrMod(ReplaceSpaces);

У цьому рядку метод ReplaceSpaces() передається як параметр. При цьому вказується лише його ім'я, а не параметри. Цей приклад можна узагальнити: при отриманні екземпляра делегата достатньо вказати лише ім'я методу, на який повинен посилатися делегат. Зрозуміло, що сигнатура методу повинна збігатися з тією, що вказана в оголошенні делегата. У протилежному випадку під час компіляції виникне помилка. Потім методReplaceSpaces()викликається за допомогою екземпляра делегата strOp, як показано нижче

str = strOp("Це простий тест.");

Екземпляр делегата strOp посилається на метод ReplaceSpaces() , тому викликається саме цей метод. Потім екземпляру делегата strOpприсвоюється посилання на методRemoveSpaces(), і з його допомогою знову викликається вказаний метод - на цей разRemoveSpaces(). Нарешті, екземпляру делегата strOp присвоюється посилання на метод Reverse(). І в результаті викликається саме цей метод. Основний висновок з цього прикладу полягає в наступному: в той момент, коли звертається до екземпляру делегата strOp, викликається метод, на який він посилається. Отже, виклик методу вирішується під час виконання, а не в процесі компіляції.
