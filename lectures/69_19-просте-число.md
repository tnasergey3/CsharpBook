---
layout: default
title: "19 – просте число"
---

# 19 – просте число

### 5.1.1 Різновиди оператора циклу for

Оператор циклу for відноситься до найбільш універсальних операторів мови С#, оскільки він допускає найрізноманітніші варіанти його застосування. Деякі різновидності оператора циклу for розглядаються нижче.

#### 5.1.1.1 Застосування кількох змінних управління циклом

У операторі циклу for дозволяється використовувати дві або більше змінних для управління циклом. У цьому випадку оператори ініціалізації та інкремента кожної змінної розділяються комою. Розглянемо наступний приклад програми (лістинг 5.4).

Лістинг 5.4 – Використання ком у операторі циклу for

// Використання ком у операторі циклу for.

using System;

class Comma

{

static void Main()

{

int i, j;

for (i = 0, j = 10; i < j; i++, j--)

Console.WriteLine("i and j: " + i + " " + j);

}

}

Виконання цієї програми дає наступний результат.

i j: 0 10

i and j: 1 9

i and j: 2 8

i and j: 3 7

i and j: 4 6

У даному прикладі комами розділяються два оператори ініціалізації та ще два ітераційних вирази. Коли цикл починається, ініціалізуються обидві змінні, i і j . Кожного разу, коли цикл повторюється, змінна i інкрементується, а змінна j декрементується. Застосування кількох змінних управління циклом часто є зручним, спрощуючи деякі алгоритми. Теоретично у операторі циклу for може бути будь-яка кількість операторів ініціалізації та ітерації, але на практиці цикл виходить занадто громіздким, якщо застосовується більше двох подібних операторів.

Нижче наведено практичний приклад застосування кількох змінних управління циклом в операторі for . У цьому прикладі програми використовуються дві змінні управління одним циклом for для виявлення найбільшого і най меншого множника цілого числа (у даному випадку – 100). Зверніть особливу увагу на умову закінчення циклу. Вона базується на обох змінних управління циклом (лістинг 5.5).

Лістинг 5.5 – Виявлення найменшого та найбільшого множника числа

// Використовувати коми в операторі циклу for для

// виявлення найменшого і найбільшого множника числа.

using System;

class Comma

{

static void Main()

{

int i, j;

int smallest, largest;

int num;

num = 100;

smallest = largest = 1;

for (i = 2, j = num / 2; (i <= num / 2) & (j >= 2); i++, j--)

{

if ((smallest == 1) & ((num % i) == 0))

smallest = i;

if ((largest == 1) & ((num % j) == 0))

largest = j;

}

Console.WriteLine("Найбільший множник: " + largest);

Console.WriteLine("Найменший множник: " + smallest);

}

}

Нижче наведено результат виконання цієї програми.

Найбільший множник: 50

Найменший множник: 2

Завдяки застосуванню двох змінних управління циклом вдається виявити най менший і найбільший множники числа в одному циклі for . Зокрема, управляюча змінна i служить для виявлення найменшого множника. Спочатку її значення встановлюється рівним 2, а потім інкрементується до тих пір, поки не перевищить половину значення змінної num. А управляюча змінна j служить для виявлення найбільшого множника. Її значення спочатку встановлюється рів ним половині значення змінної num, а потім декрементується до тих пір, поки не стане менше 2. Цикл продовжує виконуватися до тих пір, поки обидві змінні, i і j , не досягнуть своїх кінцевих значень. Після завершення циклу обидва множники виявляються.

#### 5.1.1.2 Умовний вираз

Умовним виразом, що керує циклом for, може бути будь-який дійсний вираз, що повертає значення типу bool. Він не обов'язково повинен містити змінну керування циклом. У наступному прикладі програми керування циклом for здійснюється за допомогою значення змінної done.

Лістинг 5.6 – Керування циклом for за допомогою значення змінної

// Умовою виконання циклу може бути будь-який вираз типу bool.

using System;

class forDemo

{

static void Main()

{

int i, j;

bool done = false;

for (i = 0, j = 100; !done; i++, j--)

{

if (i * i >= j) done = true;

Console.WriteLine("i, j: " + i + " " + j);

}

}

}

Нижче наведено результат виконання цієї програми.

i, j: 0 100

i, j: 1 99

i, j: 2 98

i, j: 3 97

i, j: 4 96

i, j: 5 95

i, j: 6 94

i, j: 7 93

i, j: 8 92

i, j: 9 91

i, j: 10 90

У даному прикладі цикл for повторюється до тих пір, поки значення змінної done типу не стане істинним ( true ). Істинне значення змінної done встановлюється в циклі, коли квадрат значення змінної i становиться більшим або рівним значенню змінної j.

#### 5.1.1.3 Відсутні частини циклу

Ряд цікавих різновидностей циклу for виникає у випадку, якщо залишити порожніми окремі частини визначення циклу. У C# дозволяється залишати порожніми будь-які або всі частини ініціалізації, умови та ітерації в операторі циклу for. На прикладі розглянемо таку програму (лістинг 5.7).

Лістинг 5.7 – Окремі частини циклу for можуть залишатися порожніми.

// Окремі частини циклу for можуть залишатися порожніми.

using System;

class Empty

{

static void Main()

{

int i;

for (i = 0; i < 10;)

{

Console.WriteLine("Прохід #" + i);

i++; // інкрементувати змінну управління циклом

}

}

}

У даному прикладі ітераційний вираз в визначенні циклу for виявляється порожнім, тобто він взагалі відсутній. Замість цього змінна i, що керує циклом, інкрементується в тілі самого циклу. Це означає, що кожного разу, коли цикл повторюється , значення змінної i перевіряється на рівність числу 10, але жодних інших дій при цьому не відбувається. А оскільки змінна i інкрементується в тілі циклу, то сам цикл виконується звичайним чином, виводячи наведений нижче результат.

Прохід №0

Прохід №1

Прохід №2

Прохід №3

Прохід №4

Прохід №5

Прохід №6

Прохід №7

Прохід №8

Прохід №9

У наступному прикладі програми з визначення циклу for виключена ініціалізуюча частина (лістинг 5.8).

Лістинг 5.8 – Виключення ще одну частину з for

// Виключити ще одну частину з визначення циклу for.

using System;

class Empty2

{

static void Main()

{

int i;

i = 0; // виключити ініціалізацію з визначення циклу

for (; i < 10;)

{

Console.WriteLine("Прохід #" + i);

i++; // інкрементувати змінну управління циклом

}

}

}

У даному прикладі змінна i ініціалізується перед початком циклу, а не в самому циклі for. Зазвичай, змінна управління циклом ініціалізується в циклі for. Виведення ініціалізуючої частини за межі циклу зазвичай робиться лише у випадку, якщо початкове значення цієї змінної отримується в результаті складного процесу, який нецілеспрямовано вводити в операторі циклу for.

#### 5.1.1.4 Нескінченний цикл

Якщо залишити порожнім вираз умови в операторі циклу for , то отримається нескінченний цикл, тобто такий цикл, який ніколи не закінчується. Як приклад в наступному фрагменті коду показано, яким чином у С# зазвичай створюється нескінченний цикл.

for ( ; ; ) // цикл, навмисно зроблений нескінченним

{

//...

}

Цей цикл буде виконуватися нескінченно. Незважаючи на те, що нескінченні цикли потрібні для вирішення деяких задач програмування, наприклад при розробці командних процесорів операційних систем, більшість так званих "нескінченних" циклів насправді представляють собою цикли зі спеціальними вимогами до завершення (докладніше про це - у розділі "Застосування оператора break для виходу з циклу" далі в цьому розділі).

#### 5.1.1.5 Цикли без тіла

У C# допускається залишати порожнє тіло циклу for або будь-якого іншого циклу, оскільки порожній оператор з точки зору синтаксису цієї мови вважається дійсним. Цикли без тіла часто бувають корисними. Наприклад, у наступній програмі цикл без тіла використовується для отримання суми чисел від 1 до 5 (лістинг 5.9).

Лістинг 5.9 – Цикл без тіла для отримання суми чисел

//  Тіло циклу може бути порожнім.

using System;

class Empty3

{

static void Main()

{

int i;

int sum = 0;

// отримати суму чисел від 1 до 5

for (i = 1; i <= 5; sum += i++) ;

Console.WriteLine("Сума дорівнює " + sum);

}

}

Виконання цієї програми дає наступний результат.

Сума дорівнює 15

Зверніть увагу на те, що процес сумування виконується повністю у операторі циклу for , і для цього тіло циклу не потрібне. У цьому циклі особливу увагу звертається на ітераційний вираз.

sum +=  i++;

Подібні оператори не повинні вас збивати з пантелику. Вони часто зустрічаються в програмах, професійно написаних на C#, і стають зрозумілими, якщо розібрати їх на частини. Дослівно наведений вище оператор означає наступне: додати до значення змінної sum результат сумування значень змінних sum та i, а потім інкрементувати значення змінної i. Отже, даний оператор еквівалентний наступній послідовності операторів.

sum = sum + i;

i++;

#### 5.1.1.6 Оголошення керуючих змінних в циклі for

Часто змінна, що керує циклом for, потрібна лише для виконання самого циклу і ніде більше не використовується. У такому випадку керуючу змінну можна оголосити в ініціалізуючій частині оператора циклу for. Наприклад, у наведеній нижче програмі обчислюється сума і факторіал чисел від 1 до 5, а змінна i, що керує циклом for , оголошується в цьому циклі (лістинг 5.10).

Лістинг 5.10 – Обчислення суми та факторіалу чисел від 1 до 5

// Оголосити змінну керування циклом в самому циклі for.

using System;

class ForVar

{

static void Main()

{

int sum = 0;

int fact = 1;

// обчислити факторіал чисел від 1 до 5

for (int i = 1; i <= 5; i++)

{

sum += i;  // Змінна i діє в циклі.

fact *= i;

}

// А тут змінна i недоступна.

Console.WriteLine("Сума дорівнює " + sum);

Console.WriteLine("Факторіал дорівнює " + fact);

}

}

Оголошуючи змінну в циклі for, не слід забувати, що область дії цієї змінної обмежується межами оператора циклу for. Це означає, що поза межами циклу дія даної змінної припиняється. Так, у наведеному вище прикладі змінна i виявляється недоступною поза межами циклу for. Для того щоб використовувати змінну управління циклом в якомусь іншому місці програми, її не можна оголошувати в циклі for.

Перш ніж переходити до наступного матеріалу, спробуйте експериментувати з власними варіантами оператора циклу for. Під час експерименту ви обов'язково виявите чудові властивості цього оператора циклу.
