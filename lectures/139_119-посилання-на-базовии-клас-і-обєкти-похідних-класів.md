---
layout: default
title: "11.9 Посилання на базовий клас і об'єкти похідних класів"
---

# 11.9 Посилання на базовий клас і об'єкти похідних класів

Як вам вже повинно бути відомо, C# є строго типізованою мовою програмування. Крім стандартних перетворень і автоматичного про движення простих типів значень , в цій мові строго дотримується принцип сумісності типів. Це означає, що змінна посилання на об'єкт класу одного типу, зазвичай, не може посилатися на об'єкт класу іншого типу. Як приклад розглянемо наступну програму, в якій оголошуються два класи однакової структури.

Лістинг 11.14 -  Приклад програми

class X

{

int а;

public X(int i) { a = i; }

}

class Y

{

int a;

public Y(int i) { a = i; }

}

class IncompatibleRef

{

static void Main()

{

X x = new X(10);

X x2;

Y у = new Y(5);

x2 = x; // правильно, оскільки обидва об'єкти належать до одного й того ж типу

х2 = у; // помилка, оскільки це різнотипні об'єкти

}

}

Незважаючи на те, що класи X і Y у цьому прикладі абсолютно однакові за своєю структурою, посилання на об'єкт типу Y не можна присвоїти змінній посилання на об'єкт типу X, оскільки типи у них різні. Тому наступний рядок коду виявляється неправильним і може призвести до помилки через несумісність типів під час компі ляції.

х2 = у; // неправильно, оскільки це різнотипні об'єкти

Загалом, змінна посилання на об'єкт може посилатися тільки на об'єкт свого типу. Але з цього принципу строгого дотримання типів в C# є одне важливе виняток: змінній посилання на об'єкт базового класу може бути присвоєно посилання на об' єкт будь-якого похідного від нього класу. Таке присвоєння вважається повністю неприпустимим, оскільки екземпляр об'єкта похідного типу інкапсулює екземпляр об' єкта базового типу. Отже, за допомогою посилання на об'єкт базового класу можна звертатися до об'єкта похідного класу. Нижче наведено відповідний приклад.

Лістинг 11.15 - З посиланням на об'єкт базового класу можна звертатися

class X

{

public int a;

public X(int i)

{

a = i;

}

}

class Y : X

{

public int b;

public Y(int i, int j) : base(j)

{

b = i;

}

}

class BaseRef

{

static void Main()

{

X x = new X(10);

X x2;

Y у = new Y(5, 6);

x2 = x; // правильно, оскільки обидва об'єкти належать до одного й того ж типу

Console.WriteLine("х2.а: " + х2.а);

х2 = у; // також правильно, оскільки клас Y є похідним від класу X

Console.WriteLine("х2.а: " + х2.а);

// посиланням на об'єкти класу X відомо тільки про члени класу X

х2.а = 19; // правильно

// х2.b = 27; // неправильно, оскільки член b відсутній у класі X

}}

Слід особливо підкреслити, що доступ до конкретних членів класу визначається типом змінної посилання на об'єкт, а не типом об'єкта, на який вона посилається. Це означає, що якщо посилання на об'єкт похідного класу присвоюється змінній посилання на об'єкт базового класу, то доступ дозволяється лише до тих частин цього об'єкта, які визначаються базовим класом. Саме тому змінній х2 недоступний член b класу Y , коли вона посилається на об'єкт цього класу. І в цьому є своя логіка, оскільки базовому класу нічого не відомо про ті члени, які додані в похідний від нього клас. Саме тому останній рядок коду в наведеному вище прикладі був закоментований. Незважаючи на здавалося б незначно відволікаючий характер наведених вище розсуджень, їх можна знайти кілька важливих застосувань на практиці. Одне з них роз глядається нижче, а інше - далі в цьому розділі, коли йдеться про віртуальні методи.
