---
layout: default
title: "10.1 Створення одновимірних індексаторів"
---

# 10.1 Створення одновимірних індексаторів

Як вам вже повинно бути відомо, індексування масиву здійснюється за допомогою оператора []. Для створюваних класів можна визначити оператор [], але для цієї мети замість операторного методу створюється індексатор, який дозволяє індексувати об'єкт, подібно до масиву. Індексатори застосовуються, головним чином, як засіб, що підтримує створення спеціалізованих масивів, на які накладається одне або кілька обмежень. Тим не менш, індексатори можуть служити практично будь-яким цілям, для яких вигідним виявляється такий самий синтаксис, як і у масивів. Індексатори можуть бути одно - або багатовимірними. Спочатку розглянемо одновимірні індексатори.

Нижче наведена загальна форма одновимірного індексатора:

тип_елементу this[int індекс] {

// Аксесор для отримання даних.

get { // Повернення значення, яке визначає індекс. }

// Аксесор для встановлення даних.

set { // Встановлення значення, яке визначає індекс. }

}

де тип_елементу означає конкретний тип елемента індексатора. Отже, у кожного елемента, доступного за допомогою індексатора, повинен бути визначений тип_елементу . Цей тип відповідає типу елемента масиву. Параметр індекс отримує конкретний індекс елемента, до якого здійснюється доступ. Формально цей параметр зовсім не обов'язково повинен мати тип int , але оскільки індексато ри, як правило, застосовуються для індексування масивів, то найчастіше використовується цілочисельний тип даного параметра. У тілі індексатора визначені два аксесори (тобто засоби доступу до даних): get і set. Аксесор схожий на метод, за винятком того, що в ньому не оголошується тип поверненого значення або параметри. Аксесори викликаються автоматично при використанні індексатора, і обидва отримуютьіндексяк параметр. Так, якщо індексатор вказується в лівій частині оператора присвоєння, то викликається аксесор set і встановлюється елемент, на який вказує параметр індекс . В іншому випадку викликається аксесор getі повертається значення, що відповідає параметру індекс. Крім того, аксесор set отримує неявний параметр value , що містить значення, призначене за вказаним індексом. Перевага індексатора полягає, зокрема, в тому, що він дозволяє повністю керувати доступом до масиву, уникнувши небажаного доступу. Як приклад розглянемо програму, в якій створюється клас FailSoftArray , що реалізує масив для виявлення помилок порушення меж масиву, а отже, для запобігання виникненню виключних ситуацій, що виникають під час виконання у зв'язку з індексуванням масиву за його межами. Для цього масив інкапсулюється як закрите поле класу, а доступ до нього здійснюється лише за допомогою індексатора. При такому підході виключається будь-яка спроба отримати доступ до масиву за його межами, причому ця спроба припиняється без катастрофічних наслідків для програми. А оскільки в класі FailSoftArray використовується індексатор, то до масиву можна звертатися за допомогою звичайної форми запису.

Лістинг 10.01 - Приклад одномірних індексів

using System;

class FailSoftArray

{

int[] a; // посилання на базовий масив

public int Length; // відкрита змінна довжини масиву

public bool ErrFlag; // позначає результат останньої операції

// Побудувати масив заданого розміру.

public FailSoftArray(int size)

{

a = new int[size];

Length = size;

}

// Це індексатор для класу FailSoftArray.

public int this[int index]

{

// Це аксесор get.

get

{

if (ok(index))

{

ErrFlag = false;

return a[index];

}

else

{

ErrFlag = true;

return 0;

}

}

// Це аксесор set.

set

{

if (ok(index))

{

a[index] = value;

ErrFlag = false;

}

else ErrFlag = true;

}

}

// Повернути логічне значення true, якщо

// індекс знаходиться в установлених межах.

private bool ok(int index)

{

if (index >= 0 & index < Length) return true;

return false;

}

}

Індексатор запобігає порушенню меж масиву. Уважно проаналізуємо кожну частину коду індексатора. Він починається з наступного рядка.

public int this[int index] { У цьому рядку коду оголошується індексатор, що працює з елементами типу int . Йому передається індекс у якості параметра index. Крім того, індексатор оголошується відкритим ( public ), що дає можливість використовувати цей індексатор у коді за межами його класу. Розглянемо наступний код аксесора get.

Лістинг 10.2 - код аксесора get

get {

if(ok(index)) {

ErrFlag = false;

return a[index];

} else {

ErrFlag = true;

return 0;

}

Аксесор get запобігає помилкам порушення меж масиву, перевіряючи спочатку , чи знаходиться індекс у встановлених межах. Ця перевірка меж ви повнюється в методі ok() , який повертає логічне значення true , якщо індекс правильний, а інакше - логічне значення false . Так, якщо вказаний індекс на знаходиться б встановлених межах, то за цим індексом повертається відповідний елемент. А якщо індекс виявляється поза встановленими межами, то жодних опе рацій не виконується , але в той же час не виникає жодних помилок переповнення. У цьому варіанті класу FailSoftArray змінна ErrFlag містить результат кожної операції. Її вміст можна перевірити після кожної операції на успішне або неуспішне виконання останньої.  А тепер розглянемо наступний код аксесора set, що запобігає помилкам порушення меж масиву.

Лістинг 10.3 - код аксесора set

set {

if(ok(index)) {

a[index] = value;

ErrFlag = false;

}

else ErrFlag = true;

}

повідному елементу масиву присвоюється значення, передане з параметра value . У протилежному випадку встановлюється логічне значення true змінній ErrFlag . Нагадаємо, що value у будь-якому аксесорному методі є неявним параметром, що містить присвоюване значення. Його не потрібно (і навіть неможливо) окремо оголошувати. Наявність обох аксесорів, get і set, в індексаторі не є обов'язковою. Так, можна створити індексатор тільки для читання, реалізувавши в ньому лише аксесор get, або ж індексатор тільки для запису з єдиним аксесором set.
