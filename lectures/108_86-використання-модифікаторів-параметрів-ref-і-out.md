---
layout: default
title: "8.6 Використання модифікаторів параметрів ref і out"
---

# 8.6 Використання модифікаторів параметрів ref і out

Як пояснювалося вище, аргументи простих типів, наприклад int або char передаються методу за значенням. Це означає, що зміни, внесені в параметр, що приймає значення, не будуть мати жодного впливу на аргумент, використаний для виклику. Але таку поведінку можна змінити, використовуючи ключові слова ref і out для передачі значень звичайних типів за посиланням. Це дозволяє змінити в самому методі аргумент, вказаний при його виклику. Перш ніж переходити до особливостей використання ключових слів ref і out, корисно зрозуміти причини, чому значення простого типу іноді потрібно передавати за посиланням. Загалом, для цього існують дві причини: дозволити методу змінити вміст його аргументів або повернути кілька значень. Розглянемо кожну з цих причин більш детально. даються за значенням, то, використовуючи вибраний в C# за замовчуванням механізм виклику за значенням для передачі аргумента параметру, неможливо написати метод, що змінює місцями значення двох його аргументів, наприклад типу int . Цю складність роз рішує модифікатор ref .

Як вам вже повинно бути відомо, значення повертається з методу викликаючої частини програми за допомогою оператора return . Але метод може одночасно повернути лише одне значення. А що, якщо з методу потрібно повернути два або більше фрагменти інформації, наприклад, цілу і дробову частини числового значення з плаваючою точкою? Такий метод можна написати, використовуючи модифікатор out .

Модифікатор параметра ref примусово організовує виклик за посиланням, а не за значенням. Цей модифікатор вказується як при оголошенні, так і при викликуметоду. Для початку розглянемо простий приклад. У наведеній нижче програмі створюється метод Sqr(), який повертає замість свого аргумента квадрат його цілочисельного значення. Зверніть особливу увагу на застосування та розташування модифікато ра ref.

Лістинг 8.5 - Приклад використання оператора ref

using System;
class RefTest {
// Цей метод змінює свій аргумент. Зверніть
// увагу на використання модифікатора ref.
    public void Sqr(ref int i) {
        i = i * i;
    }
}
class RefDemo {
    static void Main() {
        RefTest ob = new RefTest();
        int a = 10;
        Console.WriteLine("до виклику: " + a);
        ob.Sqr(ref a); // зверніть увагу на використання модифікатора ref
        Console.WriteLine("після виклику: " + а);
    }
}

Як бачите, модифікатор refвказується перед оголошенням параметра в самому методі і перед аргументом при виклику методу. Нижче наведено результат виконання даної програми, який підтверджує, що значення аргумента а дійсно було змінено за допомогою методу Sqr() до виклику 10 після виклику 100.

Тепер, використовуючи модифікатор ref , можна написати метод, який переміщує значення двох своїх аргументів простого типу. Нижче наведено програму якприклад, в якій метод Swap() виконує обмін значеннями двох своїх цілих аргументів при виклику.

Лістинг 8.6 - Обміняти місцями два значення.

using System;
class ValueSwap {
// Цей метод обмінює свої аргументи місцями.
    public void Swap(ref int a, ref int b) {
        int t;
        t = a;
        a = b;
        b = t;
    }
}
class ValueSwapDemo {
    static void Main() {
        ValueSwap ob = new ValueSwap();
        int x = 10, у = 20;
        Console.WriteLine("x і у до виклику: " + х + " " + у);
        ob.Swap(ref х, ref у);
        Console.WriteLine("х і у після виклику: " + х + " " + у);
    }
}

Щодо модифікатора ref слід мати на увазі наступне. Аргументу, переданому за посиланням за допомогою цього модифікатора, повинно бути присвоєно значення до виклику методу. Справа в тому, що в методі, який отримує такий аргумент як параметр, передбачається, що параметр посилається на дійсне значення. Отже, при використанні модифікатора ref в методі не можна задати початкове значення аргумента.

Іноді посилальний параметр потрібно використовувати для отримання значення з методу, а не для передачі йому значення. Припустимо, що є метод, який виконує певну функцію, наприклад, відкриття мережевого сокету і повернення коду успішнго або невдачного завершення даної операції в якості посилального параметра.

У цьому випадку методу не передається жодної інформації, але в той же час він повинен повернути певну інформацію. Головна складність при цьому полягає в тому, методу. Отже, щоб скористатися параметром типу ref , доведеться задати для аргумента фіктивне значення і таким чином подолати дане обмеження. Справді, в C# є більш підходящий варіант виходу з подібної складності — скористатися модифікатором параметра out .

Модифікатор параметра out схожий на модифікатор ref , за винятком одного: він служить лише для передачі значення поза межі методу. Тому змінній, що використовується як параметр out , не потрібно (і навіть непотрібно) присвоювати яке-небудь значення. Більше того, в методі параметр out вважається неініціалізованим, тобто припускається, що він не має початкового значення.

Це означає, що значення повинно бути присвоєне даному параметру в методі до його завершення. Отже, після виклику методу параметр out буде містити яке-небудь значення. Нижче наведено приклад застосування модифікатора параметра out. У цьому прикладі програми для розділення числа з плаваючою точкою на цілу і дробову частини використовується метод GetParts() з класу Decompose. Зверніть увагу на те, як повертається кожна частина початкового числа.

Лістинг 8.7 - Використовувати модифікатор параметра out.

using System;
class Decompose {
/* Розділити числове значення з плаваючою точкою на
цілу і дробову частини. */
    public int GetParts(double n, out double frac) {
        int whole;
        whole = (int) n;
        frac = n % whole; // передати дробову частину числа через параметр frac
        return whole; // повернути цілу частину числа
    }
}
class UseOut {
    static void Main() {
        Decompose ob = new Decompose();
        int i;
        double f;
        i = ob.GetParts(10.125, out f);
        Console.WriteLine("Ціла частина числа дорівнює " + i); Console.WriteLine("Дробова частина числа дорівнює " + f);
    }
}

Застосування модифікаторів ref і out не обмежується лише передачею значе нь звичайних типів. За допомогою них також можна передавати посилання на об'єкти. Якщо модифікатор ref або out вказує на посилання, то саме посилання передається за посиланням.

Це дозволяє змінити в методі об'єкт, на який вказує посилання. Розглянемо як приклад наступну програму, в якій посилальні параметри типу ref використовуються для зміни об'єктів, на які вказують посилання.

Лістинг 8.8 - Поміняти місцями дві посилання.

using System;
class RefSwap {
    int a, b;
    public RefSwap(int i, int j) {
        a = i;
        b = j;
    }
    public void Show() {
        Console.WriteLine("a: {0}, b: {l}", a, b);
    }
// Цей метод змінює свої аргументи.
    public void Swap(ref RefSwap ob1, ref RefSwap ob2) {
        RefSwap t;
        t = ob1;
        ob1 = ob2;
        ob2 = t;
    }
}

class RefSwapDemo {
    static void Main() {
        RefSwap x = new RefSwap(1, 2);
        RefSwap у = new RefSwap(3, 4);
        Console.Write("x до виклику: ");
        x.Show();
        Console.Write("у до виклику: ");
        у.Show();
        Console.WriteLine();
// Зміна об'єктів, на які посилаються аргументи х і у.
        х.Swap(ref х, ref у);
        Console.Write("х після виклику: ");
        х.Show();
        Console.Write("у після виклику: ");
        у.Show();
    }
}

У цьому прикладі в методі Swap() виконується зміна об'єктів, на які посилаються два його аргументи. До виклику методу Swap() аргумент х посилається на об'єкт, що містить значення 1 і 2, тоді як аргумент у посилається на об'єкт, що містить значення 3 і 4. А після виклику методу Swap() аргумент х посилається на об'єкт, що містить значення 3 і 4, тоді як аргумент у посилається на об'єкт, що містить значення 1 і 2. Якби не параметри типу ref , то перестановка в методі Swap() не мала б жодних наслідків поза межами цього методу. Щоб переконатися в цьому, виключіть параметри типу ref з методу Swap().
