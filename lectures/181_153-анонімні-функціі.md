---
layout: default
title: "15.3 Анонімні функції"
---

# 15.3 Анонімні функції

Метод, на який посилається делегат, часто використовується лише для цієї цілі. Іншими словами, єдиним підставою для існування методу є те об ставина, що його можна викликати за допомогою делегата, але сам він не викликається взагалі. У таких випадках можна скористатися анонімною функцією, щоб не створювати окремий метод. Анонімна функція, по суті, представляє собою безіменний кодовий блок, переданий конструктору делегата. Перевага ано німної функції полягає, зокрема, в її простоті. Завдяки їй відпадає необхідність оголошувати окремий метод, єдина мета якого полягає в тому, що він передається делегату.

Починаючи з версії 3.0, в C# передбачені два види анонімних функцій: анонімні методи та лямбда-вирази. Анонімні методи були впроваджені в C# ще в версії 2.0, а лямбда-вирази - в версії 3.0. В цілому лямбда-вираз поліпшує принцип дії анонімного методу і наразі вважається більш переваги для створення анонімної функції. Але анонімні методи широко застосовуються в існуючому коді C# і тому залишаються важливою складовою частиною C#. А оскільки анонімні методи передували по появі лямбда-виразів, то чітке уявлення про них дозволяє краще зрозуміти особливості лямбда-виразів. Крім того, анонімні методи можуть бути використані в цілому ряді випадків, де застосування лямбда-виразів виявляється неможливим. Саме тому в цій главі розглядаються і анонімні методи, і лямбда- вирази.

Анонімний метод - один з способів створення безіменного блоку коду, пов'язаного з конкретним екземпляром делегата. Для створення анонімного методу достатньо вказати кодовий блок після ключового слова delegate . Покажемо, як це робиться, на конкретному прикладі. У наведеній нижче програмі анонімний метод служить для підрахунку від 0 до 5.

Лістинг 15.3 - Застосування анонімного методу

// Оголосити тип делегата.

delegate void CountIt();

class AnonMethDemo

{

static void Main()

{

// Далі слідує код для підрахунку чисел, передаваний делегату

// в якості анонімного методу.

CountIt count = delegate

{

// Цей кодовий блок передається делегату.

for (int i = 0; i <= 5; i++)

Console.WriteLine(i);

}; // зверніть увагу на крапку з комою

count();

}}

Анонімному методу можна передати один або кілька аргументів. Для цього достатньо вказати в дужках список параметрів після ключового слова delegate , а при зверненні до екземпляру делегата — передати йому відповідні аргументи. В якості прикладу нижче наведено варіант попередньої програми, змінений з метою передати в якості аргумента кінцеве значення для підрахунку.

Лістинг 15.04 - Застосування анонімного методу, що приймає аргумент.

delegate void CountIt(int end);

class AnonMethDemo2

{

static void Main()

{

// Тут кінцеве значення для підрахунку передається анонімному методу.

CountIt count = delegate (int end)

{

for (int i = 0; i <= end; i++)

Console.WriteLine(i);

};

count(3);

Console.WriteLine();

count(5);

}

}

У цій версії програми делегат CountIt приймає цілочисельний аргумент. Зверніть увагу на те, що при створенні анонімного методу список параметрів вказується після ключового слова delegate. Параметр end становиться доступним для коду в анонімному методі так само, як і при створенні іменованого методу. Нижче наведено результат виконання даної програми.

Анонімний метод може повертати значення. Для цього служить оператор return , що діє в анонімному методі так само, як і в іменованому методі. Як і очікувалося, тип поверненого значення повинен бути сумісним з типом, вказуваним в оголошенні делегата. В якості при кладу нижче наведено код, що виконує підрахунок з сумуванням і повертає результат.

Лістинг 15.05 - Використання анонімного методу, що повертає значення

delegate int CountIt(int end);

class AnonMethDemo3

{

static void Main()

{

int result;

// Тут кінцеве значення для підрахунку передається анонімному методу.

// А повертається сума підрахованих чисел.

CountIt count = delegate (int end)

{

int sum = 0;

for (int i = 0; i <= end; i++)

{

Console.WriteLine(i);

sum += i;

}

return sum; // повернути значення з анонімного методу

};

result = count(3);

Console.WriteLine("Сума 3 дорівнює " + result);

Console.WriteLine();

result = count(5);

Console.WriteLine("Сума 5 дорівнює " + result);

}

}

У цьому варіанті коду сумарне значення повертається кодовим блоком, пов'язаним з екземпляром делегата count . Зверніть увагу на те, що оператор return застосовується в анонімному методі так само, як і в іменованому методі. Нижче наведено результат виконання даного коду.

Локальна змінна, в область дії якої входить анонімний метод, називається зовнішньою змінною. Такі змінні доступні для використання в ано німному методі.. І в цьому випадку зовнішня змінна вважається захопленою. Захоплена змінна існує до тих пір, поки захоплюючий її делегат не буде зібраний в " сміття " . Тому якщо локальна змінна, яка зазвичай припиняє своє існування після виходу з кодового блоку, використовується в анонімному методі, то вона продовжує існувати до тих пір, поки не буде знищений делегат, що посилається на цей метод. Захоплення локальної змінної може призвести до неочікуваних результатів. Як приклад розглянемо ще один варіант програми підрахунку з сумуванням чисел. У цьому варіанті об'єкт CountIt конструюється і повертається статичним методом Counter() . Цей об'єкт використовує змінну sum , оголошену в охоплюючій області дії методу Counter() , а не самого анонімного методу. Тому змінна sum захоплюється анонімним методом. Метод Counter() викликається в методі Main() для отримання об'єкта CountIt , а отже, змінна sum не знищується до самого кінця програми.

Лістинг 15.06 - Використання захопленої змінної

delegate int CountIt(int end);

class VarCapture

{

static CountIt Counter()

{

int sum = 0;

// Тут підрахована сума зберігається в змінній sum.

CountIt ctObj = delegate (int end)

{

for (int i = 0; i <= end; i++)

{

Console.WriteLine(i);

sum += i;

}

return sum;

};

return ctObj;

}

static void Main()

{

// Отримати результат підрахунку.

CountIt count = Counter();

int result;

result = count(3);

Console.WriteLine("Сума 3 дорівнює " + result);

Console.WriteLine();

result = count(5);

Console.WriteLine("Сума 5 дорівнює " + result);

}

}

Сума 5 дорівнює 21 Як бачите, підрахунок все ще виконується як зазвичай. Але зверніть увагу на те, що сума 5 тепер дорівнює 21, а не 15! Справа в тому, що змінна sum захоплюється об'єктом ctObj при його створенні в методі Counter() . Це означає, що вона продовжує існувати до знищення делегата count при " зборці сміття " в самому кінці програми. Отже, її значення не знищується після повернення з методу Counter() або при кожному виклику анонімного методу, коли звертаються до делегата count в методі Main() . Незважаючи на те, що застосування захоплених змінних може призвести до досить неочікуваних результатів, як у наведеному вище прикладі, воно все ж логічно обґрунтовано. Адже коли анонімний метод захоплює змінну, вона продовжує існувати до тих пір, поки використовується захоплюючий її делегат. В іншому випадку захоплена змінна була б невизначеною, коли вона могла б знадобитися делегату.
