---
layout: default
title: "13.7 Генерація винятків вручну"
---

# 13.7 Генерація винятків вручну

У вищезазначених прикладах перехоплювалися винятки, що генерувалися виконавчою системою автоматично. Але виняток може бути згенерований вручну за допомогою оператора throw. Нижче наведена загальна форма такої гене рації: throw exceptOb; де як exceptOb повинен бути позначений об'єкт класу винятків, похідного від класу Exception . Нижче наведений приклад програми, в якій демонструється застосування оператора throw для генерації винятка DivideByZeroException .

Лістинг 13.10 - Генерація винятків вручну

using System;

class ThrowDemo

{

static void Main()

{

try {

Console.WriteLine("Перед генерацією винятку.");

throw new DivideByZeroException();

}

catch (DivideByZeroException)

{

Console.WriteLine("Виняток перехоплено.");

}

Console.WriteLine("Після пари операторів try/catch.");

}

}

Зверніть увагу на те, що виняток DivideByZeroException був створений за допомогою ключового слова new у операторі throw . Не слід забувати, що в даному випадку генерується конкретний об'єкт, а отже, він повинен бути створений перед генерацією винятку. Це означає, що генерувати виняток тільки за його типом неможливо. У даному прикладі для створення об'єкта DivideByZeroException був автоматично викликаний конструктор, який використовується за замовчуванням, хоча для генерації винятків доступні й інші конструктори.

Виняток, перехоплений в одному блоку catch , може бути повторно згенеровано в іншому блоку, щоб бути перехопленим у зовнішньому блоку catch . Найбільш ймовірною причиною для повторного генерування винятка є надання доступу до винятка декільком обробникам. Припустимо, що один обробник оперує якимось одним аспектом винятка, а інший обробник - іншим його аспектом. Для повторного генерування винятка достатньо вказати оператор throw без супровідного виразу, як у наведеній нижче формі.

Лістинг 13.11 - Згенерувати виняток повторно

class Rethrow

{

public static void GenException()

{

// Тут масив numer довший за масив denom.

int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };

int[] denom = { 2, 0, 4, 4, 0, 8 };

for (int i = 0; i < numer.Length; i++) {

try

{

Console.WriteLine(numer[i] + " / " +

denom[i] + " дорівнює " +

numer[i] / denom[i]);

}

catch (DivideByZeroException)

{

Console.WriteLine("Ділити на нуль не можна!");

}

catch (IndexOutOfRangeException)

{

Console.WriteLine("Підходящий елемент не знайдено.");

throw; // згенерувати виняток повторно

}

}

}

}

class RethrowDemo

{

static void Main()

{

try

{

Rethrow.GenException();

}

catch (IndexOutOfRangeException)

{

// перехопити виняток повторно

Console.WriteLine("Незворотна помилка  програма перервана.");

}

}

}

У цьому прикладі програми помилки через ділення на нуль обробляються локаль но в методі GenException(), але помилка виходу за межі масиву генерується повторно. У даному випадку виняток IndexOutOfRangeException обробляється в методі Main().
