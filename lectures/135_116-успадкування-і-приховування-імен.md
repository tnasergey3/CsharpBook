---
layout: default
title: "11.6 Успадкування і приховування імен"
---

# 11.6 Успадкування і приховування імен

У похідному класі можна визначити член з таким самим ім'ям, як і у члена його базового класу. У цьому випадку член базового класу приховується в похідному класі . І хоча формально в C# це не вважається помилкою, компілятор все ж видасть повідомлення, що ім'я приховується. Якщо член базового класу потрібно приховати навмисно, то перед його ім'ям слід вказати ключове слово new, щоб уникнути появи подібного попередження. Слід, однак, майте на увазі, що це абсолютно окреме застосування ключового слова new, не схоже на його застосування при створенні екземпляра об'єкта.

Лістинг 11.9 - Приклад приховування імені з успадкованою зв'язком.

class А

{

public int i = 0;

}

// Створити похідний клас.

class В : А

{

new int i; // цей член приховує член i з класу А

public В(int b)

{

i = b; // член i в класі В

}

public void Show()

{

Console.WriteLine("Член i в похідному класі: " + i);

}

}

class NameHiding

{

static void Main()

{

В ob = new В(2);

ob.Show();

}

}

Перш за все зверніть увагу на використання ключового слова new у наступному рядку коду.

new int i; // цей член приховує член i з класу А

У цьому рядку компілятору, по суті, повідомляється про те, що новостворена змінна i намірено приховує змінну i з базового класу А і що авто ру програми про це знають. Якщо ж пропустити ключове слово newу цьому рядку коду, то компілятор видаватиме попереджувальне повідомлення. Ось до якого результату призводить виконання наведеного вище коду. Член i в похідному класі: 2 У класі Ввизначається власна змінна екземпляра i, яка приховує змінну iз базового класу А. Тому при виклику методу Show() для об'єк та типу Ввиводиться значення змінної i, визначеної в класі В, а не тієї, що визначена в класі А.
