---
layout: default
title: "3.1 Арифметичні оператори"
---

# 3.1 Арифметичні оператори

Арифметичні оператори, представлені в мові C#, наведені нижче (таблиця 3.1).

Таблиця 3.1 – Арифметичні оператори

Оператор

Дія

+

Додавання

-

Віднімання, унарний мінус

*

Множення

/

Ділення

%

Ділення за модулем

--

Декремент

++

Інкремент

Оператори +, -, * і / діють так, як передбачає їх позначення. Їх можна застосовувати до будь-якого вбудованого числового типу даних.

Дія арифметичних операторів не потребує особливих пояснень, за винятком наступних особливих випадків. По-перше, не слід забувати, що коли оператор / застосовується до цілого числа, то будь-який залишок від ділення відкидається; наприклад, результат цілочисельного ділення 10/3 буде дорівнювати 3. Залишок від цього ділення можна отримати за допомогою оператора ділення за модулем ( % ), який інакше називається оператором обчислення залишку. Він дає залишок від цілочисельного ділення. Наприклад, 10 % 3 дорівнює 1 . У C# оператор % можна застосовувати як до цілочисельних типів даних, так і до типів з плаваючою точкою. Тому 10.0 % 3.0 також дорівнює 1 . У цьому відношенні C# відрізняється від мов С і C++, де операції ділення за модулем розв'язуються тільки для цілих типів даних. У наведеному нижче прикладі програми демонструється застосування оператора ділення за модулем (лістинг 3.1).

Лістинг 3.1 – Демонстрація використання оператора %

// Продемонструвати застосування оператора %.

using System;

class ModDemo

{

static void Main()

{

int iresult, irem;

double dresult, drem;

iresult = 10 / 3;

irem = 10 % 3;

dresult = 10.0 / 3.0;

drem = 10.0 % 3.0;

Console.WriteLine("Результат і залишок від ділення 10 / 3: " +

iresult + " " + irem);

Console.WriteLine("Результат і залишок від ділення 10.0 / 3.0: " +

dresult + " " + drem);

}

}

Результат виконання цієї програми наведено нижче.

Результат і залишок від ділення 10 / 3: 3 1

Результат і залишок від ділення 10.0 / 3.0: 3. 33333333333333 1

Як бачите, обидві операції, % цілочисельного типу і з плаваючою точкою, дають один і той самий залишок, рівний 1.

### 3.1.1 Оператори інкремента та декремента

Оператори інкремента ( ++ ) і декремента ( -- ) були представлені вище. Як стане зрозуміло в подальшому, вони мають кілька особливих і досить цікавих властивостей. Але спочатку з'ясуємо основне призначення цих операторів. Оператор інкремента збільшує свій операнд на 1, а оператор декремента зменшує операнд на 1. Отже, оператор

х++;

еквівалентний оператору х = x + 1;

а оператор х--;

еквівалентний оператору

х = х - 1;

Слід, однак, мати на увазі, що в інкрементній або декрементній формі значення змінної х обчислюється тільки один раз, а не два. У деяких випадках це дозволяє підвищити ефективність виконання програми.

Обидва оператори інкремента і декремента можна вказувати перед операндом (у префіксній формі) або після операнда (у постфіксній формі). Наприклад, оператор

х = х + 1;

може бути записано у наступному вигляді:

++х; // префіксна форма

або ж у такому вигляді:

х++; // постфіксна форма

У наведеному вище прикладі форма інкремента (префіксна або постфіксна) не має особливого значення. Але якщо оператор інкремента або декремента використовується у довгому виразі, то відмінність у формі його запису вже має значення. Коли оператор інкремента або декремента попереджує свій операнд, то результатом операції стає значення операнда після інкремента або декремента. А коли оператор інкремента або декремента слідує після свого операнда, то результатом операції стає значення операнда до інкремента або декремента. Розглянемо наступний фрагмент коду (лістинг 3.2).

Лістинг 3.2 – Використання інкремента у префіксній формі

х = 10;

у = ++х;

У даному випадку значення змінної у буде встановлено рівним 11, оскільки значення змінної х спочатку збільшується на 1, а потім присвоюється змінній у. Але в уривку коду значення змінної у буде встановлено рівним 10, оскільки в цьому випадку значення змінної х спочатку присвоюється змінній у, а потім збільшується на 1 (лістинг 3.3).

Лістинг 3.3 – Використання інкремента у постфіксній формі

х = 10;

у = х++;

У обох випадках значення змінної х виявляється рівним 11. Відмінність полягає лише в тому, коли саме це значення стане рівним 11: до або після його присвоєння змінній у.

Можливість керувати моментом інкремента або декремента надає багато переваг при програмуванні. Звернемося до наступного прикладу програми, в якій формується послідовний ряд чисел (лістинг 3.4).

Лістинг 3.4 – Формування послідовного ряду чисел

//  Продемонструвати відмінність між префіксною

//  і постфіксною формами оператора інкремента (++).

using System;

class PrePostDemo

{

static void Main()

{

int x, y;

int i;

x = 1;

y = 0;

Console.WriteLine("Ряд чисел, отриманих" + " за допомогою оператора y = y + x++;");

for (i = 0; i < 10; i++)

{

y = y + x++; //  постфіксна форма оператора ++

Console.WriteLine(y + " ");

}

Console.WriteLine();

x = 1;

y = 0;

Console.WriteLine("Ряд чисел, отриманих" + "за допомогою оператора y = y + ++x;");

for (i = 0; i < 10; i++)

{

y = y + ++x; //  префіксна форма оператора ++

Console.WriteLine(y + " ");

}

Console.WriteLine();

}

}

Виконання цієї програми дає наступний результат.

Ряд чисел, отриманих за допомогою оператора у = у + х++;

1

3

6

10

15

14

21

28

36

45

55

Ряд чисел, отриманих за допомогою оператора у = у + ++х;

2

5

9

14

20

27

35

44

54

65

Як підтверджує вищезазначений результат, в операторі

у = у + х++;

початкове значення змінної х додається до самої себе, а отриманий результат присвоюється змінній у. Після цього значення змінної х збільшується на 1. Але в операторі

у = у + ++х;

значення змінної х спочатку збільшується на 1, потім додається до початкового значення цієї ж змінної, а отриманий результат присвоюється змінній у. Як випливає з вищезазначеного результату, проста заміна префіксної форми запису оператора ++х постфіксною формою х++ призводить до суттєвого змінення послідовного ряду отримуваних чисел.

І ще одне зауваження щодо наведеного вище прикладу: не лякайтеся виразів, подібних наступному:

у + ++x

Таке розташування поруч двох операторів може здатися не зовсім звичним, але компілятор сприйматиме їх у правильній послідовності. Потрібно лише запам'ятати, що у даному виразі значення змінної у складається з збільшеного на 1 значення змінної х .
