---
layout: default
title: "15.5 Події"
---

# 15.5 Події

Ще одним важливим засобом C#, що базується на делегатах, є подія. Подія, по суті, представляє собою автоматичне повідомлення про те, що сталася певна дія.. Події діють за таким принципом: об'єкт, який проявляє інтерес до події, реєструє обробник цієї події. Коли подія відбувається, всі зареєстровані обробники цієї події викликаються. Обробники подій зазвичай представлені делегатами. Події є членами класу і оголошуються за допомогою ключового слова event. Найчастіше для цієї цілі використовується наступна форма:

event делегат_події ім'я_події;

де делегат_події означає ім'я делегата, що використовується для підтримки події, а ім 'я_події — конкретний об'єкт оголошеної події.

Лістинг 15.8 - Приклад використання подій

// Оголосити тип делегата для події.

delegate void MyEventHandler();

// Оголосити клас, що містить подію.

class MyEvent

{

public event MyEventHandler SomeEvent;

// Цей метод викликається для запуску події.

public void OnSomeEvent()

{

if (SomeEvent != null)

SomeEvent();

}

}

class EventDemo

{

// Обробник події.

static void Handler()

{

Console.WriteLine("Сталася подія");

}

static void Main()

{

MyEvent evt = new MyEvent();

// Додати метод Handler() до списку подій.

evt.SomeEvent += Handler;

// Запустити подію.

evt.OnSomeEvent();

}

}

Як і делегати, події підтримують групову адресацію. Це дає можливість декільком об'єктам реагувати на сповіщення про подію. Нижче наведений приклад групової адресації події.

Лістинг 15.9 - Приклад агрегованих подій

delegate void MyEventHandler();

// Оголосити делегат, що містить подію.

class MyEvent

{

public event MyEventHandler SomeEvent;

// Цей метод викликається для запуску події.

public void OnSomeEvent()

{

if (SomeEvent != null)

SomeEvent();

}

}

class X

{

public void Xhandler()

{

Console.WriteLine("Подію отримано об'єктом класу X");

}

}

class Y

{

public void Yhandler()

{

Console.WriteLine("Подію отримано об'єктом класу Y");

}

}

class EventDemo2

{

static void Handler()

{

Console.WriteLine("Подію отримано об'єктом класу EventDemo");

}

static void Main()

{

MyEvent evt = new MyEvent();

X xOb = new X();

Y yOb = new Y();

// Додати обробники до списку подій.

evt.SomeEvent += Handler;

evt.SomeEvent += xOb.Xhandler;

evt.SomeEvent += yOb.Yhandler;

// Запустити подію.

evt.OnSomeEvent();

Console.WriteLine();

// Видалити обробник.

evt.SomeEvent -= xOb.Xhandler;

evt.OnSomeEvent();

}}

У даному прикладі створюються два додаткових класи, Xі Y, в яких також визначаються обробники подій , сумісні з делегатом MyEventHandler. Тому ці обробники також можуть бути включені в ланцюжок подій. Зверніть увагу на те, що обробники в класах Xі Y не є статичними. Це озна чає, що спочатку повинні бути створені об'єкти кожного з цих класів, а потім в ланцюжок подій повинні бути введені обробники, пов'язані з їх екземплярами. Про відмінності між обробниками екземпляра та статичними обробниками мова піде в наступному розділі.
