---
layout: default
title: "16.6 Препроцесор"
---

# 16.6 Препроцесор

У C# існує ряд директив препроцесора, які впливають на інтерпретацію вихідного коду програми компілятором. Ці директиви визначають порядок під час інтерпретації тексту програми перед її трансляцією в об'єктний код у тому вихідному файлі, де вони з'являються. Термін директива препроцесора з'явився у зв'язку з тим, що подібні інструкції традиційно оброблялися на окремому етапі компіляції, який називався препроцесором. Обробляти директиви на окремому етапі препроцесора в сучасних компіляторах вже не потрібно, але саме її назва закріпилася.

Малюнок 16.1 - директиви препроцесора, визначені в С#

Всі директиви препроцесора починаються зі знака #. Крім того, кожна директи ва препроцесора повинна бути виділена в окремому рядку коду. Беручи до уваги сучасну об'єктно-орієнтовану архітектуру мови C#, потреба в директивах препроцесора в ній не така велика, як в мовах програмування попередніх поколінь. Тим не менш вони можуть бути іноді корисними, особливо для умовної компіляції. У цьому розділі всі директиви препроцесора розглядаються по черзі.

Директива #define визначає послідовність символів, яку називають ідентифікатором. Наявність або відсутність ідентифікатора може бути визначена за допомогою директиви #if або #elif і тому використовується для керування процесом компіляції.. Нижче наведена загальна форма директиви #define . #define ідентифікатор Зверніть увагу на відсутність крапки з комою в кінці цього оператора. Між директивою #defineі ідентифікатором може бути будь-яка кількість пробілів, але після самого ідентифікатора повинен слідувати лише символ нового рядка. Так, для визначення ідентифікатораEXPERIMENTAL використовується наступна директива. #define EXPERIMENTAL. У C/C++ директива #define може використовуватися для підстановки початкового тексту , наприклад, для визначення імені значення, а також для створення макрокоманд, схожих на функції. У C# таке застосування директиви #define не підтримується. У цій мові директива # define служить лише для визначення ідентифікатора.

Обидві директиви, #if і #endif , дозволяють умовну компіляцію послідовності коду залежно від правдивого результату обчислення виразу, що включає один або кілька ідентифікаторів. Ідентифікатор вважається правдивим, якщо він визначений, а інакше — хибним. Так, якщо ідентифікатор визначений директивою #define , то він буде оцінений як правдивий. Нижче наведена загальна форма директиви #if.

#if ідентифікаторне_вираз

послідовність операторів

#endif

Якщо ідентифікаторне_вираз,наступне після директиви #if, є істинним, то компілюється код ( послідовність операторів ), зазначений між ним і директивою #endif. В іншому випадку цей проміжний код пропускається. Директива #endif позначає кінець блоку директиви #if. Ідентифікаторний вираз може бути простим, як назва ідентифікатора. В той же час в ньому дозволяється застосування наступних операторів: ! , == , != , && і || , а також круглих дужок.

Лістинг 16.07 - Приклад застосування директив

#define EXPERIMENTAL
using System;
class Test {
    static void Main() {
#if EXPERIMENTAL
        Console.WriteLine("Компілюється для експериментальної версії.");
#endif
        Console.WriteLine("Присутній у всіх версіях.");
    }
}

У наведеному вище коді визначається ідентифікатор EXPERIMENTAL . Тому коли в цьому коді зустрічається директива #if , ідентифікаційний вираз обчислюється як істинний і потім компілюється перший оператор, що містить виклик методу WriteLine() . Якщо ж видалити визначення ідентифікатора EXPERIMENTAL і перекомпілювати цей код, то перший оператор, що містить виклик методу WriteLine() , не буде скомпільований, оскільки ідентифікаційний вираз директиви #if обчислюється як хибний. Але другий оператор, що містить виклик методу WriteLine() , компілюється в будь-якому випадку, оскільки він не входить до блоку директиви #if . Як пояснювалося вище, в директиві #if допускається вказувати ідентифікаторний вираз. Як приклад розглянемо наступну програму.

Директива #else діє аналогічно умовному оператору else мови C#, визначаючи альтернативний хід виконання програми, якщо цього не може зробити директива # if. З урахуванням директиви #else попередній приклад програми може бути розширений наступним чином.

Позначення #elif означає " інакше якщо " , а сама директива #elif визначає послідовність умовних операцій if-else-if для багатоваріантної компіляції. Після директиви #elif вказується ідентифікаторний вираз. Якщо цей вираз істинний, то компілюється наступний кодовий блок, а інші вирази директиви #elif не перевіряються. В іншому випадку перевіряється наступний за порядком блок. Якщо жодну з директив #elif не вдається виконати, то при наявності директиви #else виконується послідовність коду, пов'язана з цією директивою, а інакше не компілюється жоден з кодових блоків директиви #if . Нижче наведено загальна форма директиви #elif.

#if ідентифікаторне_вираз

послідовність операторів

#elif ідентифікаторне_вираз

послідовність операторів

#elif ідентифікаторне_вираз

послідовність операторів // ...

#endif

За допомогою директиви #undef видаляється попередньо визначений ідентифікатор. Це, по суті, означає, що він стає " невизначеним ". Нижче наведена загальна форма директиви #undef.

#undef ідентифікатор

#define SMALL

#if SMALL // ...

#undef SMALL // тепер ідентифікатор SMALL не визначений

Після директиви #undef ідентифікатор SMALL вже виявляється невизначеним. ленним. Директива #undef застосовується головним чином для локалізації ідентифікато рів тільки в тих фрагментах коду, в яких вони дійсно потрібні.

Директива #error змушує компілятор припинити компіляцію. Вона в основному використовується для відлагодження. Нижче наведена загальна форма директиви #error.

#error повідомлення_про_помилку

Коли в коді зустрічається директива #error, виводиться повідомлення про помилку. Наприклад, коли компілятору зустрічається рядок коду

#error Це тестова помилка!

компіляція припиняється і виводиться повідомлення"Це тестова помилка!".

Директива #warning діє аналогічно директиві #error, за винятком того, що вона виводить попередження, а не помилку. Отже, компіляція не переривається. Нижче наведена загальна форма директиви #warning.

#warning попереджувальне_повідомлення

Директива #line встановлює номер рядка і ім'я файлу, що містить цю директиву. Номер рядка і ім'я файлу використовуються при виведенні помилок або попереджень під час компіляції. Нижче наведена загальна форма директиви #line.

#line номер "ім'я_файлу"

Є ще два варіанти директиви #line. У першому з них вона вказується з ключовим словом default, що позначає повернення нумерації рядків до початкового стану, як у наведеному нижче прикладі.

#line default

А в другому варіанті директива #line вказується з ключовим словом hidden. При кроковому налагодженні програми рядки коду, що знаходяться між директивою

#line hidden

і наступною директивою #line без ключового слова hidden, пропускаються відлагоджувачем.

За допомогою директив #region та #endregion визначається область, яка розгортається або згортається при структуруванні вихідного коду в інтегрованому середовищі розробки Visual Studio. Нижче наведена загальна форма цих директив:

#region текст

// послідовність коду

#endregion текст

де текст позначає необов'язковий символьний рядок.

За допомогою директиви #pragmaінструкції задаються компілятору у вигляді опцій. Нижче наведена загальна форма цієї директиви:

#pragma опція

Де опція позначає інструкцію, передану компілятору. У поточній версії C# передбачено дві опції для директиви #pragma. Перше з них, warning, служить для розрішення або заборони окремих попереджень від боку компілятора. Вона має дві форми:

#pragma warning disable попередження

#pragma warning restore попередження

де попередження позначає роздільний комами список номерів попереджень. Для скасування попередження використовується опція disable, а для його роз блокування — опція restore.
