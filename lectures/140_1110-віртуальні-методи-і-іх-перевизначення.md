---
layout: default
title: "11.10 Віртуальні методи і їх перевизначення"
---

# 11.10 Віртуальні методи і їх перевизначення

Віртуальнимназивається такий метод, який оголошується як virtual у базовому класі. Віртуальний метод відрізняється тим, що його можна перевизначити в одному або кількох похідних класах. Отже, у кожного похідного класу може бути свій варіант віртуального методу. Крім того, віртуальні методи цікаві тим, що саме відбувається при їх виклику за посиланням на базовий клас. У цьому випадку засобами мови C# визначається саме той варіант віртуального методу, який слід викликати, виходячи з типу об'єкта, до якого здійснюється звернення за посиланням, причому це робиться під час виконання.

Тому при посиланні на різні типи об'єктів виконуються різні варіанти віртуального методу. Іншими словами, варіант виконуваного віртуального методу вибирається за типом об'єкта, а не за типом посилання на цей об'єкт. Так, якщо базовий клас містить віртуальний метод і від нього отримані похідні класи, то при зверненні до різних типів об'єктів за посиланням на базовий клас виконуються різні варіанти цього віртуального методу. Метод оголошується як віртуальний у базовому класі за допомогою ключового слова virtual , яке вказується перед його ім'ям. Коли віртуальний метод перевизначається в похідному класі, для цього використовується модифікатор override .

А сам процес повторного визначення віртуального методу в похідному класі називається перевизначенням методу. При перевизначенні ім'я, повернений тип і сигнатура перевизначаючого методу повинні бути точно такими ж, як і у того віртуального методу, який перевизначається.. Крім того, віртуальний метод не може бути оголошений як static або abstract (докладніше це питання розглядається далі в цьому розділі). Перевизначення методу є основою для втілення одного з найефективніших принципів в C#: динамічної диспетчеризації методів, яка представляє собою механізм вирішення виклику під час виконання, а не компіляції. Значення динамічної диспетчеризації методів полягає в тому, що саме завдяки їй в C# реалізується динамічний поліморфізм.

Лістинг 11.16 - Демонстрація віртуальних методів

class Base

{

// Створити віртуальний метод у базовому класі.

public virtual void Who()

{

Console.WriteLine("Метод Who() у класі Base");

}

}

class Derivedl : Base

{

// Перевизначити метод Who() у похідному класі.

public override void Who()

{

Console.WriteLine("Метод Who() у класі Derivedl");

}

}

class Derived2 : Base

{

// Знову перевизначити метод Who() у ще одному похідному класі.

public override void Who()

{

Console.WriteLine("Метод Who() у класі Derived2");

}

}

У коді з наведеного вище прикладу створюються базовий клас Base і два похідні від нього класи — Derived1 і Derived2 . У класі Base оголошується віртуаль ний метод Who() , який перевизначається в обох похідних класах. Потім у методі Main() оголошуються об'єкти типу Base , Derived1 і Derived2 . Крім того, оголошується змінна baseRef посилального типу Base . Далі посилання на кожен тип об'єкта присвоюється змінній baseRef і потім використовується для виклику мето да Who() . Як видно з результату виконання наведеного вище коду, варіант виконуваного методу Who() визначається за типом об'єкта, до якого звертається посилання під час виклику цього методу, а не за типом класу змінної. BaseRef.

Але перевизначати віртуальний метод зовсім не обов'язково. Адже якщо в похідному класі не надається власний варіант віртуального методу, то використовується його варіант з базового класу, як у наведеному нижче прикладі.

Лістинг 11.17 - Приклад з неперевизначенням вірутального методу

using System;

class Base

{

// Створити віртуальний метод у базовому класі.

public virtual void Who()

{

Console.WriteLine("Метод Who() у класі Base");

}

}

class Derived1 : Base

{

// Перевизначити метод Who() у похідному класі.

public override void Who()

{

Console.WriteLine("Метод Who() в класі Derived1");

}

}

class Derived2 : Base

{

// У цьому класі метод Who() не перевизначається.

}

class NoOverrideDemo

{

static void Main()

{

Base baseOb = new Base();

Derived1 dOb1 = new Derived1();

Derived2 dOb2 = new Derived2();

Base baseRef; // посилання на базовий клас

baseRef = baseOb;

baseRef.Who();

baseRef = dOb1;

baseRef.Who();

baseRef = dOb2;

baseRef.Who(); // викликається метод Who() з класу Base

}

}

Завдяки перевизначенню методів в C# підтримується динамічний поліморфізм. У об'єктно-орієнтованому програмуванні поліморфізм відіграє дуже важливу роль, оскільки він дозволяє визначити в загальному класі методи, які стають загальними для всіх похідних від нього класів, а в похідних класах - визначити конкретну реалізацію деяких або всіх цих методів. Перевизначення методів - це ще один спосіб втілити в C# головний принцип поліморфізму: один інтерфейс - багато методів. Успішне застосування поліморфізму в певній мірі залежить від правильного розуміння тієї особливості, що базові і похідні класи утворюють ієрархію, яка просувається від меншої до більшої спеціалізації. При належному застосуванні базовий клас надає всі необхідні елементи, які можуть використовуватися у похідному класі безпосередньо. А за допомогою віртуальних методів у базовому класу визначаються ті методи, які можуть бути самостійно реалізовані в похідному класі. Отже, поєднуючи успадкування з віртуальними методами, можна визначити в базовому класі загальну форму методів, які будуть використовуватися в усіх його похідних класах.
