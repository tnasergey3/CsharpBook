# Введення в класи об'єкти і методи

[◀️ До змісту лекцій](README.md)

---

Класи використовувалися в прикладах програм з самого початку цієї книги. Звичайно, це були лише найпростіші класи, що не дозволяло вигідно скористатися більшістю їх можливостей. Насправді класи набагато ефективніші, ніж це випливає з наведе них раніше прикладів їх обмеженого застосування. Почнемо розгляд класів з основних положень. Клас представляє собою шаблон, за яким визначається форма об'єкта. У ньому вказуються дані та код, які будуть оперувати цими даними. У C# використовується специфікація класу для побудови об'єктів , які є екземплярами класу. Отже, клас, по суті, представляє собою ряд схематичних описі в способу побудови об'єкта. При цьому дуже важливо підкреслити, що клас є логічною абстракцією. Фізичне представлення класу з'явиться в оперативній пам'яті лише після того, як буде створений об'єкт цього класу.

7.1 Загальна форма визначення класу

При визначенні класу оголошуються дані, які він містить, а також код, що оперує цими даними. Якщо найпростіші класи можуть містити тільки код або тільки дані, то більшість справжніх класів містить і те, і інше.

Загалом кажучи, дані містяться в членах даних, визначених класом, а код в функціях-членах. Слід одразу підкреслити, що в C# передбачено кілька видів членів даних і функцій-членів. Наприклад, до членів даних, також називається полями, відносяться змінні екземпляра і статичні змінні, а до функцій-членів — методи, конструктори , деструктори, індексатори, події, оператори і властивості. Обмежимося поки що розглядом найбільш основних компо нентів класу: змінних екземпляра і методів. А далі в цьому розділі будуть представлені конструктори і деструктори. Про інші види членів класу буде мова у наступних розділах.

Клас створюється за допомогою ключового слова class. Нижче наведено загальна форма визначення простого класу, що містить лише змінні екземпляра та методи.

Лістинг 7.1 - Загальна формула простого класу

```csharp
class ім'я_класу {
```

// Оголошення змінних екземпляра.

доступ тип змінна1;

доступ тип змінна2;

доступ тип зміннаN;

// Оголошення методів.

```csharp
доступ повертаємий_тип метод1(параметри) {
```

// тіло методу

```csharp
доступ повертаємий_тип метод2(параметри) {
```

// тіло методу

```csharp
доступ повертаємий_тип методи(параметри) {
```

// тіло методу

7.2 Визначення класу

Для того, щоб продемонструвати класи на конкретних прикладах, розробимо поступово клас, що інкапсулює інформацію про будівлі, включаючи будинки, складські приміщення, установи тощо. У цьому класі (назвемо його Building ) будуть зберігатися три елементи інформації про будівлі: кількість поверхів загальна площа і кількість мешканців.

Нижче наведено перший варіант класу Building. В ньому визначені три змінні екземпляра: Floors, Areaі Occupants. Як бачите, в класі Building взагалі

відсутні методи. Це означає, що на даний момент цей клас складається тільки

з даних.

Лістинг 7.2 - Приклад класу з полями

```csharp
class Building {
```

public int Floors; // кількість поверхів

public int Area; // загальна площа будівлі

public int Occupants; // кількість мешканців

Змінні екземпляра, визначені в класі Building , демонструють загальний порядок оголошення змінних екземпляра. Нижче наведена загальна форма для оголошення змінних екземпляра:

доступ тип ім'я_змінної;

де доступ означає вид доступу; тип — конкретний тип змінної, а ім'я_змінної — ім'я, призначене змінній. Отже, за винятком специфікатора доступу, змінна екземпляра оголошується так само, як і локальна змінна. Всі змінні оголошені в класі Building з попереднім модифікатором доступу public . Як пояснювалося вище, завдяки цьому вони стають доступними поза межами класу Building .

```csharp
Визначення class означає створення нового типу даних. У даному випадку новий тип даних називається Building . За допомогою цього імені можуть бути оголошені об'єкти типу Building. Не слід, однак, забувати, що оголошення class лише описує тип, але не створює конкретний об'єкт. Отже, в наведеному вище
```

фрагменті коду об'єкти типу Buildingне створюються. Щоб створити конкретний об'єкт типу Building , доведеться скористатися наступним оператором.

Лістинг 7.3 - Приклад створення екземпляру класу Building

Building house = new Building(); // створити об'єкт типу Building

Після виконання цього оператора об'єкт house стане екземпляром класу

Building, тобто набуде "фізичної" реальності. Не звертайте поки що уваги на

окремі складові даного оператора.

Кожного разу, коли створюється екземпляр класу, також створюється об'єкт, який містить власну копію кожної змінної екземпляра, визначеної в цьому класі. Таким чином, кожен об'єкт типу Building буде містити свої копії змінних екземпляра Floors , Area і Occupants . Для доступу до цих змінних використовується оператор доступу до члена класу, який зазвичай називають оператором- точкою. Оператор-точка пов'язує ім'я об'єкта з ім'ям члена класу. Нижче наведена загальна форма

оператора-точки.

об'єкт.член

У цій формі об'єкт вказується зліва, а член — справа. Наприклад, присвоєння значення 2 змінній Floors об'єкта house здійснюється за допомогою наступного оператора.

Лістинг 7.4 - Приклад присвоєння значення 2 змінній Floors

house.Floors = 2;

В цілому, оператор-крапка служить для доступу до змінних екземпляра і методів. Нижче наведено повний приклад програми, в якій використовується клас Building.

Лістинг 7.5 - Програма, в якій використовується клас Building

```csharp
using System;
class Building
```

public int Floors; // кількість поверхів

public int Area; // загальна площа будівлі

public int Occupants; // кількість мешканців

// У цьому класі оголошується об'єкт типу Building.

```csharp
class BuildingDemo
static void Main()
```

Building house = new Building(); // створити об'єкт типу Building

int areaPP; // площа на одну особу

// Присвоїти значення полям в об'єкті house.

house.Occupants = 4;

house.Area = 2500;

house.Floors = 2;

// Обчислити площу на одну особу.

areaPP = house.Area / house.Occupants;

```csharp
Console.WriteLine("Дім має: " +
```

house.Floors + " поверхів " +

house.Occupants + " мешканця " +

house.Area +

" кв. футів загальної площі, з них " + агеаРР + "припадає на одну особу");

Ця програма складається з двох класів: Building і BuildingDemo . У класі

BuildingDemo спочатку створюється екземпляр house класу Building за допо-

могою ме тода Main() , а потім в коді метода Main() здійснюється доступ до змінних ек земпляра house для присвоєння їм значень і подальшого використання цих значень. Слід особливо підкреслити, що Building і BuildingDemo — це два окремі класи. Єдине зв'язок між ними полягає в тому, що в одному з них створюється екземпляр іншого. Але, незважаючи на те, що це окремі класи, у коді з класу BuildingDemo є доступ до членів класу Building, оскільки вони оголошені як відкриті ( public ).

Якби при їх оголошенні не було вказаний специфікатор доступу public , то доступ до них обмежувався б областю Building , а отже, їх не можна було б використовувати в класі BuildingDemo .

Припустимо, що вихідний текст вищезазначеної програми зберігається в файлі UseBuilding.cs. Після компіляції створюється файл UseBuilding.exe.

При цьому обидва класи, BuildingіBuildingDemo, автоматично включаються до складу виконуваного файлу. При виконанні даної програми виводиться наступний результат.

Лістинг 7.6 - Результат виконання програми

Будинок має:

2 поверхи

4 мешканці

2500 кв. футів загальної площі, з них

625 припадає на одну людину

Але класам Building і BuildingDemo зовсім не обов'язково знаходитися в одному і тому ж вихідному файлі. Кожен з них можна помістити в окремий файл, наприклад Building.cs і BuildingDemo.cs , а компілятору C# достатньо повідомити, що обидва файли повинні бути скомпільовані разом. Так, якщо розділити розгляну ту тут програму на два таких файли, для її компіляції можна скористатися наступним командним рядком. csc Building.cs BuildingDemo.cs

Якщо ви користуєтесь інтегрованою середою розробки Visual Studio, то вам потрібно ввести обидва згадані вище файли у свій проект і потім скомпілювати їх.

Перед тим, як рухатися далі, розглянемо наступний основний принцип: у кожного об'єкта є свої копії змінних екземпляра, визначених у його класі. Отже, вміст змінних у одному об'єкті може відрізнятися від їх вмісту в іншому об'єкті. Між обома об'єктами не існує жодного зв'язку, за винятком того факту, що вони є об'єктами одного й того ж типу. Так, якщо є два об'єкти типу Building , то у кожного з них своя копія змінних Floors , Area і Occupants , і їх вміст у обох об'єктах може відрізнятися. Цей факт демонструється у наступній програмі.

7.2 Створення об`єктів

У попередніх прикладах програм для оголошення об'єкта типу Building використовувалася наступна рядок коду.

Building house = new Building();

Цей рядок оголошення виконує три функції. По-перше, оголошується змінна house , що належить до класу Building . Сама ця змінна не є об'єктом, а лише змінною, яка може посилатися на об'єкт. По-друге, створюється конкретна, фізична копія об'єкта. Це робиться за допомогою оператора new . І нарешті, змінній house присвоюється посилання на цей об'єкт. Отже, після виконання аналізованого рядка оголошена змінна house посилається на об'єкт типу Building .

Оператор new динамічно (тобто під час виконання) розподіляє пам'ять для об'єкта і повертає посилання на нього, яке потім зберігається в змінній. Отже, в C# для об'єктів усіх класів повинна бути динамічно розподілена пам'ять.

Як і очікувалося, оголошення змінної house можна відокремити від створення

об'єкта, на який вона посилається, наступним чином.

Building house; // оголосити посилання на об'єкт

house = new Building(); // розподілити пам'ять для об'єкта типу Building

У першому рядку оголошується змінна house у вигляді посилання на об'єкт типу Building . Отже, house — це змінна, яка може посилатися на об'єкт, хоча сама вона не є об'єктом. А в другому рядку створюється новий об'єкт типу Building і посилання на нього присвоюється змінній house . В результаті змінна house виявляється пов'язаною з цим об'єктом.

Те обставина, що об'єкти класів доступні за посиланням, пояснює, чому класи називаються посилальними типами. Основна відмінність між значними типами та посилальними типами полягає в тому, що саме містить змінна кожного з цих типів. Так, змінна значного типу містить конкретне значення. Наприклад, у фрагменті коду

int х;

х = 10;

Змінна х містить значення 10, оскільки вона належить до типу int, який

є значним типом. Але у рядку

Building house = new Building();

змінна house містить не сам об'єкт, а лише посилання на нього.

7.3 Змінні посилального типу та присвоєння

У операції присвоєння змінні посилального типу діють інакше, ніж змінні значення, наприклад типу int . Коли одна змінна значення присвоюється іншій, ситуація виявляється досить простою. Змінна, що знаходиться у лівій частині оператора присвоєння, отримує копію значення змінної, що знаходиться у правій частині цього оператора. Коли ж одна змінна посилання на об'єкт присвоюється іншій, то ситуація трохи ускладнюється, оскільки таке присвоєння призводить до того, що змінна, що знаходиться у лівій частині оператора присвоєння, посилається на той самий об'єкт, на який посилається змінна, що знаходиться у правій частині цього оператора. Сам об'єкт не копіюється. У зв'язку з цією відмінністю присвоєння змінних посилального

типу може призвести до кількох неочікуваних результатів. Як приклад розглянемо наступний фрагмент коду.

Лістинг 7.7 - Приклад зміни посилань

Building house1 = new Building();

Building house2 = house1;

house1.Area = 2600;

```csharp
Console.WriteLine(house1.Area);
Console.WriteLine(house2.Area);
```

Building house1 = new Building();

Building house2 = house1;

Building house3 = new Building();

house2 = house3; // тепер обидві змінні, house2 і house3,

// посилаються на один і той самий об'єкт.

На перший погляд, змінні house1 і house2 вказують на абсолютно різні об'єкти але насправді це не так. Змінні house1 і house2 , навпаки, вказують на один і той самий об'єкт. Коли змінна house1 присвоюється змінній house2 , то в кінцевому рахунку змінна house2 просто вказує на той самий об'єкт, що й змінна house1.Отже, цим об'єктом можна оперувати за допомогою змінної house1 або house2 .

Незважаючи на те, що обидві змінні, house1і house2, посилаються на один і той самий об'єкт, вони ніяк інакше не пов'язані одна з одною. Наприклад, в результаті наступної послідовності операцій присвоєння просто змінюється об'єкт, на який посилається змінна house2.

Після виконання цієї послідовності операцій присвоєння змінна house2 посилається на той самий об'єкт, що і змінна house3 . А посилання на об'єкт у змінній house1 не змінюється.

7.4 Методи

Як пояснювалося вище, змінні екземпляра і методи є двома основними складовими класів. До цього часу клас Building , розглянутий тут як приклад, містив лише дані, але не методи. Хоча класи, що містять лише дані, є допустимими, більшість класів також повинні мати методи. Методи представляють собою підпрограми, які маніпулюють даними, визначеними ми в класі, а в багатьох випадках вони надають доступ до цих даних. Зазвичай, інші частини програми взаємодіють з класом за допомогою його методів.

Метод складається з одного або кількох операторів. У грамотно написаному коді C# кожен метод виконує лише одну функцію. У кожного методу є своє ім'я, за якимйого викликають. Загалом, методу можна присвоїти як ім'я будь-який дійсний ідентифікатор. Слід, однак, мати на увазі, що ідентифікатор Main() зарезервованийдля методу, з якого починається виконання програми. Крім того, як імена методівне можна використовувати ключові слова С#.

Методи називаються відповідно до умовних позначень, прийнятих в літературі по С#. Зокрема, після імені методу йдуть круглі дужки.

Так, якщо методу присвоєно ім'я GetVal , то в тексті він згадується у наступному вигляді: GetVal() . Така форма запису допомагає відрізнити імена методів від імен змінних. Нижче наведено загальна форма визначення методу:

```csharp
доступ повертаємий_тип ім'я(список_параметрів) {
```

// тіло методу

де доступ — це модифікатор доступу, що визначає ті частини програми, з яких

може бути викликаний метод. Як пояснювалося вище, вказувати модифікатор доступу необов'язково. Але якщо його немає, то метод виявляється закритим ( private ) в межах того класу, в якому він оголошується. Ми поки що оголошуватимемо методи відкритими ( public ), щоб викликати їх з будь-якої іншої частини коду в програмі. Потім повертаємий_тип означає тип даних, що повертаються методом. Цей тип повинен бути дійсним, включаючи тип створюваного класу.

Якщо метод не повертає значення, то як повертаєме для нього слід вказати тип void . Далі ім'я означає конкретне ім'я, що присвоюється методу. В якості імені методу може служити будь-який допустимий ідентифікатор, що не призводить до конфліктів в поточній області оголошень. І нарешті, список_параметрів — це послідовність пар, з існуючих з типу і ідентифікатора і розділених комами. Параметри представляють собою змінні, що отримують значення аргументів, переданих методу при його виклику. Якщо у метода відсутні параметри, то список параметрів виявляється порожнім.

Як пояснювалося вище, методи класу, як правило, маніпулюють даними класу інадають до них доступ. З урахуванням цього нагадаємо, що в наведених вище прикладах у методі Main() обчислювалась площа на одну людину шляхом ділення загальної площі будівлі на кількість мешканців. І хоча такий спосіб формально вважається правильним, насправді він виявляється далеко не найкращим для організації подібного обчислення. Площа на одну людину найкраще обчислювати в самому класі Building , просто тому, що так легше зрозуміти сам характер обчислен ня. Адже площа на одну людину залежить від значень у полях Area і Occupants , інкапсульованих в класі Building . Отже, дане обчислення може бути повністю здійснене в самому класі Building . Крім того, вводячи обчислення площі на одну людину в клас Building , ми тим самим звільняємо всі програм ми, що користуються класом Building , від необхідності виконувати це обчислення самостійно. Завдяки цьому уникнуто непотрібного дублювання коду. І нарешті, додавання в клас Building методу, що обчислює площу на одну людину, сприяє поліпшенню його об'єктно-орієнтованої структури, оскільки вели чини, безпосередньо пов'язані з будівлею, інкапсулюються в класі Building. Щоб додати метод до класу Building , достатньо вказати його в області оголошень у даному класі. Як приклад нижче наведено перероблену версію класу Building, що містить метод AreaPerPerson() який виводить площу, розраховану на одну людину в конкретній будівлі.

Лістинг 7.8 - Приклад додавання метода до класу Building

```csharp
using System; class Building { public int Floors; // кількість поверхів public int Area; // загальна площа будівлі public int Occupants; // кількість мешканців // Вивести площу на одну людину, public void AreaPerPerson() { Console.WriteLine(" " + Area / Occupants + " припадає на одну людину"); } } // Використовувати метод AreaPerPerson(). class BuildingDemo { static void Main() { Building house = new Building(); Building office = new Building(); // Присвоїти значення полям в об'єкті house. house.Occupants = 4; house.Area = 2500; house.Floors = 2; // Присвоїти значення полям в об'єкті office. office.Occupants = 25; office.Area = 4200; office.Floors = 3; Console.WriteLine("Дім має: " + house.Floors + " поверхів " + house.Occupants + " мешканця " + house.Area + "кrвe.a ф+утів загальної площі, з них"); house.AreaPerPerson(); Console.WriteLine(); Console.WriteLine("Установа має: " + office.Floors + " поверхів " + office.Occupants + " працівників " + office.Area + " кв. футів загальної площі, з них"); office.AreaPerPerson(); } }
```

7.5 Повернення з методу

В цілому, повернення з методу може статися за двох умов. По-перше, коли зустрічається фігурна дужка, що закриває тіло методу, як показує приклад методу AreaPerPerson() з наведеної вище програми. І по-друге, коли виконується оператор return . Існують дві форми оператора return : одна — для методів типу void , тобто тих методів, які не повертають значень, а інша — для методів, що повертають конкретні значення. Перша форма розглядається в цьому розділі, а в наступному розділі буде пояснено, яким чином значення повертаються з методів. Для негайного завершення методу типу void достатньо скористатися наступною формою оператора return.

Коли виконується цей оператор, управління повертається викликаючій частині програми, а залишений у методі код пропускається. Як приклад розглянемо наступний метод.

Лістинг 7.9 - приклад методу с оператором return

```csharp
public void MyMeth() { int i; for(i=0; i<10; i++) { if(i == 5) return; // перервати на кроці 5 Console.WriteLine(); } }
```

У даному прикладі виконується лише 5 повноцінних кроків циклу for, оскільки при значенні 5 змінної i відбувається повернення з методу.

У методі допускається наявність кількох операторів return, особливо якщо є два або більше варіантів повернення з нього. Наприклад:

Лістинг 7.10 - Приклад методу з декількома операторами return

```csharp
public void MyMeth() { //... if(done) return; // ... if(error) return; }
```

У цьому прикладі повернення з методу відбувається у двох випадках: якщо метод завершує свою роботу або виникає помилка. Але користуватися таким прийомом програмування слід дуже обережно. Адже через занадто велику кількість точок повернення з методу може порушитися структура коду.

Отже, нагадаємо ще раз: повернення з методу типу void може статися при двох умовах: при досягненні закриваючої фігурної дужки або при виконанні оператора return.

Методи з поверненням типу void часто застосовуються в програмуванні, проте більшість методів повертає конкретне значення. Насправді, здатність повертати значення є однією з найкорисніших властивостей методу.

Повернення значення вже було продемонстровано в розділі 3 на прикладі методу Math.Sqrt() , який використовувався для отримання квадратного кореня.

Повернуті значення використовуються в програмуванні з різними цілями. У деяких випадках, як у прикладі методу Math.Sqrt() , повернене значення містить результат обчислення, в інших - воно може просто вказувати на успішне або невдале завершення методу, а в третіх - містити код стану. Але незалежно від переслідуваної мети використання повернених значень є невід'ємною частиною програмування на С#.

Для повернення значення з методу до викликаючої частини програми використовується наступна форма оператора return:

return значення ;

дезначення— це конкретне повернене значення.

Використовуючи повернене значення, можна покращити розглянутий раніше метод AreaPerPerson() . Замість того, щоб виводити величину площі на одну людину, краще повернути її з цього методу. Серед інших переваг такого підходу слід особливо відзначити можливість використовувати повернене значення для виконання інших обчислень. Наведений нижче приклад представляє покращений варіант розглянутої раніше програми з покращеним методом AreaPerPerson() , що повертає величину площі на одну людину замість того, щоб виводити її.

Лістинг 7.11 Приклад повернення значення з методу AreaPerPerson()

```csharp
using System; class Building { public int Floors; // кількість поверхів public int Area; // загальна площа будівлі public int Occupants; // кількість мешканців // Повернути величину площі на одну особу, public int AreaPerPerson() { return Area / Occupants; } } // Використовувати значення, що повертається методом AreaPerPerson!). class BuildingDemo { static void Main() { Building house = new Building(); Building office = new Building(); int areaPP; // площа на одну людину // Присвоїти значення полям в об'єкті house. house.Occupants = 4; house.Area = 2500; house.Floors = 2; // Присвоїти значення полям в об'єкті office. office.Occupants = 25; office.Area = 4200; office.Floors = 3; // Отримати площу на одну особу в житловому будинку. areaPP = house.AreaPerPerson(); Console.WriteLine(areaPP); } }
```

7.6 Використання параметрів

При виклику методу йому можна передати одне або кілька значень. Значення, передане методу, називається аргументом. А змінна, що отримує аргумент, називається формальним параметром, або просто параметром. Параметри оголошуються у дужках після імені методу. Синтаксис оголошення параметрів такий самий, як у змінних. А областю дії параметрів є тіло методу. За винятком особливих випадків передачі аргументів методу, параметри діють так само, як і будь-які інші змінні.

Нижче наведений приклад програми, в якому демонструється застосування параметра. У класі ChkNum використовується метод IsPrime() , який повертає значення true, якщо йому передається значення, що є простим числом. У против ному випадку він повертає значення false. Отже, поверненням для метода IsPrime() є тип bool .

Лістинг 7.12 - Простий приклад застосування параметра

```csharp
using System; class ChkNum { // Повернути значення true, якщо значення // параметра х виявиться простим числом. public bool IsPrime(int x) { if (x <= 1) return false;. for (int i = 2; i <= x / i; i++) if ((x % i) == 0) return false; return true; } } class ParmDemo { static void Main() { ChkNum ob = new ChkNum(); for (int i = 2; i < 10; i++) if (ob.IsPrime(i)) Console.WriteLine(i + " просте число."); else Console.WriteLine(i + " непросте число."); } }
```

У цій програмі метод IsPrime()викликається вісім разів, і кожного разу йому передається інше значення. Проаналізуємо цей процес більш детально. Перед зверніть увагу на те, як викликається метод IsPrime() . Його аргумент вказується в дужках. Коли метод IsPrime() викликається вперше, йому передається значення 2. Отже, коли метод IsPrime() починає виконуватися, його параметр х приймає значення 2. При другому виклику цього методу його параметр х приймає значення 3, при третьому виклику — значення 4 і т.д. Таким чином, значення, переда ване методу IsPrime() як аргумент при його виклику, представляє собою значення, яке приймає його параметр х.

Метод може мати не тільки один, але й кілька параметрів. Кожен його параметр оголошується, відокремлюючись від іншого комою. Нижче наведено клас ChkNum , який розширений додатковим методом LeastComFactor() , що повертає найменший спільний множник двох його аргументів, як приклад. Іншими слова ми, цей метод повертає найменше число, на яке обидва його аргументи діляться націло.

Лістинг 7.13 - Приклад методу що приймає два агрументи

```csharp
using System; class ChkNum { // Повернути значення true, якщо значення // параметра х виявиться простим числом. public bool IsPrime(int x) { if(x <= 1) return false; for(int i=2; i <= x/i; i++) if((x %i) == 0) return false; return true; } // Повернути найменший спільний множник. public int LeastComFactor(int a, int b) { int max; if(IsPrime(a) || IsPrime(b)) return 1; max = a < b ? a : b; for(int i=2; i <= max/2; i++) if(((a%i) == 0) && ((b%i) == 0)) return i; return 1; } } class ParmDemo { static void Main() { ChkNum ob = new ChkNum(); int a, b; for(int i=2; i < 10; i++) if(ob.IsPrime(i)) Console.WriteLine(i + " просте число."); else Console.WriteLine(i + " непросте число."); a = 7; b = 8; Console.WriteLine("Найменший спільний множник чисел а " + a + " і " + b + " дорівнює " + ob.LeastComFactor(a, b)); a = 100; b = 75; Console.WriteLine("Найменший спільний множник чисел а " + a + " і " + b + " дорівнює " + ob.LeastComFactor(a, b)); } }
```

7.7 Конструктор

У наведених вище прикладах програм змінні екземпляра кожного об'єкта типу Building доводилося ініціалізувати вручну, використовуючи, зокрема, наступну послідовність операторів.

house.Occupants = 4;

house.Area = 2500;

house.Floors = 2;

Такий прийом зазвичай не застосовується в професійно написаному коді C#. Крім того, він може призвести до помилок (ви можете просто забути ініціалізувати одне з полів). Однак, існує кращий спосіб вирішити подібну задачу: скористатися конструктором.

Конструктор ініціалізує об'єкт при його створенні. У конструктора таке же

ім'я, як і у його класу, а з точки зору синтаксису він схожий на метод. Але у конструкторів немає повертаємого типу, явно вказаного. Нижче наведена загальна форма конструктора.

```csharp
доступ ім'я_класу(список_параметрів) {
```

// тіло конструктора

Зазвичай конструктор використовується для задання початкових значень змінних екземпляра, визначених у класі, або для виконання будь-яких інших установчих процедур, які потрібні для створення повністю сформованого об'єкта. Крім того, доступ зазвичай представляє собою модифікатор доступу типу public , оскільки конструктори часто викликаються в класі. А список_па- раметрів може бути як порожнім, так і складатися з одного або більше вказуваних параметрів.

У всіх класах є конструктори, незалежно від того, чи ви їх визначили, чи

ні, оскільки в C# автоматично надається конструктор, який використовується за замовчуванням і ініціалізує всі змінні екземпляра їх значеннями за замовчуванням. Для більшості типів даних значенням за замовчуванням є ну

льове, для типу bool— значення false, а для посилальних типів — порожнє значення. Але як тільки ви визначите свій власний конструктор, конструктор за замовчуванням більше не використовується.

Лістинг 7.14 - Простий конструктор

```csharp
using System; class MyClass { public int x; public MyClass() { x = 10; } } class ConsDemo { static void Main() { MyClass t1 = new MyClass(); MyClass t2 = new MyClass(); Console.WriteLine(t1.x + " " + t2.x); } }
```

Зверніть увагу на те, що цей конструктор позначається як public. Справа

в тому, що його потрібно викликати з коду, що визначений поза межами його класу.

У цьому конструкторі змінній екземпляра класу MyClass присвоюється значеня 10. Він викликається в операторі new при створенні об'єкта. Наприклад, у наступному рядку:

MyClass t1 = new MyClass();

конструктор MyClass() викликається для об'єкта t1, присвоюючи змінній його екземпляра t1.хзначення 10. Те саме стосується і об'єкта t2. Після конструювання змінна t2.х буде містити те саме значення 10. Отже, виконання наведеного вище коду призведе до наступного результату. 10 10.

У попередньому прикладі використовувався конструктор без параметрів. У деяких випадках цього виявляється достатньо, але часто конструктор повинен приймати один або кілька параметрів. У конструктор параметри вводяться так само, як і в метод. Для цього достатньо оголосити їх у дужках після імені конструктора. Нижче наведено приклад застосування параметризованого конструктора MyClass.

Лістинг 7.15 Приклад класу с параметризованим конструктором

```csharp
using System; class MyClass { public int x; public MyClass(int i) { x = i; } } class ParmConsDemo { static void Main() { MyClass t1 = new MyClass(10); MyClass t2 = new MyClass(88); Console.WriteLine(t1.x + " " + t2.x); } }
```

При виконанні цього коду отримується наступний результат.

10 88

У даному варіанті конструктора MyClass()визначений параметр i, за допомогою якого ініціалізується змінна екземпляра х. Тому при виконанні

наступного рядка коду:

MyClass t1 = new MyClass(10);

параметру i передається значення, яке потім присвоюється змінній х.

7.8 Деструктор

У мові C# є можливість визначити метод, який буде викликатися не прямо передостаточним знищенням об'єкта системою "збірки сміття". Такий метод називається деструктором і може використовуватися в деяких особливих випадках, щоб гарантувати чітке закінчення терміну дії об'єкта. Наприклад, деструктор може бути використаний для гарантованого звільнення системного ресурсу, задіяного звільняємим об'єктом. Слід, однак, відразу під креслити, що деструктори - дуже специфічні засоби, застосовувані тільки у рідкісних, особливих випадках. І, як правило, вони не потрібні. Але тут вони розглядаються у кількох словах для повноти уявлення про можливості

мови C#. Нижче наведена загальна форма деструктора:

```csharp
~ім'я_класу() {
```

// код деструктора

де ім'я_класу означає ім'я конкретного класу. Отже, деструктор оголошується аналогічно конструктору, за винятком того, що перед його ім'ям вказується знак "тильда" ( ~ ). Зверніть увагу на те, що у деструктора відсутній повертаємий тип і передавані йому аргументи. Для того, щоб додати деструктор до класу, достатньо включити його в клас як члена. Він викликається кожного разу, коли передбачається утилізувати об'єкт його класу. У деструкторі можна вказати ті дії, які слід виконати перед тим, як знищувати об'єкт. Слід, однак, мати на увазі, що деструктор викликається безпосередньо перед "збором сміття ".

Він не викликається, наприклад, в той момент, коли змінна, що містить посилання на об'єкт, опиняється поза областю дії цього об'єк та. (У цьому відношенні деструктори в C# відрізняються від деструкторів в C++, де вони викликаються в той момент, коли об'єкт опиняється поза областю своєї ді ї.) Це означає, що наперед неможливо знати, коли саме слід викликати деструк тор. Крім того, програма може завершитися до того, як відбудеться "збірка сміття", а отже, деструктор може взагалі не бути викликаний. Нижче наведено приклад програми, що демонструє застосування деструктора. У цій програмі створюється і знищується велика кількість об'єктів. В якийсь моментпід час цього процесу активізується "збірка сміття" і викликаються деструктори для знищення непотрібних об'єктів.

Лістинг 7.16 - Приклад класу с деструктором

```csharp
using System; class Destruct { public int x; public Destruct(int i) { x = i; } // Викликається при утилізації об'єкта. ~Destruct() { Console.WriteLine("Знищити " + х); } // Створює об'єкт і одразу ж знищує його. public void Generator(int i) { Destruct о = new Destruct(i); } } class DestructDemo { static void Main() { int count; Destruct ob = new Destruct(0); /* А тепер створити велику кількість об'єктів В якийсь момент відбудеться . "збірка сміття". Примітка: для того, щоб активувати "збірку сміття", можливо, доведеться збільшити кількість створюваних об'єктів. */ for(count=1; count < 100000; count++) ob.Generator(count); Console.WriteLine( "Готово!"); } }
```

Ця програма працює наступним чином. Конструктор ініціалізує змінну х відомим значенням. У даному прикладі змінна х виступає в якості ідентифікатора об'єкта. А деструктор виводить значення змінної х , коли об'єкт утилізується. Особливий інтерес викликає метод Generator() , який створює і одразу ж знищує об'єкт типу Destruct. Спочатку в класі DestructDemo створюється початковий об'єкт ob типу Destruct, а потім здійснюється послідовне створення і знищення 100 тис. об'єктів. В різні моменти цього процесу відбувається "збірка сміття".

Наскільки часто вона відбувається - залежить від кількох факторів, включаючи початковий об'єм вільної пам'яті, тип використовуваної операційної си стеми і т.д. Проте в якийсь момент починають з'являтися повідомлення, формо вані деструктором. Якщо вони не з'являться до закінчення програми, тобто до того моменту, коли буде видано повідомлення "Готово!", спробуйте збільшити кількість створю ваних об'єктів, підвищивши максимальну кількість підраховуваних кроків у циклі for. І ще одне важливе зауваження : метод WriteLine() викликається в деструкторі ~Destruct() виключно для наочності даного прикладу його використання.

Зазвичай, деструктор повинен впливати лише на змінні екземпляра, визначені в його класі. У зв'язку з тим, що порядок виклику деструкторів не визначений точно, їх не слід застосовувати для виконання дій, які повинні відбуватися в певний момент виконання програми. У той же час є можливість запитувати " збірку сміття ", як буде показано в частині II цієї книги при розгляді бібліо теки класів С#. Проте ініціалізація "збірки сміття " вручну у більшості випадків не рекомендується, оскільки це може призвести до зниження ефектив ності програми. Крім того, у системи "збірки сміття " є свої особливості — навіть якщо запитати " збірку сміття " явно, все

одно неможливо заздалегідь знати, коли саме буде утилізований конкретний об'єкт.

7.9 Ключове слово this

Перед тим як завершити цю главу, необхідно представити ключове слово this. Коли метод викликається, йому автоматично передається посилання на викликаючий об'єкт, тобто той об'єкт, для якого викликається даний метод. Це посилання позначається ключовим словом this . Отже, ключове слово this означає саме той об'єкт, за посиланням на який діє викликаний метод. Для того щоб стало зрозуміліше призначення ключового слова this , розглянемо спочатку приклад програми, в якій створюється клас Rect , що інкапсулює ширину і висоту прямокутника і включає в себе метод Area() , що повертає площу прямокутника.

Як вам вже повинно бути відомо, інші члени класу можуть бути доступні не прямо без додаткового уточнення імені об'єкта або класу. Тому оператор.

return Width * Height;

Але той самий оператор можна написати наступним чином.

return this.Width * this.Height;

У цьому операторі ключове слово this позначає об'єкт, для якого викликано

метод Area() . Отже, у виразі this.Width робиться посилання на копію змінної

Width даного об'єкта, а у виразі this.Height — посилання на копію змінної Height

цього ж об'єкта. Так, якщо б метод Area() був викликаний для об'єкта х , то ключове слово this у наведеному операторі позначало б посилання на об'єкт х .

Написання оператора без ключового слова this представляє собою не більше ніж скорочену форму запису. Ключове слово this також можна використовувати в конструкторі. У цьому випадку воно означає об'єкт, який конструюється. Наприклад, наступні оператори в методі

Width = w;

Height = h;

можна було б написати таким чином.

this.Width = w;

this.Height = h;

Звичайно, такий спосіб запису не дає в даному випадку жодних переваг.

Наведено нижче весь клас Rect, написаний з використанням посилан

ня this, на прикладі.

Лістинг 07.17 - Приклад використання this

```csharp
using System; class Rect { public int Width; public int Height; public Rect(int w, int h) { this.Width = w; this.Height = h; } public int Area() { return this.Width * this.Height; } }
```

7.10 Властивості класів

Для спрощення написання структурних класів можна використовувати конструкції властивостей Get Set. Таким чином є можливість створити контроль над присвоєнням та повертанням змінної.

Лістинг 7.18 - Приклад використання властивостей класу

```csharp
class Rect { public int Width { get; set; } public int Height { get; set; }
public Rect(int w, int h) { this.Width = w; this.Height = h; } public int Area() { return this.Width * this.Height; } }
```

Ця конструкція може використовуватися коли нам потрібно або захистити і спростити доступ до полів даних класу. Слід використовувати для всіх полів с даними.

У наступному прикладі наведений зразок використання властивостей із перевіркою на обмеження по ширині та висоті. Якщо властивість порушує обмеження, виводиться відповідне повідомлення.

Лістинг 07.19 - Приклад використання властивостей класу

```csharp
using System;
using System.Text;
class Rect
```

private int _width;

private int _height;

public int Width

```csharp
get { return _width; }
```

set

if (value < 1 || value > 100)

```csharp
Console.WriteLine("Ширина повинна бути в діапазоні від 1 до 100.");
```

else

_width = value;

public int Height

```csharp
get { return _height; }
```

set

if (value < 1 || value > 100)

```csharp
Console.WriteLine("Висота повинна бути в діапазоні від 1 до 100.");
```

else

_height = value;

public Rect(int w, int h)

this.Width = w;

this.Height = h;

public int Area()

return this.Width * this.Height;

```csharp
class Program
static void Main(string[] args)
Console.OutputEncoding = Encoding.Unicode;
```

// Створення об'єкта з правильними параметрами

Rect rect1 = new Rect(50, 30);

```csharp
Console.WriteLine($"Площа прямокутника: {rect1.Area()}");
```

// Спроба встановити некоректні параметри

rect1.Width = 150; // Виведе повідомлення про помилку

rect1.Height = -10; // Виведе повідомлення про помилку

// Перевірка після некоректного вводу

```csharp
Console.WriteLine($"Ширина: {rect1.Width}, Висота: {rect1.Height}");
```

// Коректне оновлення значень

rect1.Width = 80;

rect1.Height = 40;

```csharp
Console.WriteLine($"Оновлена площа прямокутника: {rect1.Area()}");
```

---

[◀️ До змісту](../README.md)
