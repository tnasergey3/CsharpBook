# Оператори

[◀️ До змісту лекцій](README.md)

---

У мові C# передбачений широкий набір операторів, що надають програмісту можливість повного контролю над побудовою та обчисленням виразів. Більшість операторів в С# належать до наступних категорій: арифметичні, порозрядні, логічні та оператори відношення. Усі перераховані категорії операторів розглядаються в цьому розділі. Крім того, в C# передбачений набір інших операторів для особливих випадків, включаючи індексування масивів, доступ до членів класу та обробку лямбда виразів. Ці спеціальні оператори розглядаються далі разом з тими засобами, в яких вони застосовуються.

3.1 Арифметичні оператори

Арифметичні оператори, представлені в мові C#, наведені нижче (таблиця 3.1).

Таблиця 3.1 – Арифметичні оператори

Оператори +, -, * і / діють так, як передбачає їх позначення. Їх можна застосовувати до будь-якого вбудованого числового типу даних.

Дія арифметичних операторів не потребує особливих пояснень, за винятком наступних особливих випадків. По-перше, не слід забувати, що коли оператор / застосовується до цілого числа, то будь-який залишок від ділення відкидається; наприклад, результат цілочисельного ділення 10/3 буде дорівнювати 3. Залишок від цього ділення можна отримати за допомогою оператора ділення за модулем ( % ), який інакше називається оператором обчислення залишку. Він дає залишок від цілочисельного ділення. Наприклад, 10 % 3 дорівнює 1 . У C# оператор % можна застосовувати як до цілочисельних типів даних, так і до типів з плаваючою точкою. Тому 10.0 % 3.0 також дорівнює 1 . У цьому відношенні C# відрізняється від мов С і C++, де операції ділення за модулем розв'язуються тільки для цілих типів даних. У наведеному нижче прикладі програми демонструється застосування оператора ділення за модулем (лістинг 3.1).

Лістинг 3.1 – Демонстрація використання оператора %

// Продемонструвати застосування оператора %.

```csharp
using System;
class ModDemo
static void Main()
```

int iresult, irem;

double dresult, drem;

iresult = 10 / 3;

irem = 10 % 3;

dresult = 10.0 / 3.0;

drem = 10.0 % 3.0;

```csharp
Console.WriteLine("Результат і залишок від ділення 10 / 3: " +
```

iresult + " " + irem);

```csharp
Console.WriteLine("Результат і залишок від ділення 10.0 / 3.0: " +
```

dresult + " " + drem);

Результат виконання цієї програми наведено нижче.

Результат і залишок від ділення 10 / 3: 3 1

Результат і залишок від ділення 10.0 / 3.0: 3. 33333333333333 1

Як бачите, обидві операції, % цілочисельного типу і з плаваючою точкою, дають один і той самий залишок, рівний 1.

3.1.1 Оператори інкремента та декремента

Оператори інкремента ( ++ ) і декремента ( -- ) були представлені вище. Як стане зрозуміло в подальшому, вони мають кілька особливих і досить цікавих властивостей. Але спочатку з'ясуємо основне призначення цих операторів. Оператор інкремента збільшує свій операнд на 1, а оператор декремента зменшує операнд на 1. Отже, оператор

х++;

еквівалентний оператору х = x + 1;

а оператор х--;

еквівалентний оператору

х = х - 1;

Слід, однак, мати на увазі, що в інкрементній або декрементній формі значення змінної х обчислюється тільки один раз, а не два. У деяких випадках це дозволяє підвищити ефективність виконання програми.

Обидва оператори інкремента і декремента можна вказувати перед операндом (у префіксній формі) або після операнда (у постфіксній формі). Наприклад, оператор

х = х + 1;

може бути записано у наступному вигляді:

++х; // префіксна форма

або ж у такому вигляді:

х++; // постфіксна форма

У наведеному вище прикладі форма інкремента (префіксна або постфіксна) не має особливого значення. Але якщо оператор інкремента або декремента використовується у довгому виразі, то відмінність у формі його запису вже має значення. Коли оператор інкремента або декремента попереджує свій операнд, то результатом операції стає значення операнда після інкремента або декремента. А коли оператор інкремента або декремента слідує після свого операнда, то результатом операції стає значення операнда до інкремента або декремента. Розглянемо наступний фрагмент коду (лістинг 3.2).

Лістинг 3.2 – Використання інкремента у префіксній формі

х = 10;

у = ++х;

У даному випадку значення змінної у буде встановлено рівним 11, оскільки значення змінної х спочатку збільшується на 1, а потім присвоюється змінній у. Але в уривку коду значення змінної у буде встановлено рівним 10, оскільки в цьому випадку значення змінної х спочатку присвоюється змінній у, а потім збільшується на 1 (лістинг 3.3).

Лістинг 3.3 – Використання інкремента у постфіксній формі

х = 10;

у = х++;

У обох випадках значення змінної х виявляється рівним 11. Відмінність полягає лише в тому, коли саме це значення стане рівним 11: до або після його присвоєння змінній у.

Можливість керувати моментом інкремента або декремента надає багато переваг при програмуванні. Звернемося до наступного прикладу програми, в якій формується послідовний ряд чисел (лістинг 3.4).

Лістинг 3.4 – Формування послідовного ряду чисел

// Продемонструвати відмінність між префіксною

// і постфіксною формами оператора інкремента (++).

```csharp
using System;
class PrePostDemo
static void Main()
```

int x, y;

int i;

x = 1;

y = 0;

```csharp
Console.WriteLine("Ряд чисел, отриманих" + " за допомогою оператора y = y + x++;");
```

for (i = 0; i < 10; i++)

y = y + x++; // постфіксна форма оператора ++

```csharp
Console.WriteLine(y + " ");
Console.WriteLine();
```

x = 1;

y = 0;

```csharp
Console.WriteLine("Ряд чисел, отриманих" + "за допомогою оператора y = y + ++x;");
```

for (i = 0; i < 10; i++)

y = y + ++x; // префіксна форма оператора ++

```csharp
Console.WriteLine(y + " ");
Console.WriteLine();
```

Виконання цієї програми дає наступний результат.

Ряд чисел, отриманих за допомогою оператора у = у + х++;

Ряд чисел, отриманих за допомогою оператора у = у + ++х;

Як підтверджує вищезазначений результат, в операторі

у = у + х++;

початкове значення змінної х додається до самої себе, а отриманий результат присвоюється змінній у. Після цього значення змінної х збільшується на 1. Але в операторі

у = у + ++х;

значення змінної х спочатку збільшується на 1, потім додається до початкового значення цієї ж змінної, а отриманий результат присвоюється змінній у. Як випливає з вищезазначеного результату, проста заміна префіксної форми запису оператора ++х постфіксною формою х++ призводить до суттєвого змінення послідовного ряду отримуваних чисел.

І ще одне зауваження щодо наведеного вище прикладу: не лякайтеся виразів, подібних наступному:

у + ++x

Таке розташування поруч двох операторів може здатися не зовсім звичним, але компілятор сприйматиме їх у правильній послідовності. Потрібно лише запам'ятати, що у даному виразі значення змінної у складається з збільшеного на 1 значення змінної х .

3.2 Оператори відношення та логічні оператори

У позначеннях оператор відношення і логічний оператор термін відношення означає взаємозв'язок, який може існувати між двома значеннями, а термін логічний — взаємозв'язок між логічними значеннями "істина" і "хиба". І оскільки оператори відношення дають істинні або хибні результати, то вони часто використовуються разом з логічними операторами. Саме з цієї причини вони і розглядаються разом у цьому розділі.

Нижче перераховані оператори відношення (таблиця 3.2).

Таблиця 3.2 – Оператори відношення

Результатом виконання оператора відношення або логічного оператора є логічне значення типу bool.

В цілому, об'єкти можна порівнювати на рівність або нерівність, використовуючи оператори відношення == та !=. А оператори порівняння < , > , <= або >= можуть застосовуватися тільки до тих типів даних, які підтримують відношення порядку. Отже, оператори відношення можна застосовувати до всіх числових типів даних. Але значення типу bool можуть порівнюватися тільки на рівність або нерівність, оскільки істинні ( true ) і хибні ( false ) значення не упорядковуються. Наприклад, порівняння true > false в C# не має сенсу.

Операнди логічних операторів повинні належати до типу bool , а результат виконання логічної операції також належить до типу bool . Логічні оператори & , | , ^ і ! підтримують основні логічні операції І, АБО, виключне АБО і НЕ згідно з наведеною нижче таблицею істинності (таблиця 3.3).

Таблиця 3.3. Таблиця істинності

Як випливає з наведеної вище таблиці, результатом виконання логічної операції виключне АБО буде істинне значення (true), якщо один і тільки один з її операндів має значення true.

Нижче наведений приклад програми, що демонструє застосування декількох операторів відношення та логічних операторів (лістинг 3.5).

Лістинг 3.5 – Застосування операторів відношення та логічних операторів

// Показати застосування операторів відношення та логічних операторів.

```csharp
using System;
class RelLogOps
static void Main()
```

int i, j;

bool b1, b2;

i = 10;

j = 11;

```csharp
if (i < j) Console.WriteLine("i < j");
if (i <= j) Console.WriteLine("i <= j");
if (i != j) Console.WriteLine("i != j");
if (i == j) Console.WriteLine("Неможливо виконати");
if (i >= j) Console.WriteLine("Неможливо виконати");
if (i > j) Console.WriteLine("Неможливо виконати");
```

b1 = true;

b2 = false;

```csharp
if (b1 & b2) Console.WriteLine("Неможливо виконати");
if (!(b1 & b2)) Console.WriteLine("!(b1 & b2) - true");
if (b1 | b2) Console.WriteLine("b1 | b2 - true");
if (b1 ^ b2) Console.WriteLine("b1 ^ b2 - true");
```

Виконання цієї програми дає наступний результат.

i < j

i <= j

i != j

!(b1 & b2) — true

b1 | b2 — true

b1 ^ b2 — true

Логічні оператори в C# виконують найпоширеніші логічні операції. Тим не менш існує ряд операцій, що виконуються за правилами формальної логіки. Ці логічні оператори можуть бути побудовані за допомогою логічних операторів, підтримуваних в С#. Отже, в C# передбачений такий на бір логічних операторів, якого достатньо для побудови практично будь-якої логічної операції, включаючи імплікацію. Імплікація — це двійкова операція, результатом якої є хибне значення тільки у випадку, якщо лівий операнд має істинне значення, а правий — хибне. (Операція імплікації від ображає наступний принцип: істина не може підтверджувати хибне.) Нижче наведена таблиця істинності для операції імплікації (таблиця 3.4).

Таблиця 3.4 – Таблиця істинності для операції імплікації

Операція імплікації може бути побудована на основі комбінації логічних операторів ! і |, як у наведеному нижче коді (лістинг 3.6).

Лістинг 3.6 – Побудова операції імплікації

!р | q

У наступному прикладі програми демонструється подібна реалізація операції імплікації (лістинг 3.7).

Лістинг 3.7 – Демонстрація реалізації операції імплікації

// Побудова операції імплікації в С#.

```csharp
using System;
class Implication
static void Main()
```

bool p = false, q = false;

int i, j;

for (i = 0; i < 2; i++)

for (j = 0; j < 2; j++)

if (i == 0) p = true;

if (i == 1) p = false;

if (j == 0) q = true;

if (j == 1) q = false;

```csharp
Console.WriteLine("p дорівнює " + p + ", q дорівнює " + q);
if (!p | q) Console.WriteLine("Результат імплікації" + p + " і " + q +
```

" дорівнює " + true);

```csharp
Console.WriteLine();
```

Результат виконання цієї програми виглядає так.

p дорівнює True, q дорівнює True

Результат імплікації True і True дорівнює True

p дорівнює True, q дорівнює False

p дорівнює False, q дорівнює False

Результат імплікації False і True дорівнює True

p дорівнює False, q дорівнює False

Результат імплікації False і False дорівнює True

3.2.1 Скорочені логічні оператори

У C# також передбачені спеціальні, скорочені, варіанти логічних операторів І і АБО, призначені для отримання більш ефективного коду. Пояснимо це на наступних прикладах логічних операцій. Якщо перший операнд логічної операції І має хибне значення ( false ), то її результат буде мати хибне значення незалежно від значення другого операнда. Якщо ж перший операнд логічної операції АБО має істинне значення ( true ), то її результат буде мати істинне значення незалежно від значення другого операнда. Завдяки тому, що значення другого операнда в цих операціях обчислювати не потрібно, економиться час і підвищується ефективність коду.

Скорочена логічна операція І виконується за допомогою оператора && , а скорочена логічна операція АБО - за допомогою оператора || . Цим скороченим логічним операторам відповідають звичайні логічні оператори & і | . Єдине відмінність скороченого логічного оператора від звичайного полягає в тому, що другий операнд обчислюється лише за необхідністю.

У наведеному нижче прикладі програми демонструється застосування скороченого логічного оператора І. У цій програмі за допомогою операції ділення за модулем визначається наступне: чи ділиться значення змінної d на значення змінної n націло. Якщо залишок від ділення n/d дорівнює нулю, то n ділиться на d націло. Але оскільки ця операція передбачає ділення, то для перевірки умови ділення на нуль використовується скорочений логічний оператор І (лістинг 3.8).

Лістинг 3.8 – Застосування скорочених логічних операторів

// Показати застосування скорочених логічних операторів.

```csharp
using System;
class SCops
static void Main()
```

int n, d;

n = 10;

d = 2;

if (d != 0 && (n % d) == 0)

```csharp
Console.WriteLine(n + " ділиться націло на " + d);
```

d = 0; // задати нульове значення змінної d

// d дорівнює нулю, тому другий операнд не обчислюється

if (d != 0 && (n % d) == 0)

```csharp
Console.WriteLine(n + " ділиться націло на " + d);
```

// Якщо тепер спробувати зробити те саме без скороченого

// логічного оператора, то виникне помилка через ділення на нуль.

if (d != 0 & (n % d) == 0)

```csharp
Console.WriteLine(n + " ділиться націло на " + d);
```

Для уникнення помилки, пов'язаної з діленням на нуль в операторі if спочатку перевіряється умова: чи дорівнює нулю значення змінної d. Якщо воно дорівнює нулю, то виконання скороченого логічного оператора І завершується, а наступна операція ділення за модулем не виконується. Так, при першій перевірці значення змінної d виявляється рівним 2, тому виконується операція ділення за модулем. А при другій перевірці це значення виявляється рівним нулю, отже, операція ділення за модулем пропускається, щоб уникнути ділення на нуль. І нарешті, виконується звичайний логічний оператор І, коли обчислюються обидва операнди. Якщо при цьому відбувається ділення на нуль, то виникає помилка при виконанні.

Скорочені логічні оператори іноді виявляються більш ефективними, ніж їх звичайні аналоги. Так для чого ж потрібні звичайні логічні оператори І та АБО? Справа в тому, що в деяких випадках потрібно обчислювати обидва операнди логічної операції І або АБО через виникаючі побічні ефекти. Розглянемо наступний приклад програми (лістинг 3.9).

Лістинг 3.9 – Застосування скорочених логічних операторів

// Продемонструвати значення побічних ефектів.

```csharp
using System;
class SideEffects
static void Main()
```

int i;

bool someCondition = false;

i = 0;

// Значення змінної i інкрементується, незважаючи на те,

// що оператор if не виконується.

if (someCondition & (++i < 100))

```csharp
Console.WriteLine("He виводиться");
Console.WriteLine("Оператор if виконується: " + i);
```

// виводиться 1

// У даному випадку значення змінної i не інкрементується,

// оскільки інкремент в скороченому логічному операторі

// опускається.

if (someCondition && (++i < 100))

```csharp
Console.WriteLine("He виводиться");
Console.WriteLine("Оператор if виконується: " + i);
```

// як і раніше 1 !!

По-перше звернімо увагу на те, що змінна someCondition типу bool ініціалізується значенням false . Далі проаналізуємо кожен оператор if . Як випливає з коментарів до цієї програми, в першому операторі if змінна i інкрементується, незважаючи на те, що значення змінної someCondition дорівнює false. Коли застосовується логічний оператор & , як це має місце в першому операторі if, вираз у правій частині цього оператора обчислюється незалежно від значення виразу у його лівій частині. А в другому операторі if застосовується скоро чений логічний оператор. У цьому випадку значення змінної i не інкрементується, оскільки лівий операнд (змінна someCondition) має значення false, отже, вираз у правій частині даного оператора пропускається. З цього випливає висновок: якщо в коді передбачається обчислення правого операнда логічної операції І або АБО, то необхідно користуватися нескороченими формами логічних операцій, доступних у С#.

І останнє зауваження: скорочений оператор І також називається умовним логічним оператором І, а скорочений оператор АБО — умовним логічним оператором АБО.

3.3 Оператор присвоєння

Оператор присвоєння позначається одиночним знаком рівності ( = ). У C# оператор присвоєння діє так само, як і в інших мовах програмування. Нижче наведена його загальна форма.

ім'я_змінної = вираз

Тут ім'я_змінної повинно бути сумісним з типом виразу.

У оператора присвоєння є одна цікава особливість, про яку вам буде корисно знати: він дозволяє створювати ланцюжок операцій присвоєння. Розглянемо, наприклад , наступний фрагмент коду (лістинг 3.10).

Лістинг 3.10 – Приклад оператора присвоєння

int х, у, z;

х = у = z = 100; // присвоїти значення 100 змінним х, у і z

У наведеному вище фрагменті коду одне і те ж значення 100 задається для змінних х , у і z за допомогою єдиного оператора присвоєння. Це значення присвоюється спочатку змінній z , потім змінній у і, нарешті, змінній х.

Такий спосіб присвоєння "по ланцюжку" зручний для задання загального значення цілій групі змінних.

3.3.1 Складні оператори присвоєння

У C# передбачені спеціальні складні оператори присвоєння, спрощують програмування деяких операцій присвоєння. Звернемося спочатку до простого прикладу. Наведений нижче оператор присвоєння

х = х + 10;

можна переписати, використовуючи наступний складний оператор присвоєння.

х += 10;

Пара операторів += вказує компілятору на те, що змінній х має бути присвоєне її початкове значення, збільшене на 10.

Розглянемо ще один приклад. Оператор

х = х - 100;

і оператор

x -= 100;

виконують одні й ті самі дії. Обидва оператори присвоюють змінній х її початкове значення, зменшене на 100.

Для багатьох двійкових операцій, тобто операцій, які потребують наявності двох операндів, існують окремі складні оператори присвоєння. Загальна форма всіх цих операторів має наступний вигляд;

ім'я_змінної ор = вираз

де ор – арифметичний або логічний оператор, застосовуваний разом з оператором присвоєння.

Нижче перераховані складні оператори присвоєння для арифметичних і логічних операцій (таблиця 3.5).

Таблиця 3.5 – Складні оператори присвоєння

Складні оператори присвоєння записуються коротше, ніж їх неско мпактні еквіваленти. Тому їх іноді ще називають скороченими операторами присвоєння.

У складних операторів присвоєння є дві головні переваги. По-перше, вони більш компактні, ніж їх "нескорочені" еквіваленти. І по-друге, вони дають більш ефективний виконавчий код, оскільки лівий операнд цих операторів обчислюється лише один раз. Саме з цих причин складні оператори присвоєння найчастіше застосовуються в програмах, професійно написаних на C#.

3.4 Порозрядні оператори

У C# передбачено ряд порозрядних операторів, які розширюють коло завдань, для рішення яких можна застосовувати C#. Порозрядні оператори впливають на окремі двійкові розряди (біти) своїх операндів. Вони визначені тільки для цілочисельних операндів, тому їх не можна застосовувати до даних типу bool, float або double.

Ці оператори називаються порозрядними, оскільки вони служать для перевірки, встановлення або зсуву двійкових розрядів, що складають ціле значення. Між іншим порозрядні оператори застосовуються для рішення найрізноманітніших завдань програмування на рівні системи, включаючи, наприклад, аналіз інформації стану пристрою. Усі доступні в C# порозрядні оператори наведені в таблиці 3.6.

Таблиця 3.6 – Порозрядні оператори

3.4.1 Порозрядні оператори І, АБО, виключаюче АБО і НЕ

Порозрядні оператори І, АБО, виключне АБО і НЕ позначаються наступним чином: & , | , ^ і ~ . Вони виконують ті ж функції, що і їх логічні аналоги, розглянуті вище. Але на відміну від логічних операторів, порозрядні оператори діють на рівні окремих двійкових розрядів. Нижче наведено результати порозрядних операцій з двійковими одиницями та нулями (таблиця 3.7).

Таблиця 3.7 – Таблиця результатів порозрядних операцій

З точки зору найпоширенішого застосування порозрядну операцію І можна розглядати як спосіб пригнічення окремих двійкових розрядів. Це означає, що якщо який-небудь біт в будь-якому з операндів дорівнює 0, то відповідний біт результату буде скинутий в 0. Наприклад:

1101 0011

1010 1010

& __________

1000 0010

У наведеному нижче прикладі програми демонструється застосування порозрядного оператора & для перетворення непарних чисел в парні (лістинг 3.11). Для цієї мети достатньо скинути молодший розряд числа. Наприклад, число 9 має наступний двійковий вигляд: 0000 1001. Якщо скинути молодший розряд цього числа, то воно стане числом 8, а в двійковій формі — 0000 1000.

Лістинг 3.11 – Застосування порозрядного оператора

// Застосувати побітовий оператор І, щоб зробити число парним.

```csharp
using System;
class MakeEven
static void Main()
```

ushort num;

ushort i;

for (i = 1; i <= 10; i++)

num = i;

```csharp
Console.WriteLine("num: " + num);
```

num = (ushort)(num & 0xFFFE); // num & 1111 1110

```csharp
Console.WriteLine(" num після скидання молодшого розряду: "
```

+ num + "\n");

Результат виконання цієї програми наведено нижче.

num: 1

num після скидання молодшого розряду: 0

num: 2

num після скидання молодшого розряду: 2

num: 3

num після скидання молодшого розряду: 2

num: 4

num після скидання молодшого розряду: 4

num: 5

num після скидання молодшого розряду: 4

num: 6

num після скидання молодшого розряду: 6

num: 7

num після скидання молодшого розряду: 6

num: 8

num після скидання молодшого розряду: 8

num: 9

num після скидання молодшого розряду: 8

num: 10

num після скидання молодшого розряду: 10

Шістнадцяткове значення 0xFFFE , використовуване в побітовому операторі І, має наступну двійкову форму: 1111 1111 1111 1110. Отже, побітова операція І залишає без змін усі двійкові розряди в числовому значенні змінної num, крім молодшого розряду, який скидається в нуль. В результаті парні числа не зазнають жодних змін, а непарні зменшуються на 1 і стають парними.

Побітовим оператором І зручно також користуватися для визначення встановленого або скинутого стану окремого двійкового розряду. У наступному прикладі програми визначається, чи є число непарним (лістинг 3.12).

Лістинг 3.12 – Застосування побітового оператора

// Застосувати побітовий оператор І, щоб визначити, чи є число непарним.

```csharp
using System;
class IsOdd
static void Main()
```

ushort num;

num = 10;

if ((num & 1) == 1)

```csharp
Console.WriteLine("Він виводиться.");
```

num = 11;

if ((num & 1) == 1)

```csharp
Console.WriteLine(num + " — непарне число.");
```

Ось як виглядає результат виконання цієї програми.

11 – непарне число.

У обох операторах if з наведеної вище програми виконується побітова операція І над числовими значеннями змінної num і 1. Якщо молодший двійковий нижній розряд числового значення змінної num встановлений, тобто містить двійкову 1, то результат побітової операції num & 1 показується рівним 1. В іншому випадку він дорівнює нулю. Тому оператор if може бути успішно виконаний лише в тому випадку, якщо перевірене число виявиться непарним.

Можливість перевіряти стан окремих двійкових розрядів за допомогою побітового оператора & можна використовувати для написання програми, в якій окремі двійкові розряди перевіреного значення типу byte представлені у двійковій формі . Нижче показано один із способів написання такої програми (лістинг 3.13).

Лістинг 3.13 – Відображення бітів, що складають байт

// Показати біти, що складають байт.

```csharp
using System;
class ShowBits
static void Main()
```

int t;

byte val;

val = 123;

for (t = 128; t > 0; t = t / 2)

```csharp
if ((val & t) != 0) Console.Write("1 ");
if ((val & t) == 0) Console.Write("0 ");
```

Виконання цієї програми дає наступний результат.

0 1 1 1 1 0 1 1

У циклі for з наведеної вище програми кожен біт значення змінної val перевіряється за допомогою побітового оператора І, щоб визначити, встановлений він чи скинутий. Якщо він встановлений, то виводиться цифра 1, а якщо скинутий, то виводиться цифра 0.

Порозрядний оператор АБО може бути використаний для встановлення окремих двійкових розрядів. Якщо в 1 встановлений який-небудь біт в будь-якому з операндів цього оператора, то в 1 буде встановлений і відповідний біт в іншому операнді. Наприклад:

1101 0011

1010 1010

| __________

1111 1011

Використовуючи порозрядний оператор АБО, можна без особливих зусиль перетворити згаданий вище приклад програми, що перетворює непарні числа в парні, а наведений нижче зворотний приклад, де парні числа перетворюються в непарні (лістинг 3.14).

Лістинг 3.14 – Застосування порозрядного оператора АБО

// Застосувати поразрядний оператор АБО, щоб зробити число непарним.

```csharp
using System;
class MakeOdd
static void Main()
```

ushort num;

ushort i;

for (i = 1; i <= 10; i++)

num = i;

```csharp
Console.WriteLine("num: " + num);
```

num = (ushort)(num | 1); // num | 0000 0001

```csharp
Console.WriteLine("після встановлення молодшого розряду: "
```

+ num + "\n");

Результат виконання цієї програми виглядає наступним чином.

num: 1

num після встановлення молодшого розряду: 1

num: 2

num після встановлення молодшого розряду: 3

num: 3

num після встановлення молодшого розряду: 3

num: 4

num після встановлення молодшого розряду: 5

num: 5

num після встановлення молодшого розряду: 5

num: 6

num після встановлення молодшого розряду: 7

num: 7

num після встановлення молодшого розряду: 7

num: 8

num після встановлення молодшого розряду: 9

num: 9

num після встановлення молодшого розряду: 9

num: 10

num після встановлення молодшого розряду: 11

У вищезазначеній програмі виконується порозрядна операція АБО над кожним числовим значенням змінної num і 1, оскільки 1 дає двійкове значення, в якому встановлений молодший розряд. В результаті порозрядної операції АБО над 1 і будь-яким іншим значенням молодший розряд останнього встановлюється, тоді як всі інші розряди залишаються без змін. Отже, отримане числове значення стає непарним, якщо початкове значення було парним.

Порозрядний оператор виключне АБО встановлює двійковий розряд операнда в тому і тільки в тому випадку, якщо двійкові розряди порівнюваних операндів виявляються різними, як у наведеному нижче прикладі.

0111 1111

1011 1001

^ __________

1100 0110

У порозрядного оператора виключне АБО є одна цікава властивість, яка виявляється корисною в найрізноманітніших ситуаціях. Так, якщо спочатку виконати порозрядну операцію виключне АБО одного значення X з іншим значенням Y, а потім таку ж операцію над результатом попередньої операції і значенням Y, то знову отримається початкове значення X. Це означає, що в наведеному нижче фрагменті коду

R1 = X ^ Y;

R2 = R1 ^ Y;

значення змінної R2 виявляється в кінцевому підсумку таким самим, як і значення змінної X. Отже, в результаті двох послідовно виконуваних порозрядних операцій виключне АБО, в яких використовується одне і те саме значення, виходить початкове значення. Цією властивістю даної операції можна скористатися для написання простої програми шифрування, в якій деяке ціле значення служить як ключ для кодування і декодування повідомлення за допомогою операції виключне АБО над символами цього повідомлення. Вперше операція виключне АБО виконується для кодування відкритого тексту в зашифрований, а другий раз – для декодування зашифрованого тексту в відкритий. Звичай но, таке шифрування не має ніякої практичної цінності, оскільки його можна легко розшифрувати. Тим не менш, воно служить цікавим прикладом для демонстрації результатів застосування порозрядних операторів виключне АБО, як у наведеній нижче програмі (лістинг 3.15).

Лістинг 3.15 – Застосування порозрядного оператора виключне АБО

// Показати застосування поразрядного оператора виключаюче АБО.

```csharp
using System;
class Encode
static void Main()
```

char ch1 = 'H';

char ch2 = 'i';

char ch3 = '!';

int key = 88;

```csharp
Console.WriteLine("Початкове повідомлення: " + ch1 + ch2 + ch3);
```

// Зашифрувати повідомлення.

ch1 = (char)(ch1 ^ key);

ch2 = (char)(ch2 ^ key);

ch3 = (char)(ch3 ^ key);

```csharp
Console.WriteLine("Зашифроване повідомлення: " + ch1 + ch2 + ch3);
```

// Розшифрувати повідомлення.

ch1 = (char)(ch1 ^ key);

ch2 = (char)(ch2 ^ key);

ch3 = (char)(ch3 ^ key);

```csharp
Console.WriteLine("Розшифроване повідомлення: " + ch1 + ch2 + ch3);
```

Нижче наведено результат виконання цієї програми.

Початкове повідомлення: Hi!

Зашифроване повідомлення: □1y

Розшифроване повідомлення: Hi!

Як бачите, в результаті виконання двох послідовностей порозрядних операцій виключне АБО отримується розшифроване повідомлення. (Знову нагадуємо, що таке шифрування не має жодної практичної цінності, оскільки воно, по суті, ненадійне .)

Порозрядний унарний оператор НЕ (або оператор доповнення до 1) змінює на зворотний стан всіх двійкових розрядів операнда. Так, якщо деяке ціле значення А має комбінацію двійкових розрядів 1001 0110, то в результаті порозрядної операції ~А отримується значення з комбінацією двійкових розрядів 0110 1001.

У наступному прикладі програми демонструється застосування порозрядного оператора НЕ з виведенням деякого числа і його доповнення до 1 в двійковому коді (лістинг 3.16).

Лістинг 3.16 – Застосування порозрядного оператора унарного оператора Не

// Показати застосування поразрядного унарного оператора НЕ.

```csharp
using System;
class NotDemo
static void Main()
```

sbyte b = -34;

for (int t = 128; t > 0; t = t / 2)

```csharp
if ((b & t) != 0) Console.Write("1 ");
if ((b & t) == 0) Console.Write("0 ");
Console.WriteLine();
```

// змінити всі біти

b = (sbyte)~b;

for (int t = 128; t > 0; t = t / 2)

```csharp
if ((b & t) != 0) Console.Write("1 ");
if ((b & t) == 0) Console.Write("0 ");
```

Результат виконання цієї програми наведено нижче.

1 1 0 1 1 1 1 0

0 0 1 0 0 0 0 1

3.4.2 Оператори зсуву

У C# є можливість зсувати двійкові розряди, що складають ціле значення, вліво або вправо на задану величину. Для цієї цілі в C# визначені два перераховані нижче оператори зсуву двійкових розрядів (таблиця 3.8).

Таблиця 3.8 – Оператори зсуву

Нижче наведена загальна форма для цих операторів:

значення << число_бітів

значення >> число_бітів

де число_бітів — це число двійкових розрядів, на яке зсувається вказане значення.

При зсуві вліво всі двійкові розряди в указаному значенні зсуваються на одну позицію вліво, а молодший розряд скидається в нуль. При зсуві вправо всі двійкові розряди в указаному значенні зсуваються на одну позицію вправо. Якщо вправо зсувається ціле значення без знаку, то старший розряд скидається в нуль. А якщо вправо зсувається ціле значення зі знаком, то розряд знаку зберігається. Не забуваємо, що для представлення від'ємних чисел старший розряд цілого числа встановлюється в 1. Так, якщо зсуване значення є від'ємним, то при при кожному зсуві вправо старший розряд числа встановлюється в 1. А якщо зсуване значення є позитивним, то при кожному зсуві вправо старший розряд числа скидається в нуль.

При зсуві вліво і вправо крайні двійкові розряди втрачаються. Відновити по втрачені при зсуві двійкові розряди неможливо, оскільки зсув в даному випадку не є циклічним.

Нижче наведено приклад програми, наочно демонструючий дію зсуву вліво і вправо. У даному прикладі спочатку задається початкове ціле значення, рівне 1. Це означає, що молодший розряд цього значення встановлений. Потім це ціле значення зсувається вісім разів поспіль вліво. Після кожного зсуву виводяться всім молодші двійкові розряди даного значення. Далі процес повторюється, але на цей раз 1 встановлюється на позиції восьмого розряду, і по суті, задається ціле значення 128, яке потім зсувається вісім разів поспіль вправо (лістинг 3.17).

Лістинг 3.17 – Застосування операторів зсуву

// Показати застосування операторів зсуву.

```csharp
using System;
class ShiftDemo
static void Main()
```

int val = 1;

for (int i = 0; i < 8; i++)

for (int t = 128; t > 0; t = t / 2)

```csharp
if ((val & t) != 0) Console.Write("1 ");
if ((val & t) == 0) Console.Write("0 ");
Console.WriteLine();
```

val = val << 1; // зсув вліво

```csharp
Console.WriteLine();
```

val = 128;

for (int i = 0; i < 8; i++)

for (int t = 128; t > 0; t = t / 2)

```csharp
if ((val & t) != 0) Console.Write("1 ");
if ((val & t) == 0) Console.Write("0 ");
Console.WriteLine();
```

val = val >> 1; // зсув вправо

Результат виконання цієї програми виглядає наступним чином.

0 0 0 0 0 0 0 1

0 0 0 0 0 0 1 0

0 0 0 0 0 1 0 0

0 0 0 0 1 0 0 0

0 0 0 1 0 0 0 0

0 0 1 0 0 0 0 0

0 1 0 0 0 0 0 0

1 0 0 0 0 0 0 0

1 0 0 0 0 0 0 0

0 1 0 0 0 0 0 0

0 0 1 0 0 0 0 0

0 0 0 1 0 0 0 0

0 0 0 0 1 0 0 0

0 0 0 0 0 1 0 0

0 0 0 0 0 0 1 0

0 0 0 0 0 0 0 1

Двійкові розряди відповідають формі представлення чисел у степені 2, і тому оператори зсуву можуть бути використані для множення або ділення цілих значень на 2. Так, при зсуві вправо ціле значення подвоюється, а при зсуві вліво — зменшується наполовину. Звичайно, все це справедливо лише у випадку, якщо крайні розряди не втрачаються при зсуві в ту або іншу сторону. Нижче наведений відповідний приклад (лістинг 3.18).

Лістинг 3.18 – Застосування операторів зсуву для множення і ділення на 2

// Застосувати оператори зсуву для множення і ділення на 2.

```csharp
using System;
class MultDiv
static void Main()
```

int n;

n = 10;

```csharp
Console.WriteLine("Значення змінної n: " + n);
```

// Помножити на 2.

n = n << 1;

```csharp
Console.WriteLine("Значення змінної n після n = n * 2: " + n);
```

// Помножити на 4.

n = n << 2;

```csharp
Console.WriteLine("Значення змінної n після n = n * 4: " + n);
```

// Розділити на 2.

n = n >> 1;

```csharp
Console.WriteLine("Значення змінної n після n = n / 2: " + n);
```

// Розділити на 4.

n = n >> 2;

```csharp
Console.WriteLine("Значення змінної n після n = n / 4: " + n);
Console.WriteLine();
```

// Встановити змінну n в початковий стан.

n = 10;

```csharp
Console.WriteLine("Значення змінної n: " + n);
```

// Помножити на 2 тридцять разів

n = n << 30; // дані втрачаються

```csharp
Console.WriteLine("Значення змінної n після зсуву на 30 позицій вліво: " + n);
```

Нижче наведено результат виконання цієї програми.

Значення змінної n: 10

Значення змінної n після n = n * 2: 20

Значення змінної n після n = n * 4: 80

Значення змінної n після n = n / 2: 40

Значення змінної n після n = n / 4: 10

Значення змінної n: 10

Значення змінної n після зсуву на 30 позицій вліво: -2147483648

Зверніть увагу на останній рядок наведеного вище результату. Коли ціле значення 10 зсувається вліво тридцять разів поспіль, інформація втрачається, оскільки двійкові розряди зсуваються за межі представлення чисел для типу int. У даному випадку отримується абсолютно "непридатне" значення, яке виявляється також від'ємним, оскільки в результаті зсуву в старшому розряді, використовуваному як знаковий, виявляється 1, а отже, дане числове значення має бути інтерпретоване як від'ємне. Цей приклад наочно показує, що застосовувати оператори зсуву для множення або ділення на 2 слід дуже обережно. (Докладніше про типи даних зі знаком і без знака див. у розділі 3.)

3.4.3 Порозрядні складні оператори присвоєння

Всі двійкові порозрядні оператори можуть бути використані в складних операціях присвоєння. Наприклад, в двох наведених нижче операторах змінній х присвоюється результат виконання операції виключне АБО над початковим значенням змінної х і числовим значенням 127.

х = х ^ 127;

х ^= 127;

3.5 Оператор ?

Оператор ? належить до числа найвідоміших в C#. Він представляє собою умовний оператор і часто використовується замість певних видів конструкцій

if-then-else. Оператор ? іноді ще називають тернарним, оскільки для нього потрібні три операнди. Нижче наведена загальна форма цього оператора.

Вираз! ? Вираз2 : Вираз3;

Тут Вираз1 повинен належати до типу bool, а Вираз2 і Вираз3 — до одного й того ж типу. Зверніть увагу на застосування двокрапки і його місце у операторі ?.

Значення виразу ? визначається наступним чином. Спочатку обчислюється Вираз1. Якщо він істинний, то обчислюється Вираз2, а отриманий результат визначає значення всього виразу ? в цілому. Якщо ж Вираз1 виявляється хибним, то обчислюється Вираз3, і його значення стає загальним для всього виразу ?. Розглянемо наступний приклад, в якому змінній absval присвоюється значення змінної val.

absval = val < 0 ? -val : val; // отримати абсолютне значення змінної val

У даному прикладі змінній absval присвоюється значення змінної val, якщо воно більше або дорівнює нулю. Якщо ж значення змінної val від'ємне, то змінній absval присвоюється результат заперечення цього значення, що в результаті дає додатнє значення.

Нижче наведено ще один приклад застосування оператора ?. У цій програмі одне число ділиться на інше, але при цьому виключається ділення на нуль (лістинг 3.19).

Лістинг 3.19 – Застосування оператора ?

// Виключити ділення на нуль, використовуючи оператор?.

```csharp
using System;
class NoZeroDiv
static void Main()
```

int result;

for (int i = -5; i < 6; i++)

result = i != 0 ? 100 / i : 0;

if (i != 0)

```csharp
Console.WriteLine("100 / " + i + " дорівнює " + result);
```

Виконання цієї програми дає наступний результат.

100 / -5 дорівнює -20

100 / -4 дорівнює -25

100 / -3 дорівнює -33

100 / -2 дорівнює -50

100 / -1 дорівнює -100

100 / 1 дорівнює 100

100 / 2 дорівнює 50

100 / 3 дорівнює 33

100 / 4 дорівнює 25

100 / 5 дорівнює 20

Зверніть особливу увагу на наступний рядок з наведеної вище програми. result = i != 0 ? 100 / i : 0;

У цьому рядку змінній result присвоюється результат ділення числа 100 на значення змінної i . Але це ділення відбувається тільки у випадку, якщо значення змінної i не дорівнює нулю. Коли воно дорівнює нулю, змінній result присвоюється значення, яке обнуляє результат.

Присвоювати змінній результат виконання оператора ? зовсім не обов'язково. Наприклад, значення, яке дає оператор ?, можна використовувати як аргумент при виклику методу. А якщо всі вирази в операторі ? належать до типу bool , то такий оператор може замінити умовний вираз у циклі або операторі if. У наведеному нижче прикладі програми виводяться результати ділення числа 100 лише на парні, ненульові значення (лістинг 3.20).

Лістинг 3.20 – Ділення лише на парні, ненульові значення

// Розділити лише на парні, ненульові значення.

```csharp
using System;
class NoZeroDiv2
static void Main()
```

for (int i = -5; i < 6; i++)

if (i != 0 ? (i % 2 == 0) : false)

```csharp
Console.WriteLine("100 / " + i + " дорівнює " + 100 / i);
```

Зверніть увагу на оператор if у наведеній вище програмі. Якщо значення змінної i дорівнює нулю, то оператор if дає хибний результат. А якщо значення змінної i не дорівнює нулю, то оператор if дає істинний результат, коли значення змінної i виявляється парним, і хибний результат, якщо воно непарне. Завдяки цьому дозволяється ділення лише на парні і ненульові значення. Незважаючи на те що цей приклад служить лише для цілей демонстрації, подібні конструкції іноді виявляються дуже корисними.

3.6 Використання пробілів і круглих дужок

У виразі на C# допускається наявність символів табуляції і пробілів, завдяки яким він стає зручнішим для читання. Наприклад, обидва наведені нижче вирази, по суті, однакові, але другий читається легше.

х=10/у*(127+х);

х = 10 / у * (127 + х);

Дужки можуть служити для групування підвиразів, по суті, підвищуючи порядок передчасності поміщених в них операцій, як в алгебрі. Застосування зайвих або додаткових дужок не призводить до помилок і не уповільнює обчислення виразу. Тому дужки рекомендується використовувати, щоб зробити більш зрозумілим і зрозумілим порядок обчислення як для самого автора програми, так і для тих, хто буде розбиратися в ній в подальшому. Наприклад, яке з двох наведених нижче виразів легше читається?

х = у/3-34*temp+127;

х = (у/3) - (34*temp) + 127;

3.7 Послідовність операторів

Таблиця пріоритетів операторів у мові програмування C# визначає порядок, у якому оператори обчислюються у виразах. Ось основні правила пріоритету:

1. Постфіксні оператори: (), [], . (виклик методу, доступ до елемента масиву, доступ до члена об'єкта).

2. Унарні оператори: +, -, !, ~, ++, --, (T) (унарний плюс і мінус, логічне НЕ, побітове НЕ, інкремент, декремент, приведення типу).

3. Мультиплікативні оператори: *, /, % (множення, ділення, залишок від ділення).

4. Адитивні оператори: +, - (додавання, віднімання).

5. Оператори зсуву: <<, >> (зсув вліво, зсув вправо).

6. Реляційні та типові оператори: <, >, <=, >=, is, as (порівняння, перевірка типу, приведення типу).

7. Оператори рівності: ==, != (рівність, нерівність).

8. Побітові оператори І: & (побітове І).

9. Побітові оператори виключного АБО: ^ (побітове виключне АБО).

10. Побітові оператори АБО: | (побітове АБО).

11. Умовні логічні оператори: &&, || (логічне І, логічне АБО).

12. Умовний оператор: ?: (тернарний умовний оператор).

13. Присвоєння та оператори присвоєння: =, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>= (присвоєння та складене присвоєння).

14. Оператор кома: , (розділювач у виразах).

Ці правила визначають порядок, у якому оператори будуть оцінюватися у будь-якому виразі. Якщо необхідно змінити порядок обчислень, можна використовувати круглі дужки для групування виразів.


---

[◀️ До змісту](../README.md)
