# Наслідування

[◀️ До змісту лекцій](README.md)

---

Наслідування є одним з трьох осново полагаючих принципів об'єктно-орієнтованого програмування, оскільки воно дозволяє створення ієрархічних класифікацій. Завдяки наслідуванню можна створити загальний клас, в якому визначаються характерні особливості, притаманні багатьом пов'язаним елементам. Від цього класу можуть потім успадковуватися інші, більш конкретні класи, додаючи до нього свої індивідуальні особливості. У мові C# клас, який успадковується, називається базовим , а клас, який успадковує, - похідним. Отже, похідний клас є спеціалізованою версією базового класу. Він успадковує всі змінні, методи, властивості та індексатори, визначені в базовому класі, додавши до них свої власні елементи.

11.1 Основи успадкування

Підтримка успадкування в C# полягає в тому, що при оголошенні одного класу можна вводити інший клас. Для цього при оголошенні похідного класу вказується базовий клас. Розглянемо спочатку простий приклад. Нижче наведений клас TwoDShape, що містить ширину і висоту двовимірного об'єкта, наприклад квадрата, прямо кутника, трикутника тощо.

Лістинг 11.01 - Клас для двовимірних об'єктів.

```csharp
class TwoDShape
```

public double Width;

public double Height;

public void ShowDim()

```csharp
Console.WriteLine("Ширина і висота дорівнюють " +
```

Width + " і " + Height);

Клас TwoDShape може стати базовим, тобто вихідною точкою для створення класів, що описують конкретні типи двовимірних об'єктів. Наприклад, у наведеній нижче програмі клас TwoDShapeвикористовується для породження похідного класу Triangle. Зверніть особливу увагу на оголошення класу Triangle.

Лістинг 11.2 - Приклад простої ієрархії класів.

// Клас для двовимірних об'єктів.

```csharp
class TwoDShape
```

public double Width;

public double Height;

public void ShowDim()

```csharp
Console.WriteLine("Ширина і висота дорівнюють " +
```

Width + " і " + Height);

// Клас Triangle, похідний від класу TwoDShape.

```csharp
class Triangle : TwoDShape
```

public string Style; // тип трикутника

// Повернути площу трикутника.

public double Area()

return Width * Height / 2;

// Показати тип трикутника.

public void ShowStyle()

```csharp
Console.WriteLine("Трикутник " + Style);
class Shapes
static void Main()
```

Triangle t1 = new Triangle();

Triangle t2 = new Triangle();

t1.Width = 4.0;

t1.Height = 4.0;

t1.Style = "рівнобедрений";

t2.Width = 8.0;

t2.Height = 12.0;

t2.Style = "прямокутний";

```csharp
Console.WriteLine("Інформація про об'єкт t1: ");
```

t1.ShowStyle();

t1.ShowDim();

```csharp
Console.WriteLine("Площа дорівнює " + t1.Area());
Console.WriteLine();
Console.WriteLine("Інформація про об'єкт t2: ");
```

t2.ShowStyle();

t2.ShowDim();

```csharp
Console.WriteLine("Площа дорівнює " + t2.Area());
```

У класі Triangle створюється особливий тип об'єкта класу TwoDShape (у цьому випадку - трикутник). Крім того, до класу Triangle входять всі члени класу TwoDShape, до яких, зокрема, додаються методи Area() і ShowStyle(). Таким чином, опис типу трикутника зберігається в змінній Style, метод Area() розраховує і повертає площу трикутника, а метод ShowStyle() відображає тип трикутника. Зверніть увагу на синтаксис, що використовується в класі Triangle для успадкування класу TwoDShape .

```csharp
class Triangle : TwoDShape {
```

Цей синтаксис може бути узагальнений. Кожного разу, коли один клас успадковує від іншого, після імені базового класу вказується ім'я похідного класу, розділене двокрапкою. У C# синтаксис успадкування класу дивовижно простий і зручний у використанні. У класі Triangle включаються всі члени його базового класу TwoDShape , тому у ньому змінні Width і Height доступні для методу Area() . Крім того, об'єкти t1 і t 2 у методі Main() можуть безпосередньо звертатися до змінних Width і Height , ніби вони є членами класу Triangle . На рис. 11.1 схематично показано, як клас TwoDShape вводиться в клас Triangle .

Рисунок 11.1 - Схематичне зображення класу Triangle

Незважаючи на те, що клас TwoDShape є базовим для класу Triangle, в той же час він є абсолютно незалежним і самодостатнім класом. Якщо клас є базовим для похідного класу, це зовсім не означає, що він не може бути використаний самостійно. Наприклад, наступний фрагмент коду вважається повністю допустимим.

TwoDShape shape = new TwoDShape();

shape.Width = 10;

shape.Height = 20;

shape.ShowDim();

Звичайно, об'єкт класу TwoDShape ніяк не пов'язаний з будь-яким з класів, похідних від класу TwoDShape , і взагалі не має до них доступу. Нижче наведено загальна форма оголошення класу, що успадковується від базового класу.

```csharp
class ім'я_похідного_класу : ім'я_базового_класу {
```

// тіло класу

Для будь-якого похідного класу можна вказати лише один базовий клас. У C# не передбачено успадкування кількох базових класів в одному похідному класі. (У цьому відношенні C# відрізняється від C++, де допускається успадкування кількох базових класів. Цю обставину слід враховувати при перенесенні коду C++ в С#.) Однак можна створити ієрархію успадкування, в якій похідний клас стає базовим для іншого похідного класу. (Звичайно, жоден з класів не може бути базовим для самого себе як безпосередньо, так і посередньо.) Але в будь-якому випадку похідний клас успадковує всі члени свого базового класу, включаючи змінні екземпляра, методи, властивості та індексатори.

Головна перевага успадкування полягає в наступному: як тільки буде створений базовий клас, в якому визначені загальні для багатьох об'єктів атрибу ти, його можна використовувати для створення будь-якої кількості більш конкретних похідних класів. А в кожному похідному класі може бути точно впорядкована своя власна класифікація. Як приклад нижче наведено ще один клас, похідний від класу TwoDShape і інкапсулюючий прямокутники.

11.2 Доступ до членів класу і успадкування

Як пояснювалося в главі 8, члени класу часто оголошуються закритими, щоб виключити їх несанкціоноване або незаконне використання. Але наслідування класу не скасовує обмеження, накладені на доступ до закритих членів класу. Тому, якщо всі члени його базового класу входять до похідного класу, вони все одно залишаються недоступними ті члени базового класу, які є закритими. Так, якщо зробити змінні класу TwoDShape закритими, вони стануть недоступними в класі Triangle , як показано нижче.

Лістинг 11.3 - Доступ до закритих членів класу не успадковується.

// Клас для двовимірних об'єктів.

```csharp
class TwoDShape
```

double Width; // тепер це закрита змінна

double Height; // тепер це закрита змінна

public void ShowDim()

```csharp
Console.WriteLine("Ширина і висота дорівнюють " +
```

Width + " і " + Height);

// Клас Triangle, похідний від класу TwoDShape.

```csharp
class Triangle : TwoDShape
```

public string Style; // тип трикутника

// Повернути площу трикутника.

public double Area()

return Width * Height / 2; // Помилка, доступ до закритого

// члену класу заборонено

// Показати тип трикутника.

public void ShowStyle()

```csharp
Console.WriteLine("Трикутник " + Style);
```

Клас Triangle не буде компілюватися, оскільки звертатися до змінних Width і Height з методу Area() заборонено. А оскільки змінні Width і Height тепер є закритими, то вони доступні лише для інших членів свого класу, але не для членів похідних класів.

На перший погляд, обмеження на доступ до приватних членів базового класу з по хідного класу здається непереборним, оскільки воно не дає в багатьох випадках можливості користуватися приватними членами цього класу. Але насправді це не так. Для подолання даного обмеження в C# передбачені різні способи. Один з них полягає у використанні захищених ( protected ) членів класу, які розглядаються в наступному розділі, а другий - у застосуванні відкритих властивостей для доступу до закритих даних.

Як пояснювалося в попередньому розділі, властивість дозволяє керувати доступом до змінної екземпляра. Наприклад, за допомогою властивості можна накласти обмеження на доступ до значення змінної або зробити її доступною тільки для читання. Так, якщо зробити властивість відкритою, але оголосити її базову змінну закритою, то цією властивістю можна буде скористатися в похідному класі, але не можна буде отримати безпосередній доступ до її базової закритої змінної. Нижче наведено варіант класу TwoDShape, в якому змінні Widthі Height перетворені на властивості. Під час виконання в цьому класі перевіряється, чи є позитивними значення властивостей Widthі Height. Це, наприклад, дає можливість вказувати властивості Widthі Heightяк координати форми в будь-якому квадранті прямокутної системи координат, не отримуючи наперед їх абсолютні значення.

Лістинг 11.4 - Як використовувати відкриті властивості

// Клас для двовимірних об'єктів.

```csharp
class TwoDShape
```

double pri_width; // тепер це закрита змінна

double pri_height; // тепер це закрита змінна

// Властивості ширини і висоти двовимірного об'єкта.

public double Width

```csharp
get { return pri_width; }
set { pri_width = value < 0 ? value: value; }
```

public double Height

```csharp
get { return pri_height; }
set { pri_height = value < 0 ? value: value; }
```

public void ShowDim()

```csharp
Console.WriteLine("Ширина і висота дорівнюють " +
```

Width + " і " + Height);

// Клас для трикутників, похідний від

// класу TwoDShape.

```csharp
class Triangle : TwoDShape
```

public string Style; // тип трикутника

// Повернути площу трикутника.

public double Area()

return Width * Height / 2;

// Показати тип трикутника.

public void ShowStyle()

```csharp
Console.WriteLine("Трикутник " + Style);
```

У цьому варіанті властивості Width і Height надають доступ до закритих членів pri_width і pri_height класу TwoDShape , в яких фактично зберігаються значення ширини і висоти двовимірного об'єкта. Отже, значення членів pri_width і pri_height класу TwoDShape можуть бути встановлені і отримані за допомогою відповідних відкритих властивостей, незважаючи на те, що самі ці члени за- лишаються закритими. Базові та похідні класи іноді також називаються суперкласом та підкласом. Ці терміни походять з практики програмування на Java. Те, що в Java називається суперкласом, в C# позначається як базовий клас. А те, що в Java називається підкласом, в C# позначається як похідний клас. Обидва ряди термінів часто застосовуються до класу в обох мовах програмування, але в цій книзі продовжують використовуватися загальноприйняті в C# терміни базового та похідного класів, які звичайно використовуються й в C++.

11.3 Організація захищеного доступу

Як пояснювалося вище, відкритий член базового класу недоступний для похідного класу. З цього можна припустити, що для доступу до деякого члена базового класу з похідного класу цей член необхідно зробити відкритим. Але якщо зробити член класу відкритим, то він стане доступним для всього коду, що далеко не завжди бажано. Правда, згадане припущення вірно лише частково, оскільки в C# допускається створення захищеного члена класу.

Захищений член є відкритим в межах ієрархії класів, але закритим поза цією ієрархією. Захищений член створюється за допомогою модифікатора доступу protected . Якщо член класу оголошується як protected , він стає закритим, за винятком одного випадку, коли захищений член успадковується. У цьому випадку захищений член базового класу стає захищеним членом похідного класу, тобто доступним для похідного класу. Отже, використовуючи модифікатор доступу protected , можна створювати члени класу, які є закритими для свого класу, але все ж доступними для похідного класу.

Лістинг 11.5 - Приклад застосування модифікатора доступу protected

```csharp
class В
```

protected int i, j; // члени, закриті для класу В,

// але доступні для класу D

public void Set(int a, int b)

i = a;

j = b;

public void Show()

```csharp
Console.WriteLine(i + " " + j);
class D : В
```

int k; // закритий член

// члени i і j класу В доступні для класу D

public void Setk()

k = i * j;

public void Showk()

```csharp
Console.WriteLine(k);
```

У цьому прикладі клас В успадковується класом D, а його елементи iі jоголошені як protected, тому вони доступні для методу Setk(). Якби елементи iі jкласу В були оголошені як private, то вони були б недоступними для класу D, і при поданому вище коді його не можна було б скомпілювати. Аналогічно стану public і private , стан protected зберігається за елементом класу незалежно від кількості рівнів успадкування. Тому коли похідний клас використовується як базовий для іншого похідного класу, будь-який захищений елемент початкового базового класу, успадкований першим похідним класом, успадковується як захищений і другим похідним класом.

Незважаючи на всю свою корисність, захищений доступ придатний далеко не для всіх ситуацій. Так, в класі TwoDShape з показаного раніше прикладу потрібно, щоб значення його членів Width і Height були доступними відкрито, оскільки потрібно було керувати значеннями, які їм присвоювалися, що було б неможливо, якби вони були оголошені як protected . У даному випадку більш підходя щим рішенням виявилося застосування властивостей, щоб керувати доступом, а не пере дотворити його. Отже, модифікатор доступу protected слід застосовувати у випадку, якщо потрібно створити член класу, доступний для всієї ієрархії класів, але для решти коду він повинен бути закритим. А для керування доступом до значення члена класу краще скористатися властивістю.

11.4 Конструктори і успадкування

У ієрархії класів допускається, щоб у базових і похідних класів були свої власні конструктори. У зв'язку з цим виникає наступне розумне питання: який конструктор відповідає за побудову об'єкта похідного класу: конструктор базового класу, конструктор похідного класу або обидва? На це питання можна відповісти так: конструктор базового класу будує базову частину об'єкта, а кон структор похідного класу - похідну частину цього об'єкта. І в цьому є своя логіка, оскільки базовому класу невідомі і недоступні будь-які елементи похід ного класу, отже, їх побудова повинна відбуватися окремо. У наведених вище прикладах це питання не виникало, оскільки вони базувалися на автоматичному створенні конструкторів, що використовуються в C# за замовчуванням. Але на практиці конструктори визначаються у більшості класів. Нижче буде показано, яким чином вирішується подібна ситуація.

Якщо конструктор визначений тільки в похідному класі, то все відбувається дуже просто: конструюється об'єкт похідного класу, а базова частина об'єкта автома тично конструюється його конструктором, що використовується за замовчуванням. Як приклад нижче наведено перероблений варіант класу Triangle в якому визначається конструктор, а член Style робиться закритим, оскільки тепер він встановлюється конструктором.

Лістинг 11.6 - Додати конструктор в клас Triangle

// Клас для двовимірних об'єктів.

```csharp
class TwoDShape
```

double pri_width;

double pr.i_height;

// Властивості ширини і довжини об'єкта.

public double Width

```csharp
get { return pri_width; }
set { pri_width = value < 0 ? value: value; }
```

public double Height

```csharp
get { return pri_height; }
set { pri_height = value < 0 ? value: value; }
```

public void ShowDim()

```csharp
Console.WriteLine("Ширина і довжина дорівнюють " +
```

Width + " і " + Height);

// Клас для трикутників, похідний від класу TwoDShape.

```csharp
class Triangle : TwoDShape
```

string Style;

// Конструктор.

public Triangle(string s, double w, double h)

Width = w; // ініціалізувати член базового класу

Height = h; // ініціалізувати член базового класу

Style = s; // ініціалізувати член похідного класу

// Повернути площу трикутника.

public double Area()

return Width * Height / 2;

// Показати тип трикутника.

public void ShowStyle()

```csharp
Console.WriteLine("Трикутник " + Style);
```

У даному прикладі конструктор класу Triangle ініціалізує успадковані члени класу TwoDShape разом з його власним полем Style. Коли конструктори визначаються як у базовому, так і в похідному класі, процес побудови об'єкта дещо ускладнюється, оскільки повинні виконуватися конструктори обох класів. У даному випадку доводиться звертатися до ще одного ключового слова мови C#: base , яке має подвійне застосування: по-перше, для виклику конструктора базового класу; і по-друге, для доступу до члена базового класу, що приховується за членом похідного класу. Нижче буде розглянуто перше при зміна ключового слова base.

11.5 Виклик конструкторів базового класу

За допомогою форми розширеного оголошення конструктора похідного класу і ключового слова base у похідному класі може бути викликаний конструктор, визначений в його базовому класі. Нижче наведена загальна форма цього розширеного оголошення:

```csharp
конструктор_похідного_класу(список_параметрів) :base(список_аргументів) { // тіло конструктора }
```

де список_аргументів означає будь-які аргументи, необхідні конструктору у базовому класі. Зверніть увагу на розташування двокрапки. Для того, щоб продемонструвати застосування ключового слова base на конкретному прикладі, розглянемо ще один варіант класу TwoDShape у наведеній нижче програмі. У даному прикладі визначається конструктор, що ініціалізує властивості Width і Height. Потім цей конструктор викликається конструктором класу Triangle.

Лістинг 11.7 - Додати конструктор в клас TwoDShape

```csharp
class TwoDShape
```

double pri_width;

double pri_height;

// Конструктор класу TwoDShape.

public TwoDShape(double w, double h)

Width = w;

Height = h;

// Властивості ширини і висоти об'єкта.

public double Width

```csharp
get { return pri_width; }
set { pri_width = value < 0 ? value: value; }
```

public double Height

```csharp
get { return pri_height; }
set { pri_height = value < 0 ? value: value; }
```

public void ShowDim()

```csharp
Console.WriteLine("Ширина і висота дорівнюють " +
```

Width + " і " + Height);

// Клас для трикутників, похідний від класу TwoDShape.

```csharp
class Triangle : TwoDShape
```

string Style;

// Викликати конструктор базового класу.

public Triangle(string s, double w, double h) : base(w, h)

Style = s;

// Повернути площу трикутника.

public double Area()

return Width * Height / 2;

// Показати тип трикутника.

public void ShowStyle()

```csharp
Console.WriteLine("Трикутник " + Style);
```

Тепер конструктор класу Трикутник оголошується наступним чином.

```csharp
public Triangle( string s, double w, double h) : base(w, h) {
```

У даному варіанті конструктор Трикутник() викликає метод base з параметрами w і h . Це, в свою чергу, призводить до виклику конструктора TwoDShape() , що ініціалізує властивості Width і Height значеннями параметрів w і h . Вони більше не ініціалізуються засобами самого класу Трикутник , де тепер залишається ініціалізувати лише його власний член Style , що визначає тип трикутника. Завдяки цьому класу TwoDShape він звільняється від будь-якого обмеження щодо конструювання свого підоб'єкта. Більше того, в класі TwoDShape можна ввести функції, про які похідні класи навіть не будуть підозрювати, що запобігає порушенню існуючого коду.

За допомогою ключового слова base можна викликати будь-який конструктор, визначений у базовому класі, причому виконуватиметься лише той конструктор, параметри якого відповідають переданим аргументам. Нижче наведено розширені варіанти класів TwoDShape і Triangle , в які включені як конструктори за замовчуванням, так і конструктори, які приймають один аргумент.

Лістинг 11.8 - Додати додаткові конструктори в клас TwoDShape

```csharp
class TwoDShape
```

double pri_width;

double pri_height;

// Конструктор, викликається за замовчуванням.

public TwoDShape()

Width = Height = 0.0;

// Конструктор класу TwoDShape.

public TwoDShape(double w, double h)

Width = w;

Height = h;

// Побудувати об'єкт з однаковою шириною і висотою.

public TwoDShape(double х)

Width = Height = x;

// Властивості ширини і висоти об'єкта.

public double Width

```csharp
get { return pri_width; }
set { pri_width = value < 0 ? value: value; }
```

public double Height

```csharp
get { return pri_height; }
set { pri_height = value < 0 ? value: value; }
```

public void ShowDim()

```csharp
Console.WriteLine("Ширина і висота дорівнюють " +
```

Width + " і " + Height);

// Клас для трикутників, похідний від класу TwoDShape.

```csharp
class Triangle : TwoDShape
```

string Style;

/* Конструктор, використовується за замовчуванням.

Автоматично викликає конструктор, доступний за

замовчуванням в класі TwoDShape. */

public Triangle()

Style = "null";

// Конструктор, що приймає три аргументи.

public Triangle(

string s, double w, double h) : base(w, h)

Style = s;

// Побудувати рівнобедрений трикутник.

public Triangle(double x) : base(x)

Style = "рівнобедрений";

// Повернути площу трикутника.

public double Area()

return Width * Height / 2;

// Показати тип трикутника.

public void ShowStyle()

```csharp
Console.WriteLine("Трикутник " + Style);
```

А тепер розглянемо коротко основні принципи дії ключового слова base. Коли в похідному класі вказується ключове слово base, викликається конструктор з його безпосереднього базового класу. Отже, ключове слово baseзавжди звертається до базового класу, що стоїть в ієрархії безпосередньо над викликаю чим класом. Це справедливо навіть для багаторівневої ієрархії класів. Аргумен ти передаються базовому конструктору як аргументи методу base(). Якщо ж ключове слово відсутнє, то автоматично викликається конструктор, використовуваний в базовому класі за замовчуванням.

11.6 Успадкування і приховування імен

У похідному класі можна визначити член з таким самим ім'ям, як і у члена його базового класу. У цьому випадку член базового класу приховується в похідному класі . І хоча формально в C# це не вважається помилкою, компілятор все ж видасть повідомлення, що ім'я приховується. Якщо член базового класу потрібно приховати навмисно, то перед його ім'ям слід вказати ключове слово new, щоб уникнути появи подібного попередження. Слід, однак, майте на увазі, що це абсолютно окреме застосування ключового слова new, не схоже на його застосування при створенні екземпляра об'єкта.

Лістинг 11.9 - Приклад приховування імені з успадкованою зв'язком.

```csharp
class А
```

public int i = 0;

// Створити похідний клас.

```csharp
class В : А
```

new int i; // цей член приховує член i з класу А

public В(int b)

i = b; // член i в класі В

public void Show()

```csharp
Console.WriteLine("Член i в похідному класі: " + i);
class NameHiding
static void Main()
```

В ob = new В(2);

ob.Show();

Перш за все зверніть увагу на використання ключового слова new у наступному рядку коду.

new int i; // цей член приховує член i з класу А

У цьому рядку компілятору, по суті, повідомляється про те, що новостворена змінна i намірено приховує змінну i з базового класу А і що авто ру програми про це знають. Якщо ж пропустити ключове слово newу цьому рядку коду, то компілятор видаватиме попереджувальне повідомлення. Ось до якого результату призводить виконання наведеного вище коду. Член i в похідному класі: 2 У класі Ввизначається власна змінна екземпляра i, яка приховує змінну iз базового класу А. Тому при виклику методу Show() для об'єк та типу Ввиводиться значення змінної i, визначеної в класі В, а не тієї, що визначена в класі А.

11.6 Застосування ключового слова base для доступу до прихованого імені

Існує ще одна форма ключового слова base , яка діє подібно до ключового слова this , за винятком того, що вона завжди посилається на базовий клас в тому похідному класі, в якому вона використовується. Нижче ця форма наведена у загальному вигляді:

Base.член

де член може позначати метод або змінну екземпляра. Ця форма ключового слова base найчастіше застосовується у випадках, коли під іменами членів похідного класу приховуються члени базового класу з тими самими іменами. Як приклад нижче наведено інший варіант ієрархії класів з попереднього прикладу.

Лістинг 11.10 - Застосування ключового слова base для подолання перешкоди, пов'язаної з приховуванням імені.

```csharp
class А
```

public int i = 0;

// Створити похідний клас.

```csharp
class В : А
```

new int i; // цей член приховує член i з класу А

public В(int a, int b)

base.i = а; // тут виявляється прихований член з класу А

i = b; // член i з класу В

public void Show()

// Тут виводиться член i з класу А.

```csharp
Console.WriteLine("Член i в базовому класі: " + base.i);
```

// А тут виводиться член i з класу В.

```csharp
Console.WriteLine("Член i в похідному класі: " + i);
```

Незважаючи на те, що змінна екземпляра iу похідному класі В приховує змінну i з базового класу А, ключове слово base дозволяє доступ до змін ної i, визначеної в базовому класі. За допомогою ключового слова base можуть також викликатися приховані методи . Наприклад, у наведеному нижче коді клас В успадковує клас А і в обох класах оголошується метод Show(). А потім у методі Show()класу Вза допомогою ключового слова base викликається варіант методу Show(), визначений у класі А.

Лістинг 11.11 - Викликати прихований метод

```csharp
class А
```

public int i = 0;

// Метод Show() у класі A

public void Show()

```csharp
Console.WriteLine("Член i у базовому класі: " + i);
```

// Створити похідний клас.

```csharp
class В : А
```

new int i; // цей член приховує член i з класу А

public В(int a, int b)

base.i = а; // тут виявляється прихований член з класу А

i = b; // член i з класу В

// Тут приховується метод Show() з класу А. Зверніть увагу

// на використання ключового слова new.

new public void Show()

base.Show(); // тут викликається метод Show() з класу А

// далі виводиться член i з класу В

```csharp
Console.WriteLine("Член i в похідному класі: " + i);
```

Як бачите, у виразіbase.Show()викликається варіант методу Show()з базового класу базового класу. Зверніть також увагу на наступне: ключове слово new використовується в при веденому вище коді з метою повідомити компілятору, що метод Show(), знову оголошений в похідному класі В, намірено приховує інший метод Show(), визначений в базовому класі А.

11.7 Створення багаторівневої ієрархії класів

У раніше наведених прикладах програм використовувалися прості ієрархії класів , що складалися лише з базового і похідного класів. Але в C# можна але також будувати ієрархії, що складаються з будь-якої кількості рівнів наслідування. Як зазначалося вище, багаторівнева ієрархія ідеально підходить для використання одного похідного класу як базового для іншого похідного класу. Так, якщо є класи, А, Ві С, то клас С може успадковувати від класу В, а той, в свою чергу, від класу А. У такому випадку кожен похідний клас успадковує ха рактерні особливості всіх своїх базових класів. Зокрема, клас С успадковує всі члени класів Ві А. Для того щоб показати , наскільки корисною може бути багаторівнева ієрархія класів, розглянемо наступний приклад програми. У ній похідний клас Triangle служить в якості базового для створення іншого похідного клас у —ColorTriangle. При цьому клас ColorTriangle успадковує всі характерні осо бливості, а по суті, члени класів Triangleі TwoDShape, до яких додається поле color, що містить колір трикутника.

Лістинг 11.12 - Приклад побудови багаторівневої ієрархії класів

```csharp
class TwoDShape
```

double pri_width;

double pri_height;

// Конструктор, використовуваний за замовчуванням.

public TwoDShape()

Width = Height = 0.0;

// Конструктор для класу TwoDShape.

public TwoDShape(double w, double h)

Width = w;

Height = h;

// Побудувати об'єкт з однаковою шириною і висотою.

public TwoDShape(double х)

Width = Height = x;

// Властивості ширини і висоти об'єкта.

public double Width

```csharp
get { return pri_width; }
set { pri_width = value < 0 ? value: value; }
```

public double Height

```csharp
get { return pri_height; }
set { pri_height = value < 0 ? value: value; }
```

public void ShowDim()

```csharp
Console.WriteLine("Ширина і висота дорівнюють " +
```

Width + " і " + Height);

// Клас для трикутників, похідний від класу TwoDShape.

```csharp
class Triangle : TwoDShape
```

string Style; // закритий член класу

/* Конструктор, використовується за замовчуванням.

Автоматично викликає конструктор, доступний за

замовчуванням в класі TwoDShape. */

public Triangle()

Style = "null";

// Конструктор.

public Triangle(string s, double w, double h) : base(w, h)

Style = s;

// Побудувати рівнобедрений трикутник.

public Triangle(double x) : base(x)

Style = "рівнобедрений";

// Повернути площу трикутника.

public double Area()

return Width * Height / 2;

// Показати тип трикутника.

public void ShowStyle()

```csharp
Console.WriteLine("Трикутник " + Style);
```

// Розширити клас Triangle.

```csharp
class ColorTriangle : Triangle
```

string color;

public ColorTriangle(string c, string s,

double w, double h) : base(s, w, h)

color = c;

// Показати колір трикутника.

public void ShowColor()

```csharp
Console.WriteLine("Колір " + color);
```

Завдяки успадкуванню в класі ColorTriangle можуть використовуватися визначені раніше класи Triangle і TwoDShape , до елементів яких додається лише та інформація, яка потрібна для конкретного застосування даного класу. У цьому відчастина і полягає цінність успадкування, оскільки воно дозволяє повторне використання коду. Наведений вище приклад демонструє ще одне важливе положення: ключове слово base завжди позначає посилання на конструктор найближчого за ієрархією базового класу. Так, ключове слово base в класі ColorTriangle означає виклик конструктора з класу Triangle, а ключове слово base в класі Triangle — виклик конструктора з класу TwoDShape. Якщо ж в ієрархії класів конструктору базо вого класу потрібні параметри, то всі похідні класи повинні надати ці параметри вгору по ієрархії, незалежно від того, потрібні вони самому похід ному класу чи ні.

11.8 Порядок виклику конструкторів

У зв'язку з вищевикладеним щодо успадкування та ієрархії класів може виникнути наступне обґрунтоване питання: коли створюється об'єкт похідного класу і який конструктор виконується першим - той, що визначений у похідному класі, чи той, що визначений у базовому класі? Так, якщо є базовий клас А і похідний клас В , то викликається конструктор класу А раніше конструктора класу В ? Відповідь на це питання полягає в тому, що в ієрархії класів конструктори викликаються в порядку виведення класів: від базового до похідного. Більше того, цей порядок залишається незмінним незалежно від використання ключового слова base . Отже, якщо ключове слово base не використовується, то виконується конструктор за замовчуванням, тобто конструктор без параметрів. У наведеному нижче прикладі програми демонструється порядок виклику та виконання конструкторів.

Лістинг 11.13 - Продемонструвати порядок виклику конструкторів

// Створити базовий клас.

```csharp
class А
```

public А()

```csharp
Console.WriteLine("Конструювання класу А.");
```

// Створити клас, похідний від класу А.

```csharp
class В : А
```

public В()

```csharp
Console.WriteLine("Конструювання класу В.");
```

// Створити клас, похідний від класу В.

```csharp
class С : В
```

public С()

```csharp
Console.WriteLine("Конструювання класу С.");
class OrderOfConstruction
static void Main()
```

С с = new С();

Як бачите, конструктори викликаються в порядку виведення їх класів. Якщо добре подумати, то в виклику конструкторів в порядку виведення їх класів можна виявити певний зміст. Адже базовому класу нічого не відомо ні про один з похідних від нього класів, і тому будь-яка ініціалізація, яка потрібна його членам, здійснюється зовсім окремо від ініціалізації членів похідного класу, і можливо, це і необхідна умова. Отже, вона повинна виконуватися першою.

11.9 Посилання на базовий клас і об'єкти похідних класів

Як вам вже повинно бути відомо, C# є строго типізованою мовою програмування. Крім стандартних перетворень і автоматичного про движення простих типів значень , в цій мові строго дотримується принцип сумісності типів. Це означає, що змінна посилання на об'єкт класу одного типу, зазвичай, не може посилатися на об'єкт класу іншого типу. Як приклад розглянемо наступну програму, в якій оголошуються два класи однакової структури.

Лістинг 11.14 - Приклад програми

```csharp
class X
```

int а;

```csharp
public X(int i) { a = i; }
class Y
```

int a;

```csharp
public Y(int i) { a = i; }
class IncompatibleRef
static void Main()
```

X x = new X(10);

X x2;

Y у = new Y(5);

x2 = x; // правильно, оскільки обидва об'єкти належать до одного й того ж типу

х2 = у; // помилка, оскільки це різнотипні об'єкти

Незважаючи на те, що класи X і Y у цьому прикладі абсолютно однакові за своєю структурою, посилання на об'єкт типу Y не можна присвоїти змінній посилання на об'єкт типу X, оскільки типи у них різні. Тому наступний рядок коду виявляється неправильним і може призвести до помилки через несумісність типів під час компі ляції.

х2 = у; // неправильно, оскільки це різнотипні об'єкти

Загалом, змінна посилання на об'єкт може посилатися тільки на об'єкт свого типу. Але з цього принципу строгого дотримання типів в C# є одне важливе виняток: змінній посилання на об'єкт базового класу може бути присвоєно посилання на об' єкт будь-якого похідного від нього класу. Таке присвоєння вважається повністю неприпустимим, оскільки екземпляр об'єкта похідного типу інкапсулює екземпляр об' єкта базового типу. Отже, за допомогою посилання на об'єкт базового класу можна звертатися до об'єкта похідного класу. Нижче наведено відповідний приклад.

Лістинг 11.15 - З посиланням на об'єкт базового класу можна звертатися

```csharp
class X
```

public int a;

public X(int i)

a = i;

```csharp
class Y : X
```

public int b;

public Y(int i, int j) : base(j)

b = i;

```csharp
class BaseRef
static void Main()
```

X x = new X(10);

X x2;

Y у = new Y(5, 6);

x2 = x; // правильно, оскільки обидва об'єкти належать до одного й того ж типу

```csharp
Console.WriteLine("х2.а: " + х2.а);
```

х2 = у; // також правильно, оскільки клас Y є похідним від класу X

```csharp
Console.WriteLine("х2.а: " + х2.а);
```

// посиланням на об'єкти класу X відомо тільки про члени класу X

х2.а = 19; // правильно

// х2.b = 27; // неправильно, оскільки член b відсутній у класі X

Слід особливо підкреслити, що доступ до конкретних членів класу визначається типом змінної посилання на об'єкт, а не типом об'єкта, на який вона посилається. Це означає, що якщо посилання на об'єкт похідного класу присвоюється змінній посилання на об'єкт базового класу, то доступ дозволяється лише до тих частин цього об'єкта, які визначаються базовим класом. Саме тому змінній х2 недоступний член b класу Y , коли вона посилається на об'єкт цього класу. І в цьому є своя логіка, оскільки базовому класу нічого не відомо про ті члени, які додані в похідний від нього клас. Саме тому останній рядок коду в наведеному вище прикладі був закоментований. Незважаючи на здавалося б незначно відволікаючий характер наведених вище розсуджень, їх можна знайти кілька важливих застосувань на практиці. Одне з них роз глядається нижче, а інше - далі в цьому розділі, коли йдеться про віртуальні методи.

11.10 Віртуальні методи і їх перевизначення

Віртуальнимназивається такий метод, який оголошується як virtual у базовому класі. Віртуальний метод відрізняється тим, що його можна перевизначити в одному або кількох похідних класах. Отже, у кожного похідного класу може бути свій варіант віртуального методу. Крім того, віртуальні методи цікаві тим, що саме відбувається при їх виклику за посиланням на базовий клас. У цьому випадку засобами мови C# визначається саме той варіант віртуального методу, який слід викликати, виходячи з типу об'єкта, до якого здійснюється звернення за посиланням, причому це робиться під час виконання.

Тому при посиланні на різні типи об'єктів виконуються різні варіанти віртуального методу. Іншими словами, варіант виконуваного віртуального методу вибирається за типом об'єкта, а не за типом посилання на цей об'єкт. Так, якщо базовий клас містить віртуальний метод і від нього отримані похідні класи, то при зверненні до різних типів об'єктів за посиланням на базовий клас виконуються різні варіанти цього віртуального методу. Метод оголошується як віртуальний у базовому класі за допомогою ключового слова virtual , яке вказується перед його ім'ям. Коли віртуальний метод перевизначається в похідному класі, для цього використовується модифікатор override .

А сам процес повторного визначення віртуального методу в похідному класі називається перевизначенням методу. При перевизначенні ім'я, повернений тип і сигнатура перевизначаючого методу повинні бути точно такими ж, як і у того віртуального методу, який перевизначається.. Крім того, віртуальний метод не може бути оголошений як static або abstract (докладніше це питання розглядається далі в цьому розділі). Перевизначення методу є основою для втілення одного з найефективніших принципів в C#: динамічної диспетчеризації методів, яка представляє собою механізм вирішення виклику під час виконання, а не компіляції. Значення динамічної диспетчеризації методів полягає в тому, що саме завдяки їй в C# реалізується динамічний поліморфізм.

Лістинг 11.16 - Демонстрація віртуальних методів

```csharp
class Base
```

// Створити віртуальний метод у базовому класі.

public virtual void Who()

```csharp
Console.WriteLine("Метод Who() у класі Base");
class Derivedl : Base
```

// Перевизначити метод Who() у похідному класі.

public override void Who()

```csharp
Console.WriteLine("Метод Who() у класі Derivedl");
class Derived2 : Base
```

// Знову перевизначити метод Who() у ще одному похідному класі.

public override void Who()

```csharp
Console.WriteLine("Метод Who() у класі Derived2");
```

У коді з наведеного вище прикладу створюються базовий клас Base і два похідні від нього класи — Derived1 і Derived2 . У класі Base оголошується віртуаль ний метод Who() , який перевизначається в обох похідних класах. Потім у методі Main() оголошуються об'єкти типу Base , Derived1 і Derived2 . Крім того, оголошується змінна baseRef посилального типу Base . Далі посилання на кожен тип об'єкта присвоюється змінній baseRef і потім використовується для виклику мето да Who() . Як видно з результату виконання наведеного вище коду, варіант виконуваного методу Who() визначається за типом об'єкта, до якого звертається посилання під час виклику цього методу, а не за типом класу змінної. BaseRef.

Але перевизначати віртуальний метод зовсім не обов'язково. Адже якщо в похідному класі не надається власний варіант віртуального методу, то використовується його варіант з базового класу, як у наведеному нижче прикладі.

Лістинг 11.17 - Приклад з неперевизначенням вірутального методу

```csharp
using System;
class Base
```

// Створити віртуальний метод у базовому класі.

public virtual void Who()

```csharp
Console.WriteLine("Метод Who() у класі Base");
class Derived1 : Base
```

// Перевизначити метод Who() у похідному класі.

public override void Who()

```csharp
Console.WriteLine("Метод Who() в класі Derived1");
class Derived2 : Base
```

// У цьому класі метод Who() не перевизначається.

```csharp
class NoOverrideDemo
static void Main()
```

Base baseOb = new Base();

Derived1 dOb1 = new Derived1();

Derived2 dOb2 = new Derived2();

Base baseRef; // посилання на базовий клас

baseRef = baseOb;

baseRef.Who();

baseRef = dOb1;

baseRef.Who();

baseRef = dOb2;

baseRef.Who(); // викликається метод Who() з класу Base

Завдяки перевизначенню методів в C# підтримується динамічний поліморфізм. У об'єктно-орієнтованому програмуванні поліморфізм відіграє дуже важливу роль, оскільки він дозволяє визначити в загальному класі методи, які стають загальними для всіх похідних від нього класів, а в похідних класах - визначити конкретну реалізацію деяких або всіх цих методів. Перевизначення методів - це ще один спосіб втілити в C# головний принцип поліморфізму: один інтерфейс - багато методів. Успішне застосування поліморфізму в певній мірі залежить від правильного розуміння тієї особливості, що базові і похідні класи утворюють ієрархію, яка просувається від меншої до більшої спеціалізації. При належному застосуванні базовий клас надає всі необхідні елементи, які можуть використовуватися у похідному класі безпосередньо. А за допомогою віртуальних методів у базовому класу визначаються ті методи, які можуть бути самостійно реалізовані в похідному класі. Отже, поєднуючи успадкування з віртуальними методами, можна визначити в базовому класі загальну форму методів, які будуть використовуватися в усіх його похідних класах.

11.11 Застосування абстрактних класів

Іноді потрібно створити базовий клас, в якому визначається лише найзагальніша форма для всіх його похідних класів, а наповнення її деталями надається кожному з цих класів. У такому класі визначається лише характер методів, які повинні бути конкретно реалізовані в похідних класах, а не в самому базовому класі. Подібна ситуація виникає, наприклад, у зв'язку з неможливістю отримати змістовну реалізацію методу в базовому класі. Саме така ситуація була продемонстрована у варіанті класу TwoDShape з попереднього прикладу, де метод Area() був просто визначений як заповнювач. Такий метод не обчислює і не виводить площу двовимірного об'єкта будь-якого типу.

Створюючи власні класи бібліотек, ви можете переконатися, що метод часто не має конкретного визначення в контексті його базового класу. Таку ситуацію можна вирішити двома способами. Один з них, як показано у попередньому прикладі, полягає в тому, щоб просто вивести попереджувальне повідомлення. Такий спосіб може бути корисним у певних ситуаціях, наприклад, при налагодженні, але в практиці програмування він зазвичай не застосовується. Адже в базовому у класі можуть бути оголошені методи, які повинні бути перевизначені в похідному класі, щоб цей клас став значущим. Розглянемо для прикладу клас Triangle. Він був би неповним, якби в ньому не був перевизначений метод Area() . У подібних випадках потрібний якийсь спосіб, що гарантує, що в похідному класі дійсно будуть перевизначені всі необхідні методи. І такий спосіб у C# існує. Він полягає в використанні абстрактного методу.

Абстрактний метод створюється за допомогою модифікатора типу abstract . У абстрактного методу відсутнє тіло, і тому він не реалізується в ба зовому класі. Це означає, що він повинен бути перевизначений в похідному класі, оскільки його варіант з базового класу просто непридатний для використання. Не складно здогадатися , що абстрактний метод автоматично стає віртуальним і не потребує вказівки модифікатора virtual . Насправді спільне використання модифікаторів virtual і abstract вважається помилкою

Для визначення абстрактного методу використовується загальна форма, наведена нижче. abstract тип ім'я(список_параметрів);

```csharp
Як бачите, у абстрактного методу відсутнє тіло. Модифікатор abstract може застосовуватися тільки в методах екземпляра, а не в статичних методах ( static ). Абстрактними можуть бути також індексатори і властивості. Клас, що містить один або більше абстрактних методів, також повинен бути оголошений як абстрактний, і для цього перед його оголошенням class вказується модифікатор abstract . А оскільки реалізація абстрактного класу не визначається повністю , то у нього не може бути об'єктів.
```

Отже, спроба створити об'єкт аб страктного класу за допомогою оператора new призведе до помилки під час компіляції. Коли похідний клас успадковує абстрактний клас, в ньому повинні бути реалізовані всі абстрактні методи базового класу. У протилежному випадку похідний клас також повинен бути визначений як abstract . Отже, атрибут abstract успадковується до тих пір, поки не буде досягнута повна реалізація класу. Використовуючи абстрактний клас, ми можемо вдосконалити розглянутий раніше клас TwoDShape.

Для невизначеної двовимірної фігури поняття площі не має жодного сенсу, тому в наведеному нижче варіанті класу TwoDShape метод Area() і сам клас TwoDShape оголошуються як abstract . Це, звичайно, означає, що в усіх класах, похідних від класу TwoDShape , повинен бути перевизначений метод Area().

Лістинг 11.18 - Приклад абстрактного класу

```csharp
using System.Xml.Linq;
abstract class TwoDShape
```

double pri_width;

double pri_height;

// Конструктор, використовуваний за замовчуванням.

public TwoDShape()

Width = Height = 0.0;

name = "null";

// Параметризований конструктор.

public TwoDShape(double w, double h, string n)

Width = w;

Height = h;

name = n;

// Побудувати об'єкт з однаковою шириною і висотою.

public TwoDShape(double х, string n)

Width = Height = x;

name = n;

// Сконструювати копію об'єкта TwoDShape.

public TwoDShape(TwoDShape ob)

Width = ob.Width;

Height = ob.Height;

name = ob.name;

// Властивості ширини і висоти об'єкта.

public double Width

```csharp
get { return pri_width; }
set { pri_width = value < 0 ? value: value; }
```

public double Height

```csharp
get { return pri_height; }
set { pri_height = value < 0 ? value: value; }
public string name { get; set; }
```

public void ShowDim()

```csharp
Console.WriteLine("Ширина і висота дорівнюють " +
```

Width + " і " + Height);

// Тепер метод Area() є абстрактним.

public abstract double Area();

// Клас для трикутників, похідний від класу TwoDShape.

```csharp
class Triangle : TwoDShape
```

string Style;

// Конструктор, використовуваний за замовчуванням.

public Triangle()

Style = "null";

// Конструктор для класу Triangle.

public Triangle(string s, double w, double h) :

base(w, h, "трикутник")

Style = s;

// Побудувати рівнобедрений трикутник,

public Triangle(double х) : base(x, "трикутник")

Style = "рівнобедрений";

// Побудувати копію об'єкта типу Triangle.

public Triangle(Triangle ob) : base(ob)

Style = ob.Style;

// Перевизначити метод Area() для класу Triangle.

public override double Area()

return Width * Height / 2;

// Показати тип трикутника.

public void ShowStyle()

```csharp
Console.WriteLine("Трикутник " + Style);
```

// Клас для прямокутників, похідний від класу TwoDShape

```csharp
class Rectangle : TwoDShape
```

// Конструктор для класу Rectangle.

public Rectangle(double w, double h) :

base(w, h, "прямокутник")

```csharp
{ }
```

// Побудувати квадрат.

public Rectangle(double x) :

base(x, "прямокутник")

```csharp
{ }
```

// Сконструювати копію об'єкта типу Rectangle.

```csharp
public Rectangle(Rectangle ob) : base(ob) { }
```

// Повернути логічне значення true, якщо

// прямокутник виявиться квадратом.

public bool IsSquare()

if (Width == Height) return true;

return false;

// Перевизначити метод Area() для класу Rectangle.

public override double Area()

return Width * Height;

```csharp
class AbsShape
static void Main()
```

TwoDShape[] shapes = new TwoDShape[4];

shapes[0] = new Triangle("прямокутний", 8.0, 12.0);

shapes[1] = new Rectangle(10);

shapes[2] = new Rectangle(10, 4);

shapes[3] = new Triangle(7.0);

for (int i = 0; i < shapes.Length; i++)

```csharp
Console.WriteLine("Об'єкт — " + shapes[i].name);
Console.WriteLine("Площа дорівнює " + shapes[i].Area());
Console.WriteLine();
```

Як показує наведений вище приклад програми, в усіх похідних класах метод Area () повинен бути обов'язково перевизначений, а також оголошений аб страктним. Переконайтеся в цьому самі, спробувавши створити похідний клас, в якому не перевизначений метод Area() . У результаті ви отримаєте повідомлення про помилку під час компіляції. Звичайно, можливість створювати посилання на об'єкти типу TwoDShape по- прежньому існує, і це було зроблено в наведеному вище прикладі програми, але оголошувати об'єкти типу TwoDShape вже не можна. Саме тому масив shapes скорочений в методі Main() до 4 елементів, а об'єкт типу TwoDShape для загальної двох вимірної форми більше не створюється. Зверніть увагу, що класі TwoDShape надалі містить метод ShowDim() і він не оголошується з модифікатором abstract . В абстрактних класах допускається (і часто практикується) включення конкретних методів, які можуть бути використані в похідному класі у своєму початковому вигляді. Перевизначенню підлягають тільки ті методи в похідних класах, які оголошені як abstract.

11.12 Запобігання успадкуванню за допомогою ключового слова sealed

Незважаючи на всю ефективність та корисність успадкування, іноді виникає потреба його запобігти. Припустимо, що є клас, який інкапсулює послідовність ініціалізації деякого спеціального обладнання, наприклад, медичного монітора. У цьому випадку потрібно, щоб користувачі даного класу не могли змінювати порядок ініціалізації монітора, щоб уникнути його неправильної настройки. Але незалежно від конкретних причин, в C# є можливість запобігти успадкуванню класу за допомогою ключового слова sealed.

Для того, щоб запобігти успадкуванню класу, достатньо вказати ключове слово sealed перед визначенням класу. Як і очікувалося, клас не може бути одночасно оголошений як abstract та sealed , оскільки сам абстрактний клас не реалізований повністю і залежить від своїх похідних класів, які забезпечують повну реалізацію.

Нижче наведено приклад оголошення класу типу sealed.

```csharp
sealed class А { // ... }
```

Наступний клас недопустимий.

```csharp
class В : A ( // ПОМИЛКА! Не можна успадковувати клас А // ... }
```

Як випливає з коментарів у вищезазначеному фрагменті коду, клас В не може успадковувати клас А , оскільки останній оголошений як sealed . І ще одне зауваження: ключове слово sealed може бути також використано у віртуальних методах для запобігання їх подальшого перевизначення. Припустимо, що є базовий клас В і похідний клас D . Метод, оголошений у класі В як virtual , може бути оголошений у класі D як sealed . Завдяки цьому у будь-якому класі, який успадковує від класу, запобігається перевизначення даного методу.

Лістинг 11.19 - Приклад sealed method.

```csharp
class В
public virtual void MyMethod() { /* ... */ }
class D : В {
```

// Тут герметизується метода MyMethod() і

// запобігається його подальше перевизначення.

```csharp
sealed public override void MyMethod() { /* ... */ }
class X : D
```

// Помилка! Метод MyMethodO герметизований!

```csharp
public override void MyMethod() { /* ... */ }
```

11.13 Клас object

У C# передбачений спеціальний клас object , який неявно вважається базовим класом для всіх інших класів і типів, включаючи типи значень. Іншими словами, всі інші типи є похідними від object . Це, зокрема, означає, що змінна посилального типу object може посилатися на об'єкт будь-якого іншого типу. Крім того, змінна типу object може посилатися на будь-який масив, оскільки в C# масиви реалізуються як об'єкти. Формально ім'я object вважається ще одним позначенням класу System.Object , який входить до бібліотеки класів для середовища .NET Framework.

Деякі з цих методів потребують додаткових пояснень. За замовчуванням метод Equals(object) визначає, чи посилається викликаючий об'єкт на той самий об'єкт , що й об'єкт, вказаний як аргумент цього методу, тобто він визначає, чи є обидва посилання однаковими. Метод Equals(object) повертає логічне значення true , якщо порівнювані об'єкти однакові, в іншому випадку - логічне значення false . Він також може бути перевизначений у створюваних класах. Це дозволяє з'ясувати, що означає рівність об'єктів для створюваного класу. Наприклад, метод Equals( object) можна визначити таким чином, щоб в ньому порівнювалось вміст двох об' єктів.

Рисунок 11.2 - методи класу Object

Метод GetHashCode() повертає хеш-код, пов'язаний з викликаючим об'єктом. Цей хеш-код можна потім використовувати в будь-якому алгоритмі, де хешування застосовується як засіб доступу до збережених об'єктів. Слід, однак, мати на увазі, що стандартна реалізація методу GetHashCode() не підходить для всіх випадків застосування. Як зазначалося в розділі 9, якщо перевантажується оператор == , то зазвичай потрібно перевизначити методи Equals(object) і GetHashCode() , оскільки найчастіше потрібно, щоб метод Equals(object) і оператор == працювали однаково. Коли ж перевизначається метод Equals(object) , то слід перевизначити і метод GetHashCode() , щоб обидва методи були сумісними. Метод ToString() повертає символьний рядок , що містить опис того об'єкта, для якого він викликається. Крім того, метод ToString() автоматично викликається при виведенні вмісту об'єкта за допомогою методу WriteLine(). Цей метод перевизначається в багатьох класах, що дозволяє пристосовувати опис до конкретних типів об'єктів, створених в цих класах. Нижче наведено приклад застосування цього методу.

Лістинг 11.20 - Приклад ToString().

```csharp
class MyClass
```

static int count = 0;

int id;

```csharp
public MyClass() {
```

id = count;

count++;

public override string ToString()

return "Об'єкт #" + id + " типу MyClass";

```csharp
class Test
static void Main()
```

MyClass ob1 = new MyClass();

MyClass ob2 = new MyClass();

MyClass ob3 = new MyClass();

```csharp
Console.WriteLine(obi);
Console.WriteLine(ob2);
Console.WriteLine(ob3);
```

11.14 Упаковка і розпакування

Як пояснювалося вище, всі типи в С#, включаючи прості типи значень, є похідними від класу object . Отже, посиланням типу object можна скористатися для звернення до будь-якого іншого типу, включаючи типи значень. Коли посилання на об'єкт класу object використовується для звернення до типу значення, такий процес називається упаковкою. Упаковка призводить до того, що значення простого типу зберігається в екземплярі об'єкта, тобто " упаковується " в об'єкті , який потім використовується як будь-який інший об'єкт.

Але в будь-якому випадку упаковка відбувається автоматично. Для цього достатньо присвоїти значення змінній посиланняного типу object , а про решту піклується компілятор С#. Розпакування представляє собою процес вилучення упакованого значення з об'єкта. Це робиться за допомогою явного приведення типу посилання на об'єкт класу object до відповідного типу значення. Спроба розпакувати об'єкт в інший тип може призвести до помилки під час виконання. Нижче наведено простий приклад, що демонструє упакування і розпакування.

Лістинг 11.21 - Простий приклад упакування і розпакування

```csharp
class BoxingDemo
static void Main()
```

int x;

object obj;

х = 10;

obj = x; // упакувати значення змінної х в об'єкт

int у = (int)obj; // розпакувати значення з об'єкта, доступного за

// посиланням obj, в змінну типу int

```csharp
Console.WriteLine(у);
```

У цьому прикладі коду виводиться значення 10. Зверніть увагу на те, що значе ня змінної х упаковується в об'єкт простим його присвоєнням змінній obj, яка посилається на цей об'єкт. А потім це значення вилучається з об'єкта, до ступного за його посиланням obj, і далі перетворюється до типу int. Нижче наведено ще один, більш цікавий приклад упакування. У даному випадку значення типу int передається як аргумент методу Sqr(), який, в свою чергу, приймає параметр типу object.

Лістинг 11.22 - Приклад упаковки при передачі значення методу.

```csharp
class BoxingDemo
static void Main()
```

int x;

x = 10;

```csharp
Console.WriteLine("Значення x дорівнює: " + x);
```

// значення змінної x автоматично упаковується

// коли воно передається методу Sqr().

х = BoxingDemo.Sqr(х);

```csharp
Console.WriteLine("Значення x в квадраті дорівнює: " + х);
```

static int Sqr(object о)

return (int)о * (int)о;

У даному прикладі значення змінної х автоматично упаковується при перед ачі методу Sqr(). Упаковка і розпакування дозволяють повністю уніфікувати систему типів в С#. Завдяки тому, що всі типи є похідними від класу object, посилання на значення будь-якого типу може бути просто присвоєне змінній посиланняного типу object, а все інше візьмуть на себе упаковка і розпакування. Більше того, методи класу object показуються доступними всім типам, оскільки вони є по хідними від цього класу.

11.15 Клас object як універсальний тип даних

Якщо object є базовим класом для всіх інших типів і упаковка значень простих типів відбувається автоматично, то клас object можна повністю використовувати як " універсальний " тип даних. Для прикладу розглянемо програму, в якій спочатку створюється масив типу object , елементам якого потім присвоюються значення різних типів даних.

Лістинг 11.23 - Використовувати клас object для створення масиву "загального" типу.

```csharp
class GenericDemo
static void Main()
```

object[] ga = new object[10];

// Зберегти цілі значення.

for (int i = 0; i < 3; i++)

ga[i] = i;

// Зберегти значення типу double.

for (int i = 3; i < 6; i++)

ga[i] = (double)i / 2;

// Зберегти два рядки, а також значення типу bool і char.

ga[6] = "Привіт";

ga[7] = true;

ga[8] = 'X';

ga[9] = "Кінець";

for (int i = 0; i < ga.Length; i++)

```csharp
Console.WriteLine("ga[" + i + "]: " + ga[i] + " ");
```

до даних будь-якого типу, оскільки в змінній посилального типу object допускається зберігати посилання на дані всіх інших типів.

Отже, в масиві типу object з розглянутого тут прикладу можна зберегти дані практично будь-якого типу. У розвиток цієї ідеї можна було б, наприклад, без особливих зусиль створити клас стеку з посиланнями на об'єкти класу object . Це дозволило б зберігати в стеці дані будь-якого типу.

Незважаючи на те, що універсальний характер класу object може бути досить ефективно використаний у деяких ситуаціях, було б помилкою думати, що за допомогою цього класу варто намагатися обійти строго дотримуваний в C# контроль типів. Загалом кажучи, ціле значення слід зберігати в змінній типу int , рядок — в змінній посилального типу string і т.д. І найголовніше, що починаючи з версії 2.0 для програмування на C# стали до ступними справжньо узагальнені типи даних — узагальнення (докладніше вони розглядаються в розділі 18). Впровадження узагальнень дозволило без зусиль визначати класи та алгоритми, автоматично обробляючи дані різних типів, дотримуючись типової безпеки. Завдяки узагальненням відпала необхідність користуватися класом object як універсальним типом даних при створенні нового коду. Універсальний характер цього класу краще залишити для застосування в особливих випадках.


---

[◀️ До змісту](../README.md)
