# Делегати події та лямбда-вирази

[◀️ До змісту лекцій](README.md)

---

У цьому розділі розглядаються три нові засоби C#: делегати, події і лямбда-вирази. Делегат надає можливість інкапсулювати метод, а подія повідомляє про те, що сталося яке-небудь дія.. Делегати і події тісно пов'язані один з одним, оскільки подія базується на делегаті. Обидва засоби розширюють коло прикладних завдань , що вирішуються при програмуванні на С#. А лямбда-вираз представляє собою новий синтаксичний засіб, що забезпечує спрощений, але в той же час ефективний спосіб визначення того, що по суті є одиницею виконуваного коду. Лямбда-вирази зазвичай використовуються для роботи з делегатами і подіями, оскільки делегат може посилатися на лямбда-вираз. У цьому розділі також розглядаються анонімні методи, коваріантність, контраваріантність і групові перетворення методів.

15.1 Делегати

Почнемо з визначення поняття делегата. Просто кажучи, делегат представляє собою об'єкт, який може посилатися на метод. Отже, коли створюється делегат, то в результаті отримується об'єкт, що містить посилання на метод. Більше того, метод можна викликати за цим посиланням. Іншими словами, делегат дозволяє викликати метод, на який він посилається. Нижче буде показано, наскільки ефективним виявляється такий принцип.

Слід особливо підкреслити, що один і той самий делегат може бути використаний для виклику різних методів під час виконання програми, для чого достатньо змінити метод, на який посилається делегат. Отже, метод, який викликається делегатом, визначається під час виконання, а не в процесі компіляції. У цьому, саме, і полягає головна перевага делегата.

Тип делегата оголошується за допомогою ключового слова delegate. Нижче наведена загальна форма оголошення делегата: делегат повертаємий_тип ім'я(список_параметрів); де повертаємий_тип означає тип значення, яке повертають методи, які будуть викликатися делегатом; ім'я — конкретне ім'я делегата; список_параметрів — параметри, необхідні для методів, які викликаються делегатом. Як тільки буде створено екземпляр делегата, він може викликати і посилатися на ті методи, повертаємий тип і параметри яких відповідають зазначеним у оголошенні делегата. Найголовніше, що делегат може служити для виклику будь-якого методу з відповідною сигнатурою і повертаємим типом. Більше того, викликаний метод може бути методом екземпляра, пов'язаним з окремим об'єктом, або ж статичним методом, пов 'язаним з конкретним класом. Значення має лише одне: повертаємий тип і сигнатура методу повинні бути узгоджені з тими, які зазначені в оголошенні делегата.

Лістинг 15.1 - Простий приклад застосування делегата

```csharp
using System;
```

// Оголосити тип делегата.

delegate string StrMod(string str);

```csharp
class DelegateTest
```

// Замінити пробіли дефісами.

static string ReplaceSpaces(string s)

```csharp
Console.WriteLine("Заміна пробілів дефісами.");
```

return s.Replace(' ', '');

// Видалити пробіли.

static string RemoveSpaces(string s)

string temp = "";

int i;

```csharp
Console.WriteLine("Видалення пробілів.");
```

for (i = 0; i < s.Length; i++)

if (s[i] != ' ') temp += s[i];

return temp;

// Обернути рядок.

static string Reverse(string s)

string temp = "";

int i, j;

```csharp
Console.WriteLine("Обертання рядка.");
```

for (j = 0, i = s.Length-1; i >= 0; i--, j++)

temp += s[i];

return temp;

```csharp
static void Main()
```

// Створити делегат.

StrMod strOp = new StrMod(ReplaceSpaces);

string str;

// Викликати методи за допомогою делегата.

str = strOp("Це простий тест.");

```csharp
Console.WriteLine("Результуючий рядок: " + str);
Console.WriteLine();
```

strOp = new StrMod(RemoveSpaces);

str = strOp("Це простий тест.");

```csharp
Console.WriteLine("Результуючий рядок: " + str);
Console.WriteLine();
```

strOp = new StrMod(Reverse);

str = strOp("Це простий тест.");

```csharp
Console.WriteLine("Результуючий рядок: " + str);
```

Розглянемо данний приклад більш детально. У його коді спочатку оголошується делегат StrMod типу string , як показано нижче. delegate string StrMod(string str); Як бачите, делегат StrMod приймає один параметр типу string і повертає одне значення того ж типу.

Далі в класі DelegateTest оголошуються три статичні методи з одним параметром типу string і повертають значення того ж типу. Отже, вони відповідають делегату StrMod . Ці методи змінюють рядок у різних формах. Зверніть увагу, що в методі ReplaceSpaces() для заміни пробілів дефісами використовується один з методів типу string — Replace() . У методі Main()створюється змінна екземпляра strOp посиланням на тип StrMod і потім їй присвоюється посилання на методReplaceSpaces(). Зверніть особливу увагу на наступний рядок коду.

StrMod strOp = new StrMod(ReplaceSpaces);

У цьому рядку метод ReplaceSpaces() передається як параметр. При цьому вказується лише його ім'я, а не параметри. Цей приклад можна узагальнити: при отриманні екземпляра делегата достатньо вказати лише ім'я методу, на який повинен посилатися делегат. Зрозуміло, що сигнатура методу повинна збігатися з тією, що вказана в оголошенні делегата. У протилежному випадку під час компіляції виникне помилка. Потім методReplaceSpaces()викликається за допомогою екземпляра делегата strOp, як показано нижче

str = strOp("Це простий тест.");

Екземпляр делегата strOp посилається на метод ReplaceSpaces() , тому викликається саме цей метод. Потім екземпляру делегата strOpприсвоюється посилання на методRemoveSpaces(), і з його допомогою знову викликається вказаний метод - на цей разRemoveSpaces(). Нарешті, екземпляру делегата strOp присвоюється посилання на метод Reverse(). І в результаті викликається саме цей метод. Основний висновок з цього прикладу полягає в наступному: в той момент, коли звертається до екземпляру делегата strOp, викликається метод, на який він посилається. Отже, виклик методу вирішується під час виконання, а не в процесі компіляції.

15.2 Групове перетворення делегованих методів

Ще в версії C# 2.0 було впроваджено спеціальний засіб, значно спрощую чий синтаксис присвоєння методу делегату. Це так зване групове перетворення методів , що дозволяє присвоїти ім'я методу делегату, не вдаючись до оператора new або явного виклику конструктора делегата. Нижче наведений метод Main() з попереднього прикладу, змінений з метою продемонструвати групове перетворення методів.

Лістинг 15.2 - групове перетворення методів.

```csharp
static void Main()
```

// Сконструювати делегат, використовуючи групове перетворення методів.

StrMod strOp = ReplaceSpaces; // використовувати групове перетворення методів

string str;

// Викликати методи за допомогою делегата,

str = strOp("Це простий тест.");

```csharp
Console.WriteLine("Результуючий рядок: " + str);
Console.WriteLine();
```

strOp = RemoveSpaces; // використовувати групове перетворення методів

str = strOp("Це простий тест.");

```csharp
Console.WriteLine("Результуючий рядок: " + str);
Console.WriteLine();
```

strOp = Reverse; // використовувати групове перетворення методів

str = strOp("Це простий тест.");

```csharp
Console.WriteLine("Результуючий рядок: " + str);
Console.WriteLine();
```

Зверніть особливу увагу на те, як створюється екземпляр делегата strOp і як йому присвоюється методReplaceSpaces у наступному рядку коду. strOp = RemoveSpaces; // використовувати групове перетворення методів У цьому коді ім'я методу присвоюється безпосередньо екземпляру делегата strOp , а всі операції з автоматичним перетворенням методу в тип делегата "покладаються" на засоби C#. Цей синтаксис може бути застосований до будь-якої ситуації, в якій метод присвоюється або перетворюється в тип делегата. Синтаксис групового перетворення методів суттєво спрощений у порівнянні з попереднім підходом до делегування, тому в решті книги використовується саме він.

У попередніх прикладах було наочно продемонстровано внутрішній механізм дії делегатів, але ці приклади не показують їх справжнє призначення. Як правило, делегати використовуються з двох причин. По-перше, як зазначалося раніше у цьому розділі, делегати підтримують події. І по-друге, делегати дозволяють ви кликати методи під час виконання програми, не знаючи про них нічого конкретно го під час компіляції. Це дуже зручно для створення базової конструкції, що допу скає підключення окремих програмних компонентів. Розглянемо як приклад графічну програму, аналогічну стандартній сервісній програмі Windows Paint. За допомогою делегата можна надати користувачу можливість підключати спеціальні кольорові фільтри або аналізатори зображень. Крім того, користувач може складати з цих фільтрів або аналізаторів цілі по слідовності. Подібні можливості програми нескладно забезпечити, використовуючи делегати.

15.3 Анонімні функції

Метод, на який посилається делегат, часто використовується лише для цієї цілі. Іншими словами, єдиним підставою для існування методу є те об ставина, що його можна викликати за допомогою делегата, але сам він не викликається взагалі. У таких випадках можна скористатися анонімною функцією, щоб не створювати окремий метод. Анонімна функція, по суті, представляє собою безіменний кодовий блок, переданий конструктору делегата. Перевага ано німної функції полягає, зокрема, в її простоті. Завдяки їй відпадає необхідність оголошувати окремий метод, єдина мета якого полягає в тому, що він передається делегату.

Починаючи з версії 3.0, в C# передбачені два види анонімних функцій: анонімні методи та лямбда-вирази. Анонімні методи були впроваджені в C# ще в версії 2.0, а лямбда-вирази - в версії 3.0. В цілому лямбда-вираз поліпшує принцип дії анонімного методу і наразі вважається більш переваги для створення анонімної функції. Але анонімні методи широко застосовуються в існуючому коді C# і тому залишаються важливою складовою частиною C#. А оскільки анонімні методи передували по появі лямбда-виразів, то чітке уявлення про них дозволяє краще зрозуміти особливості лямбда-виразів. Крім того, анонімні методи можуть бути використані в цілому ряді випадків, де застосування лямбда-виразів виявляється неможливим. Саме тому в цій главі розглядаються і анонімні методи, і лямбда- вирази.

Анонімний метод - один з способів створення безіменного блоку коду, пов'язаного з конкретним екземпляром делегата. Для створення анонімного методу достатньо вказати кодовий блок після ключового слова delegate . Покажемо, як це робиться, на конкретному прикладі. У наведеній нижче програмі анонімний метод служить для підрахунку від 0 до 5.

Лістинг 15.3 - Застосування анонімного методу

// Оголосити тип делегата.

delegate void CountIt();

```csharp
class AnonMethDemo
static void Main()
```

// Далі слідує код для підрахунку чисел, передаваний делегату

// в якості анонімного методу.

CountIt count = delegate

// Цей кодовий блок передається делегату.

for (int i = 0; i <= 5; i++)

```csharp
Console.WriteLine(i);
}; // зверніть увагу на крапку з комою
```

count();

Анонімному методу можна передати один або кілька аргументів. Для цього достатньо вказати в дужках список параметрів після ключового слова delegate , а при зверненні до екземпляру делегата — передати йому відповідні аргументи. В якості прикладу нижче наведено варіант попередньої програми, змінений з метою передати в якості аргумента кінцеве значення для підрахунку.

Лістинг 15.04 - Застосування анонімного методу, що приймає аргумент.

delegate void CountIt(int end);

```csharp
class AnonMethDemo2
static void Main()
```

// Тут кінцеве значення для підрахунку передається анонімному методу.

CountIt count = delegate (int end)

for (int i = 0; i <= end; i++)

```csharp
Console.WriteLine(i);
```

count(3);

```csharp
Console.WriteLine();
```

count(5);

У цій версії програми делегат CountIt приймає цілочисельний аргумент. Зверніть увагу на те, що при створенні анонімного методу список параметрів вказується після ключового слова delegate. Параметр end становиться доступним для коду в анонімному методі так само, як і при створенні іменованого методу. Нижче наведено результат виконання даної програми.

Анонімний метод може повертати значення. Для цього служить оператор return , що діє в анонімному методі так само, як і в іменованому методі. Як і очікувалося, тип поверненого значення повинен бути сумісним з типом, вказуваним в оголошенні делегата. В якості при кладу нижче наведено код, що виконує підрахунок з сумуванням і повертає результат.

Лістинг 15.05 - Використання анонімного методу, що повертає значення

delegate int CountIt(int end);

```csharp
class AnonMethDemo3
static void Main()
```

int result;

// Тут кінцеве значення для підрахунку передається анонімному методу.

// А повертається сума підрахованих чисел.

CountIt count = delegate (int end)

int sum = 0;

for (int i = 0; i <= end; i++)

```csharp
Console.WriteLine(i);
```

sum += i;

return sum; // повернути значення з анонімного методу

result = count(3);

```csharp
Console.WriteLine("Сума 3 дорівнює " + result);
Console.WriteLine();
```

result = count(5);

```csharp
Console.WriteLine("Сума 5 дорівнює " + result);
```

У цьому варіанті коду сумарне значення повертається кодовим блоком, пов'язаним з екземпляром делегата count . Зверніть увагу на те, що оператор return застосовується в анонімному методі так само, як і в іменованому методі. Нижче наведено результат виконання даного коду.

Локальна змінна, в область дії якої входить анонімний метод, називається зовнішньою змінною. Такі змінні доступні для використання в ано німному методі.. І в цьому випадку зовнішня змінна вважається захопленою. Захоплена змінна існує до тих пір, поки захоплюючий її делегат не буде зібраний в " сміття " . Тому якщо локальна змінна, яка зазвичай припиняє своє існування після виходу з кодового блоку, використовується в анонімному методі, то вона продовжує існувати до тих пір, поки не буде знищений делегат, що посилається на цей метод. Захоплення локальної змінної може призвести до неочікуваних результатів. Як приклад розглянемо ще один варіант програми підрахунку з сумуванням чисел. У цьому варіанті об'єкт CountIt конструюється і повертається статичним методом Counter() . Цей об'єкт використовує змінну sum , оголошену в охоплюючій області дії методу Counter() , а не самого анонімного методу. Тому змінна sum захоплюється анонімним методом. Метод Counter() викликається в методі Main() для отримання об'єкта CountIt , а отже, змінна sum не знищується до самого кінця програми.

Лістинг 15.06 - Використання захопленої змінної

delegate int CountIt(int end);

```csharp
class VarCapture
```

static CountIt Counter()

int sum = 0;

// Тут підрахована сума зберігається в змінній sum.

CountIt ctObj = delegate (int end)

for (int i = 0; i <= end; i++)

```csharp
Console.WriteLine(i);
```

sum += i;

return sum;

return ctObj;

```csharp
static void Main()
```

// Отримати результат підрахунку.

CountIt count = Counter();

int result;

result = count(3);

```csharp
Console.WriteLine("Сума 3 дорівнює " + result);
Console.WriteLine();
```

result = count(5);

```csharp
Console.WriteLine("Сума 5 дорівнює " + result);
```

Сума 5 дорівнює 21 Як бачите, підрахунок все ще виконується як зазвичай. Але зверніть увагу на те, що сума 5 тепер дорівнює 21, а не 15! Справа в тому, що змінна sum захоплюється об'єктом ctObj при його створенні в методі Counter() . Це означає, що вона продовжує існувати до знищення делегата count при " зборці сміття " в самому кінці програми. Отже, її значення не знищується після повернення з методу Counter() або при кожному виклику анонімного методу, коли звертаються до делегата count в методі Main() . Незважаючи на те, що застосування захоплених змінних може призвести до досить неочікуваних результатів, як у наведеному вище прикладі, воно все ж логічно обґрунтовано. Адже коли анонімний метод захоплює змінну, вона продовжує існувати до тих пір, поки використовується захоплюючий її делегат. В іншому випадку захоплена змінна була б невизначеною, коли вона могла б знадобитися делегату.

15.4 Лямбда-вирази

Незважаючи на всю цінність анонімних методів, на зміну їм прийшов більш су верений підхід: лямбда-вираз. Не буде перебільшенням сказати, що лямбдавираз відноситься до одних з найважливіших нововведень в С#, починаючи з випуску початкової версії 1.0 цієї мови програмування. Лямбда-вираз базується на зовсім новому синтаксичному елементі і служить більш ефективною альтер нативою анонімному методу. І хоча лямбда-вирази знаходять застосування головним чином у роботі з LINQ (детальніше про це - у главі 19), вони часто використовуються і разом з делегатами і подіями. Саме про це застосування лямбда-виразів і піде мова в даному розділі.

Лямбда-вираз - це інший спосіб створення анонімної функції. (Перший її спосіб, анонімний метод, був розглянутий у попередньому розділі.) Отже, лямбда-вираз може бути призначений делегату. А оскільки лямбда-вираз вважається більш ефективним, ніж еквівалентний йому анонімний метод, то в більшості випадків рекомендується віддавати перевагу саме йому.

У всіх лямбда-виразах застосовується новий лямбда-оператор => , який розділяє лямбда-вираз на дві частини. У лівій його частині вказується вхідний параметр (або кілька параметрів), а в правій частині - тіло лямбда-виразу. Опера тор => іноді описується такими словами, як " переходить " або " становиться ". У C# підтримуються два види лямбда-виразів в залежності від тіла самого лямбда-виразу. Так, якщо тіло лямбда-виразу складається з одного ви разу, то утворюється одиночний лямбда-вираз. У цьому випадку тіло виразу не заключається у фігурні дужки. Якщо ж тіло лямбда-виразу складається з блоку операторів, заключених у фігурні дужки, то утворюєтьсяблочний лямбда-вираз. При цьому блочний лямбда-вираз може містити цілий ряд операторів, включаючи цикли, виклики методів та умовні оператори if. Обидві різновидності лямбда- виразів розглядаються далі окремо.

У одиночному лямбда-виразі частина, що знаходиться справа від оператора => впливає на параметр (або ряд параметрів), вказаний зліва. Поверненим результатом обчислення такого виразу є результат виконання лямбда- оператора. Нижче наведена загальна форма одиночного лямбда-виразу, що приймає єдиний параметр.

параметр => вираз

Якщо же потрібно вказати кілька параметрів, то використовується наступна форма. (список_параметрів) => вираз Отже, коли потрібно вказати два або більше параметри, їх слід заключити в дужки . Якщо вираз не потребує параметрів, то слід використовувати порожні дужки. Нижче наведено простий приклад одиночного лямбда-виразу.

сount => count + 2

У цьому виразі count виступає параметром, на який впливає вираз count + 2 . В результаті значення параметра count збільшується на 2. Ось ще один приклад одиночного лямбда-виразу.

n => n % 2 == 0

У цьому випадку вираз повертає логічне значення true, якщо числове значення параметра n виявляється парним, а інакше - логічне значення false. Лямбда-вираз застосовується в два етапи. Спочатку оголошується тип делегата, який сумісний з лямбда-виразом, а потім екземпляр делегата, якому присвоюється лямбда-вираз. Після цього лямбда-вираз обчислюється при зверненні до екземпляру делегата. Результатом його обчислення стає повернене значення.

У наведеному нижче прикладі програми демонструється застосування двох оди ночних лямбда-виразів. Спочатку в цій програмі оголошуються два типи делега тів. Перший з них, Incr, приймає аргумент типу int і повертає результат того ж типу. Другий делегат, IsEven, також приймає аргумент типу int, але повертає результат типу bool. Потім екземплярам цих делегатів присвоюються одиночні лямбда-вирази. І нарешті, лямбда-вирази обчислюються за допомогою відповід них екземплярів делегатів.

Лістинг 15.7 - Застосувати два окремі лямбда вирази

delegate int Incr(int v);

delegate bool IsEven(int v);

```csharp
class SimpleLambdaDemo
static void Main()
```

// Створити делегат Incr, який посилається на лямбдавираз.

// збільшуючи свій параметр на 2.

Incr incr = count => count + 2;

// Тепер використовуємо лямбдавираз incr.

```csharp
Console.WriteLine("Використання лямбда-виразу incr: ");
```

int x = -10;

while (x <= 0)

```csharp
Console.Write(x + " ");
```

x = incr(x); // збільшити значення x на 2

```csharp
Console.WriteLine("\n");
```

// Створити екземпляр делегата IsEven, який посилається на лямбдавираз,

// що повертає логічне значення true, якщо його параметр є парним

// значенням, інакше - логічне значення false.

IsEven isEven = n => n % 2 == 0;

// А тепер використовуємо лямбдавираз isEven.

```csharp
Console.WriteLine("Використання лямбда-виразу isEven: ");
```

for (int i = 1; i <= 10; i++)

```csharp
if (isEven(i)) Console.WriteLine(i + " парне.");
```

У першому рядку оголошення екземпляру делегата incr присвоюється одиночне лямбда-вираз, що повертає результат збільшення на 2 значення параметра count . Цей вираз може бути присвоєний делегату Incr , оскільки він сумісний з оголошенням даного делегата. Аргумент, що вказується при зверненні до екзем пляру делегата incr , передається параметру count , який і повертає результат обчислення лямбда-виразу. У другому рядку оголошення делегату isEven при своюється вираз , що повертає логічне значення true , якщо переданий йому аргумент виявляється парним, а інакше — логічне значення false . Отже, цей лямбда-вираз сумісний з оголошенням делегата IsEven . У зв'язку з усім викладеним вище виникає розумне питання: яким чином компілятору стає відомо про типи даних, використовуваних у лямбда-виразі, наприклад, про тип int параметра count у лямбда-виразі, який призначається екземпляру делегата incr ? На це питання можна відповісти так: компіля тор робить висновок про тип параметра і тип результату обчислення виразу за типом делегата. Отже, параметри та повертаєме значення лямбда- виразу повинні бути сумісні за типом з параметрами та повертаємим зна ченням делегата.

Незважаючи на всю корисність логічного висновку про тип даних, у деяких випадках доводиться явно вказувати тип параметра лямбда-виразу. Для цього до достатньо ввести конкретну назву типу даних. В якості прикладу нижче наведений інший спосіб оголошення екземпляра делегата incr.

Incr incr = (int count) => count + 2;

Як бачите, count тепер явно оголошений як параметр типу int . Зверніть також увагу на використання дужок. Тепер вони необхідні. (Дужки можуть бути опу щені лише у випадку, якщо задається лише один параметр, а його тип явно не вказується .) У попередньому прикладі в обох лямбда-виразах використовувався єдиний параметр, але взагалі лямбда-вирази можуть мати будь-яку кількість параметрів, включаючи нульову. Якщо в лямбда-виразі використовується кілька параметрів, їх необхідно заключити в дужки. Нижче наведено приклад використання лямбдавиразу з метою визначити, чи знаходиться значення в заданих межах

(low, high, val) => val >= low && val <= high;

Ось як оголошується тип делегата, сумісного з цим лямбда-виразом.

delegate bool InRange(int lower, int upper, int v);

Отже, екземпляр делегата InRange може бути створений наступним чи ном образом.

InRange rangeOK = (low, high, val) => val >= low && val <= high;

Після цього одиночне лямбда-вираз може бути виконано так, як показано нижче

if(rangeOK(1, 5, 3))

І останнє зауваження: зовнішні змінні можуть використовуватися і захоплювати ся в лямбда-виразах так само, як і в анонімних методах.

Як зазначалося вище, існують два види лямбда-виразів. Перша з них, одиночне лямбда-вираз, була розглянута в попередньому розділі. Тіло такого лямбда-виразу складається лише з одного виразу. Другим видом є блочний лямбда-вираз. Для такого лямбда-виразу характерні розширені можливості виконання різних операцій, оскільки в його тілі допускається вказувати кілька операторів.. Наприклад, в блочному лямбда-виразі можна використовувати цикли і умовні оператори if , оголошувати змінні і т.д. Створити блочний лямбда-вираз нескладно. Для цього достатньо заключити тіло виразу в фігурні дужки. Крім можливості використовувати кілька опера торів, в іншому блочний лямбда-вираз, практично нічим не відрізняється від тільки що розглянутого одиночного лямбда-виразу.

15.5 Події

Ще одним важливим засобом C#, що базується на делегатах, є подія. Подія, по суті, представляє собою автоматичне повідомлення про те, що сталася певна дія.. Події діють за таким принципом: об'єкт, який проявляє інтерес до події, реєструє обробник цієї події. Коли подія відбувається, всі зареєстровані обробники цієї події викликаються. Обробники подій зазвичай представлені делегатами. Події є членами класу і оголошуються за допомогою ключового слова event. Найчастіше для цієї цілі використовується наступна форма:

event делегат_події ім'я_події;

де делегат_події означає ім'я делегата, що використовується для підтримки події, а ім 'я_події — конкретний об'єкт оголошеної події.

Лістинг 15.8 - Приклад використання подій

// Оголосити тип делегата для події.

delegate void MyEventHandler();

// Оголосити клас, що містить подію.

```csharp
class MyEvent
```

public event MyEventHandler SomeEvent;

// Цей метод викликається для запуску події.

public void OnSomeEvent()

if (SomeEvent != null)

SomeEvent();

```csharp
class EventDemo
```

// Обробник події.

```csharp
static void Handler()
Console.WriteLine("Сталася подія");
static void Main()
```

MyEvent evt = new MyEvent();

// Додати метод Handler() до списку подій.

evt.SomeEvent += Handler;

// Запустити подію.

evt.OnSomeEvent();

Як і делегати, події підтримують групову адресацію. Це дає можливість декільком об'єктам реагувати на сповіщення про подію. Нижче наведений приклад групової адресації події.

Лістинг 15.9 - Приклад агрегованих подій

delegate void MyEventHandler();

// Оголосити делегат, що містить подію.

```csharp
class MyEvent
```

public event MyEventHandler SomeEvent;

// Цей метод викликається для запуску події.

public void OnSomeEvent()

if (SomeEvent != null)

SomeEvent();

```csharp
class X
```

public void Xhandler()

```csharp
Console.WriteLine("Подію отримано об'єктом класу X");
class Y
```

public void Yhandler()

```csharp
Console.WriteLine("Подію отримано об'єктом класу Y");
class EventDemo2
static void Handler()
Console.WriteLine("Подію отримано об'єктом класу EventDemo");
static void Main()
```

MyEvent evt = new MyEvent();

X xOb = new X();

Y yOb = new Y();

// Додати обробники до списку подій.

evt.SomeEvent += Handler;

evt.SomeEvent += xOb.Xhandler;

evt.SomeEvent += yOb.Yhandler;

// Запустити подію.

evt.OnSomeEvent();

```csharp
Console.WriteLine();
```

// Видалити обробник.

evt.SomeEvent -= xOb.Xhandler;

evt.OnSomeEvent();

У даному прикладі створюються два додаткових класи, Xі Y, в яких також визначаються обробники подій , сумісні з делегатом MyEventHandler. Тому ці обробники також можуть бути включені в ланцюжок подій. Зверніть увагу на те, що обробники в класах Xі Y не є статичними. Це озна чає, що спочатку повинні бути створені об'єкти кожного з цих класів, а потім в ланцюжок подій повинні бути введені обробники, пов'язані з їх екземплярами. Про відмінності між обробниками екземпляра та статичними обробниками мова піде в наступному розділі.


---

[◀️ До змісту](../README.md)
