# Керуючі оператори

[◀️ До змісту лекцій](README.md)

---

4.1 Оператор if

Повна форма цього оператора if:

if( умова) оператор;

else оператор;

де умова – це деякий умовний вираз, а оператор – адресат операторів if і else . Оператор else не є обов'язковим. Адресатом обох операторів, if і else , можуть також служити блоки операторів. Нижче наведена загальна форма оператора if , в якому використовуються блоки операторів.

if (умова)

послідовність операторів

else

послідовність операторів

Якщо умовний вираз є істинним, то виконується адресат оператора if. У протилежному випадку виконується адресат оператора else, якщо такий існує. Але одночасно не може виконуватися і те, і інше. Умовний вираз, який керує оператором if, повинен мати результат типу bool.

Нижче наведено приклад простої програми, в якій оператори if і else використовуються для того, щоб повідомити, чи є число позитивним або від'ємним (лістинг 4.1).

Лістинг 4.1 – Приклад використання if та else

// Визначити, чи є числове значення позитивним або від'ємним.

```csharp
using System;
class PosNeg
static void Main()
```

int i;

for (i = -5; i <= 5; i++)

```csharp
Console.Write("Перевірка " + i + ": ");
if (i < 0) Console.WriteLine("від'ємне число");
else Console.WriteLine("позитивне число");
```

Результат виконання цієї програми виглядає наступним чином.

Перевірка -5: від'ємне число

Перевірка -4: від'ємне число

Перевірка -3: від'ємне число

Перевірка -2: від'ємне число

Перевірка -1: від'ємне число

Перевірка 0: позитивне число

Перевірка 1: позитивне число

Перевірка 2: позитивне число

Перевірка 3: позитивне число

Перевірка 4: позитивне число

Перевірка 5: позитивне число

Якщо у даному прикладі значення змінної i виявляється менше нуля, то виконується адресат оператора if. У протилежному випадку виконується адресат оператора else, одночасно вони не виконуються.

4.1.1 Вкладені оператори if

Вкладеним називається такий оператор if, який є адресатом іншого оператора if або оператора else. Вкладені оператори if дуже часто використовуються в програмуванні. Що ж стосується їх застосування в С#, то не слід забувати, що будь-який оператор else завжди пов'язаний з найближчим оператором if, тобто з тим оператором if, який знаходиться в тому ж самому блоку, де й оператор else, але не з іншим оператором else. Розглянемо наступний приклад (лістинг 4.2).

Лістинг 4.2 – Приклад вкладеного if

```csharp
if (i == 10) {
```

if(j < 20) a = b;

if(k > 100) с = d;

else a = с; // цей оператор else пов'язаний з оператором if(k > 100)

else a = d; // цей оператор else пов'язаний з оператором if(i == 10)

Як випливає з коментарів до наведеного вище фрагменту коду, останній оператор else не пов'язаний з оператором if(j < 20), оскільки вони не знаходяться в одному й тому ж блоку, незважаючи на те, що цей оператор є для нього найближчим оператором if без допоміжного оператора else. Навпаки, останній оператор elseпов'язаний з оператором if(i == 10). А внутрішній оператор else пов'язаний з оператором if(k > 100), оскільки цей останній є для нього найближчим оператором if у тому ж самому блоку.

У наведеному нижче прикладі програми демонструється застосування вкладеного оператора if. У раніше наведеній програмі визначення позитивних і від'ємних чисел про нуль повідомлялося як про позитивне число. Але, як правило, нуль вважається числом, що не має знаку. Тому в наступній версії цієї програми про нуль повідомляється як про число, яке не є ані позитивним, ані від'ємним (лістинг 4.3).

Лістинг 4.3 – Визначення, чи є число позитивне, від’ємне або нульовим

// Визначити, чи є числове значення

// позитивним, від'ємним або нульовим.

```csharp
using System;
class PosNegZero
static void Main()
```

int i;

for (i = -5; i <= 5; i++)

```csharp
Console.Write("Перевірка " + i + ": ");
if (i < 0) Console.WriteLine("від'ємне число");
else if (i == 0) Console.WriteLine("число без знаку");
else Console.WriteLine("позитивне число");
```

Нижче наведено результат виконання цієї програми.

Перевірка -5: від'ємне число

Перевірка -4: від'ємне число

Перевірка -3: від'ємне число

Перевірка -2: від'ємне число

Перевірка -1: від'ємне число

Перевірка 0: число без знаку

Перевірка 1: позитивне число

Перевірка 2: позитивне число

Перевірка 3: позитивне число

Перевірка 4: позитивне число

Перевірка 5: позитивне число

4.1.2 Конструкція if-else-if

У програмуванні часто застосовується багатоступінчаста конструкція if-else-if, що складається з вкладених операторів if. Нижче наведена її загальна форма.

if(умова)

оператор;

else if (умова)

оператор;

else if (умова)

оператор;

else

оператор;

Умовні вирази в такій конструкції обчислюються зверху вниз. Як тільки виявиться істинна умова, виконується пов'язаний з нею оператор, а всі інші оператори в багатоступінчастій конструкції опускаються.

Якщо жодна з умов не є істинною, то виконується останній оператор else, який зазвичай служить як умова, встановлена за замовчуванням. Коли останній оператор else відсутній, а всі інші перевірки за умовою дають хибний результат, то жодних дій взагалі не виконується.

У наведеному нижче прикладі програми демонструється застосування багаторівневої конструкції if-else-if. У цій програмі виявляється найменший множник заданого цілого значення, що складається з однієї цифри (лістинг 4.4).

Лістинг 4.4 – Визначення найменшого множника заданого цілого значення

// Визначити найменший множник заданого

// цілого значення, що складається з однієї цифри.

```csharp
using System;
class Ladder
static void Main()
```

int num;

for (num = 2; num < 12; num++)

if ((num % 2) == 0)

```csharp
Console.WriteLine("Найменший множник числа " + num + " дорівнює 2.");
```

else if ((num % 3) == 0)

```csharp
Console.WriteLine("Найменший множник числа " + num + " дорівнює 3.");
```

else if ((num % 5) == 0)

```csharp
Console.WriteLine("Найменший множник числа " + num + " дорівнює 5.");
```

else if ((num % 7) == 0)

```csharp
Console.WriteLine("Найменший множник числа " + num + " дорівнює 7.");
```

else

```csharp
Console.WriteLine(num + " не ділиться на 2, 3, 5, або 7.");
```

Ось до якого результату призводить виконання цієї програми.

Найменший множник числа 2 дорівнює 2

Найменший множник числа 3 дорівнює 3

Найменший множник числа дорівнює 2

Найменший множник числа дорівнює 5

Найменший множник числа дорівнює 2

Найменший множник числа дорівнює 7

Найменший множник числа дорівнює 2

Найменший множник числа дорівнює 3

Найменший множник числа дорівнює 2 11 не ділиться на 2, 3, 5 або 7.

Як бачите, останній оператор else виконується лише у випадку, якщо не вдається виконати жоден з попередніх операторів

4.2 Оператор switch

Другим оператором вибору в C# є оператор switch, який забезпечує багатоспрямоване розгалуження програми. Отже, цей оператор дозволяє зробити вибір серед кількох альтернативних варіантів подальшого виконання програми. Незважаючи на те, що багатоспрямована перевірка може бути організована за допомогою послідовного ряду вкладених операторів if , у багатьох випадках більш ефективним виявляється застосування оператора switch. Цей оператор діє наступним чином. Значення виразу послідовно порівнюється з константами вибору з заданого списку. Як тільки буде виявлено співпадіння з одним з умов вибору, виконується послідовність операторів, пов'язаних з цією умовою. Нижче наведена загальна форма оператора switch.

```csharp
switch(вираз) {
```

case константа1:

послідовність операторів

break;

case константа2:

послідовність операторів

break;

case константа3:

послідовність операторів

break;

default:

послідовність операторів

break;

Заданий вираз в операторі switch повинен бути цілочисельного типу ( char, byte, short або int), перерахованого або рядкового. А вирази інших типів, наприклад з плаваючою точкою, в операторі switch не допускаються. Часто вираз, що керує оператором switch, просто зводиться до однієї змінної. Крім того, константи вибору повинні мати тип, сумісний з типом виразу. У одному операторі switch не допускається наявність двох однакових за значенням констант вибору.

Послідовність операторів з гілки default виконується у випадку, якщо жодна з констант вибору не збігається з заданим виразом. Гілка default не є обов'язковою. Якщо вона відсутня і вираз не збігається з жодним з умов вибору, то жодних дій взагалі не виконується. Якщо ж відбувається збіг з однією з умов вибору, то виконуються оператори, пов'язані з цією умовою, аж до оператора break.

Нижче наведений приклад програми, в якому демонструється застосування оператора switch (лістинг 4.5).

Лістинг 4.5 – Застосування switch

// Показати застосування оператора switch.

```csharp
using System;
class SwitchDemo
static void Main()
```

int i;

for (i = 0; i < 10; i++)

switch (i)

case 0:

```csharp
Console.WriteLine("i дорівнює нулю");
```

break;

case 1:

```csharp
Console.WriteLine("i дорівнює одиниці");
```

break;

case 2:

```csharp
Console.WriteLine("i дорівнює двом");
```

break;

case 3:

```csharp
Console.WriteLine("i дорівнює трьом");
```

break;

case 4:

```csharp
Console.WriteLine("i дорівнює чотирьом");
```

break;

default:

```csharp
Console.WriteLine("i дорівнює або більше п'яти");
```

break;

Результат виконання цієї програми виглядає наступним чином.

i дорівнює нулю.

i дорівнює одиниці.

i дорівнює двом.

i дорівнює трьом.

i дорівнює чотирьом.

i дорівнює або більше п'яти.

i дорівнює або більше п'яти.

i дорівнює або більше п'яти.

i дорівнює або більше п'яти.

i дорівнює або більше п'яти.

Як бачите, на кожному кроці циклу виконуються оператори, пов'язані зі співпадаючою константою вибору, обходячи всі інші оператори. Коли значення змінної i становиться рівним або більшим п'яти, то воно не співпадає з жодною з констант вибору, і, отже, виконуються оператори з гілки default.

У вищезазначеному прикладі оператором switch керувала змінна i типу int. Як пояснювалося раніше, для керування оператором switch може бути використано вираз будь-якого цілочисельного типу, включаючи char. Нижче наведено приклад застосування виразу і констант вибору типу char у операторі switch (лістинг 4.6).

Лістинг 4.6 – Застосування switch, використовуючи char у операторі

// Використовувати елементи типу char для

// керування оператором switch.

```csharp
using System;
class SwitchDemo2
static void Main()
```

char ch;

for (ch = 'A'; ch <= 'E'; ch++)

switch (ch)

case 'A':

```csharp
Console.WriteLine("ch містить A");
```

break;

case 'B':

```csharp
Console.WriteLine("ch містить B");
```

break;

case 'C':

```csharp
Console.WriteLine("ch містить C");
```

break;

case 'D':

```csharp
Console.WriteLine("ch містить D");
```

break;

case 'E':

```csharp
Console.WriteLine("ch містить E");
```

break;

Ось який результат дає виконання цієї програми.

ch містить А

ch містить В

ch містить С

ch містить D

ch містить Е

Зверніть увагу в даному прикладі на відсутність гілки default в операторі switch. Нагадаємо, що гілка default не є обов'язковою. Коли вона не потрібна, її можна просто пропустити. Перехід послідовності операторів, пов'язаних з однією гілкою case , в наступну гілку case вважається помилкою, оскільки в C# обов'язково дотримуватися правила недопущення "провалів" в передачі керування ходом виконання програми. Саме тому послідовність операторів в кожній гілці case оператора switch закінчується оператором break. Коли у послідовності операторів окремої гілки case зустрічається оператор break, відбувається вихід не тільки з цієї гілки, але з усього оператора switch, а виконання програми продовжується з наступного оператора, що знаходиться поза межами оператора switch. Послідовність операторів у гілці default також повинна бути позбавлена "провалів", тому вона завершується, як правило, оператором break.

Правило недопущення "провалів" стосується тих особливостей мови С#, які він відрізняється від С, C++ і Java. У цих мовах програмування одна гілка case може переходити (тобто "провалюватися") в іншу. Це правило встановлено в C# для гілок case з двох причин. По-перше, воно дає компілятору можливість вільно змінювати порядок послідовностей операторів з гілок case з метою оптимізації. Така реорганізація була б неможливою, якби одна гілка case могла переходити в іншу. І по-друге, вимога завершувати кожну гілку case явно виключає мимовільні помилки програмування, що допускають перехід однієї гілки case в іншу.

Незважаючи на те, що правило недопущення "провалів" не допускає перехід однієї гілки case в іншу, в двох або більше гілках case все ж дозволяється посилатися за допомогою міток на одну й ту саму кодову послідовність, як показано в наступному прикладі програми (лістинг 4.7).

Лістинг 4.7 – Приклад «провалу» порожніх гілок

// Приклад "провалу" порожніх гілок case.

```csharp
using System;
class EmptyCasesCanFall
static void Main()
```

int i;

for (i = 1; i < 5; i++)

switch (i)

case 1:

case 2:

case 3:

```csharp
Console.WriteLine("i дорівнює 1, 2 або 3");
```

break;

case 4:

```csharp
Console.WriteLine("i дорівнює 4");
```

break;

Нижче наведено результат виконання цієї програми.

i дорівнює 1, 2 або 3

i дорівнює 1, 2 або 3

i дорівнює 1, 2 або 3

i дорівнює 4

Якщо значення змінної i у даному прикладі дорівнює 1, 2 або 3, то виконується пер ший оператор, що містить виклик методу WriteLine(). Таке розташування кількох міток гілок case поспіль не порушує правило недопущення "провалів"; оскільки в усіх цих гілках використовується одна й та сама послідовність операторів.

Розташування кількох міток гілок case послідовно застосовується у випадку, якщо кілька гілок мають спільний код. Завдяки цьому уникнуто зайвого дублювання кодових послідовностей.

4.2.1 Вкладені оператори switch

Один оператор switch може бути частиною послідовності операторів іншого, зовнішнього оператора switch. Такий оператор switch називається вкладеним. Константи вибору внутрішнього і зовнішнього операторів switch можуть містити спільні значення, не викликаючи конфліктів. Наприклад, наступний фрагмент коду є допустимим (лістинг 4.8).

Лістинг 4.8 – Приклад вкладеного оператора switch

```csharp
switch(ch1) {
case 'A': Console.WriteLine("Ця гілка А - Частина " +
```

"зовнішнього оператора switch.");

```csharp
switch(ch2){
```

case 'A':

```csharp
Console.WriteLine("Ця гілка A - частина " +
```

"внутрішнього оператора switch");

break;

case 'В': // ...

```csharp
} // кінець внутрішнього оператора switch
```

break;

case 'В': // ...


---

[◀️ До змісту](../README.md)
