# Типи даних, поняття змінних, консольний ввід та вивід

[◀️ До змісту лекцій](README.md)

---

2.1 Змінна в мові програмування C#

Змінна – це іменований контейнер або об'єкт, який використовується для зберігання та представлення даних в пам'яті комп'ютера. Змінна має ім'я, яке ідентифікує її і дозволяє звертатися до неї під час виконання програми. Кожна змінна також має тип даних, який визначає, які дані можуть бути збережені в цій змінній і які операції можна виконувати з цими даними.

Основні характеристики змінних в C#:

Ім'я: Кожна змінна має унікальне ім'я, яке використовується для звертання до неї в коді програми. Щоб ім'я відповідало правилам ідентифікаторів мови C#, воно повинно відповідати наступним вимогам:

Ім'я повинно починатися з літери або символу підкреслення (_).

Після першого символу ім'я може містити літери, цифри та символ підкреслення.

Ім'я не може містити пробіли або інші спеціальні символи, такі як знаки пунктуації або оператори.

Ім'я повинно бути унікальним у межах свого контексту (наприклад, у межах класу чи простору імен).

Регістр літер важливий: імена розглядаються як роздільні на регістр, тобто "myVariable" і "myvariable" вважаються різними іменами.

Приклади коректних імен ідентифікаторів у мові C#:

myVariable;

counter;

_privateField;

CalculateSum.

Приклади некоректних імен ідентифікаторів у мові C#:

123variable (починається з цифри);

my Variable (містить пробіл);

for (це ключове слово мови C# і не може використовуватися як ім'я).

Зважайте на ці правила при створенні ідентифікаторів у вашому коді на мові C#.

Тип даних: Змінна має тип даних, який визначає, який вид даних може бути збережений у цій змінній, і обмежує доступні операції з цими даними. Наприклад, змінна може бути типу цілого числа (`int`), рядка (`string`), дійсного числа (`double`), тощо.

Значення: Змінна може зберігати певне значення, яке може бути зміненим під час виконання програми.

Область видимості: Змінні можуть бути оголошені з областю видимості, яка визначає, де в коді програми ця змінна може бути доступною. Зазвичай, змінні оголошуються в межах функцій, методів, класів або інших конструкцій програми.

Приклад оголошення і використання змінної в C# наведений у лістингу 2.1.

Лістинг 2.1 – Приклад оголошення та використання змінної

int age; // Оголошення змінної типу int з іменем "age".

age = 30;// Присвоєння змінній "age" значення 30.

string name = "John"; // Оголошення та ініціалізація рядкової змінної name

У цьому прикладі "age" і "name" - це змінні, одна з яких зберігає ціле число, а інша - рядок. Змінні можуть бути використані для збереження та опрацювання різних видів даних у програмах.

Якщо узагальнити то для оголошення змінної можно використовувати формулу: [Тип] [Назва]; в кінці кожної строки повинен бути символ закінчення ;

Оператор "=" в мові програмування C# використовується для присвоєння значення змінній. Основна функція цього оператора - присвоїти праву сторону виразу (значення або результат виразу) лівій стороні (змінній). Ось базовий синтаксис оператора "=":

змінна = вираз;

"змінна" - ім'я змінної, якій ми хочемо присвоїти значення.

"вираз" - значення або вираз, яке ми хочемо присвоїти змінній.

Приклади використання оператора "=" наведений у лістингу 2.2.

Лістинг 2.2 – Приклад використання оператора

int x; // Оголошення змінної "x".

x = 5; // Присвоєння змінній "x" значення 5.

string name; // Оголошення змінної "name".

name = "John"; // Присвоєння змінній "name" рядкового значення "John".

double result; // Оголошення змінної "result".

result = 10.5; // Присвоєння змінній "result" значення 10.5.

Оператор "=" може бути використаний для присвоєння значень змінним будь-якого типу даних в C#, включаючи цілі числа, рядки, числа з плаваючою точкою, логічні значення і так далі.

2.2 Типи даних

У C# є дві загальні категорії вбудованих типів даних: типи значень і посилальні типи. Вони відрізняються за вмістом змінної. Якщо змінна належить до типу значення, то вона містить саме значення, наприклад 3,1416 або 212.

Якщо змінна належить до посилального типу, то вона містить посилання на значення. Найпоширенішим прикладом використання посилального типу є клас, але про класи та посилальні типи буде розповідатися далі в цій книзі. Тут розглядаються типи значень. Основу мови C# становлять 13 типів значень. Всі вони називаються простими типами, оскільки складаються з єдиного значення (іншими словами, вони не складаються з двох або більше значень). Вони становлять основу системи типів C#, надаючи прості, низько рівневі елементи даних, з якими можна працювати в програмі. Прості типи даних іноді ще називають примітивними (таблиця 2.1).

Таблиця 2.1 – Типи даних в C#

У C# строго визначені межі та характер дії кожного типу значення.

Виходячи з вимог до переносимості програм, C# не допускає жодних компромісів у цьому відношенні. Наприклад, тип int повинен бути однаковим у всіх середовищах виконання. Але в такому випадку відпадає необхідність переписувати код для конкретної платформи. І хоча строге визначення розмірності типів значень може спричинити незначний спад продуктивності в деяких середовищах, ця мера необхідна для досягнення переносимості програм.

2.2.1 Цілочисельні типи

В C# визначені дев'ять цілочисельних типів: char, byte, sbyte, short, ushort, int, uint, long і ulong. Але тип char застосовується, головним чином, для представлення символів і тому розглядається далі в цьому розділі. Решта восьми цілочисельних типів призначені для числових розрахунків. Нижче у таблиці 2.2 представлені їх діапазон представлення чисел і розрядність в бітах.

Таблиця 2.2 – Розрядність та діапазон представлення чисел

Як випливає з таблиці вище, в C# визначені обидва варіанти різних цілих типів: зі знаком і без знаку. Цілі типи зі знаком відрізняються від аналогічних типів без знаку способом інтерпретації старшого розряду цілого числа. Так, якщо в програмі вказане ціле значення зі знаком, то компілятор C# згенерує код, в якому старший розряд цілого числа використовується як прапорець знаку. Число вважається позитивним, якщо прапорець знаку дорівнює 0, і від'ємним, якщо він дорівнює 1. Від'ємні числа практично завжди представляються методом доповнення до двох, відповідно до якого всі двійкові розряди від'ємного числа спочатку інвертуються, а потім до цього числа додається 1.

Цілочисельні типи зі знаком мають велике значення для багатьох алгоритмів, але за абсолютною величиною вони наполовину менші за свої без знакові аналоги. Ось як, наприклад, виглядає число 32 767 типу short у двійковому представленні.

0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

Якщо встановити старший розряд цього числа рівним 1, щоб отримати значення зі знаком, то воно буде інтерпретовано як -1, враховуючи формат до заповнення до двох. Але якщо оголосити його як значення типу ushort, то після встановлення в 1 старшого розряду воно стане рівним 65 535.

Ймовірно, найпоширенішим цілочисельним типом у програмуванні є тип int. Змінні типу int часто використовуються для керування циклами, індексування масивів та математичних обчислень загального призначення. Коли потрібне цілочисельне значення з більшим діапазоном представлення чисел, ніж у типу int, то для цього існує цілий ряд інших цілочисельних типів. Так, якщо значення потрібно зберегти без знаку, то для нього можна вибрати тип uint, для великих значень зі знаком — тип long, а для великих значень без знаку — тип ulong. Нижче наведено приклад програми, яка обчислює відстань від Землі до Сонця в дюймах (лістинг 2.3). Для збереження такого великого значення використовується змінна типу long.

Лістинг 2.3 – Приклад програми

// Обчислити відстань від Землі до Сонця в дюймах.

```csharp
using System;
class Inches
static void Main()
```

long inches;

long miles;

miles = 93000000; // 93 000 000 миль до Сонця

inches = miles * 5280 * 12; // 5 280 футів у милі, 12 дюймів у футі

```csharp
Console.WriteLine("Відстань до Сонця: " + inches +" дюймів.");
```

Ось як виглядає результат виконання цієї програми.

Відстань до Сонця: 5892480000000 дюймів. Очевидно, що цей результат не можна було б зберегти в змінній типу int або uint. Найменшими цілими типами є byte і sbyte . Тип byte представляє цілі значення без знаку в межах від 0 до 255. Змінні типу byte особливо зручні для обробки вихідних двійкових даних, наприклад байтового потоку, що надходить від деякого пристрою. А для представлення малих цілих значень зі знаком слугує тип sbyte. У лістингу 2.4 наведено приклад програми, в якій змінна типу byte використовується для керування циклом, де сумуються числа від 1 до 100.

Лістинг 2.4 – Приклад програми для обчислення суми чисел від 1 до 100

```csharp
using System;
class Use_byte
static void Main()
```

byte x;

int sum;

sum = 0;

for (x = 1; х <= 100; х++)

sum = sum + х;

```csharp
Console.WriteLine("Сума чисел від 1 до 100 дорівнює " + sum);
```

Результат виконання цієї програми виглядає наступним чином. Сума чисел від 1 до 100 дорівнює 5050 У наведеному вище прикладі програми цикл виконується лише від 1 до 100, що не перевищує діапазон представлення чисел для типу byte, і тому для керування цим циклом не потрібна змінна більшого типу. Якщо потрібне ціле значення, більше, ніж значення типу byte або sbyte, але менше, ніж значення типу intабо uint, то для нього можна вибрати тип short або ushort.

Типи для представлення чисел з плаваючою комою

Типи з плаваючою точкою дозволяють представляти числа з дробовою частиною. У C# існує дві різновидності типів даних з плаваючою точкою: float і double . Вони представляють числові значення з одинарною і подвійною точністю відповідно. Так, розрядність типу float становить 32 біти, що приблизно відповідає діапазону представлення чисел від 5Е-45 до 3,4Е+38. А розрядність типу double становить 64 біти, що приблизно відповідає діапазону представлення чисел від 5Е-324 до 1,7Е+308.

У програмуванні на С# частіше застосовується тип double , зокрема, через те, що в багатьох математичних функціях з бібліотеки класів С#, яка одночасно є бібліотекою класів для середовища .NET Framework, використовуються числові значення типу double . Наприклад, метод Sqrt() , визначений в бібліотеці класів System.Math , повертає значення типу double, яке представляє собою квадратний корінь з аргумента типу double, переданого даному методу. У наведеному нижче прикладі програми метод Sqrt() використовується для обчислення ра діуса кола за площею круга (лістинг 2.5).

Лістинг 2.5 – Приклад програми для визначення радіуса кола

// Визначити радіус кола за площею круга.

```csharp
using System;
class FindRadius
static void Main()
```

double r;

double area;

area = 10.0;

r = Math.Sqrt(area / 3.1416);

```csharp
Console.WriteLine("Радіус дорівнює " + r);
Результат виконання цієї програми виглядає наступним чином. Радіус дорівнює 1.78412203012729 У вищезазначеному прикладі програми слід звернути увагу на виклик ме тода Sqrt() . Як зазначалося вище, метод Sqrt() належить до класу Math, тому у його виклику перед ім'ям методу йде ім'я самого класу Math. Аналогічним чином перед ім'ям методу WriteLine() у його виклику йде ім'я класу Console. При виклику деяких, хоча й не всіх, стандартних методів зазвичай вказується ім'я їх класу, як показано у наступному прикладі.
```

У наступному прикладі програми демонструється застосування кількох тригонометричних функцій, які належать до класу Math і входять в стандартну бібліотеку класів C#. Вони також оперують даними типу double. У цьому прикладі на екран виводяться значення синуса, косинуса і тангенса кута, вимірюваного в межах від 0,1 до 1,0 радіана (лістинг 2.6).

Лістинг 2.6 – Приклад застосування тригонометричних функцій

// Показати застосування тригонометричних функцій.

```csharp
using System;
class Trigonometry
static void Main()
```

double theta; // кут у радіанах

for (theta = 0.1; theta <= 1.0; theta = theta + 0.1)

```csharp
Console.WriteLine("Синус кута " + theta +
```

" = " + Math.Sin(theta));

```csharp
Console.WriteLine("Косинус кута " + theta +
```

" = " + Math.Cos(theta));

```csharp
Console.WriteLine("Тангенс кута " + theta +
```

" = " + Math.Tan(theta));

```csharp
Console.WriteLine();
```

Нижче наведено лише частина результату виконання даної програми.

Синус кута 0.1 дорівнює 0.0998334166468282

Косинус кута 0.1 дорівнює 0.995004165278026

Тангенс кута 0.1 дорівнює 0.100334672085451

Синус кута 0.2 дорівнює 0.198669330795061

Косинус кута 0.2 дорівнює 0.980066577841242

Тангенс кута 0.2 дорівнює 0.202710035508673

Синус кута 0.3 дорівнює 0.29552020666134

Косинус кута 0.3 дорівнює 0.955336489125606

Тангенс кута 0.3 дорівнює 0.309336249609623

Для обчислення синуса, косинуса і тангенса кута в показаному вище прикладі були використані стандартні методи Math.Sin(), Math.Cos() і Math.Tan(). Так само, як і метод Math.Sqrt(), ці тригонометричні методи викликаються з аргументом типу double і повертають результат того ж типу. Обчислювані кути повинні бути вказані в радіанах.

2.2.2 Десятковий тип даних

Ймовірно, найцікавішим серед усіх числових типів даних в C# є тип decimal, який призначений для застосування в фінансових розрахунках. Цей тип має розрядність 128 біт для представлення числових значень в межах від 1Е-28 до 7,9Е+28. Вам, ймовірно, відомо, що для звичайних арифметичних обчислень з плаваючою точкою характерні помилки округлення десяткових значень. Ці помилки виключаються при використанні типу decimal, який дозволяє представити числа з точністю до 28 (а іноді і 29) десяткових розрядів. Завдяки тому, що цей тип даних здатний представляти десяткові значення без помилок округлення, він особливо зручний для розрахунків, пов'язаних з фінансами. Нижче наведено приклад програми, в якій тип decimal використовується в конкретному фінансовому розрахунку. У цій програмі ціна зі знижкою розраховується на основі початкової ціни та знижки в відсотках (лістинг 2.7).

Лістинг 2.7 – Програма для розрахунку знижки

// Використовувати тип decimal для розрахунку знижки.

```csharp
using System;
class UseDecimal
static void Main()
```

decimal price;

decimal discount;

decimal discounted_price;

// Розрахувати ціну зі знижкою.

price = 19.95m;

discount = 0.15m; // норма знижки становить 15%

discounted_price = price - (price * discount);

```csharp
Console.WriteLine("Ціна зі знижкою: $" + discounted_price);
```

Результат виконання цієї програми виглядає наступним чином:

Ціна зі знижкою: $16.9575.

Зверніть увагу на те, що значення констант типу decimal у наведеному вище прикладі програми вказуються з суфіксом m . Справа в тому, що без суфікса m ці значення інтерпретувалися б як стандартні константи з плаваючою точкою, які несумісні з типом даних decimal . Тим не менше змінній типу decimal можна присвоїти ціле значення без суфікса m , наприклад 10.

Розглянемо ще один приклад застосування типу decimal . У цьому прикладі розраховується майбутня вартість капіталовкладень з фіксованою нормою прибутку протягом декількох років (лістинг 2.8).

Лістинг 2.8 – Приклад для розрахунку майбутньої вартості капіталовкладень

Застосувати тип decimal для розрахунку майбутньої вартості капіталовкладень.

```csharp
using System;
class FutVal
static void Main()
```

decimal amount;

decimal rate_of_return;

int years, i;

amount = 1000.0M;

rate_of_return = 0.07M;

years = 10;

```csharp
Console.WriteLine("Початкові капіталовкладення: $" + amount);
Console.WriteLine("Норма прибутку: " + rate_of_return);
Console.WriteLine("Протягом " + years + " років");
```

for (i = 0; i < years; i++)

amount = amount + (amount * rate_of_return);

```csharp
Console.WriteLine("Майбутня вартість дорівнює $" + amount);
```

Ось як виглядає результат виконання цієї програми.

Початкові капіталовкладення: $1000

Норма прибутку: 0.07

Протягом 10 років

Майбутня вартість становить $1967.151357289565322490000

Зверніть увагу на те, що результат виконання наведеної вище програми представлений з точністю до цілого ряду десяткових розрядів, тобто з явним надлишком порівняно з тим, що зазвичай потрібно.

2.2.3 Символи

У C# символи представлені не 8-розрядним кодом, як у багатьох інших мовах програмування, наприклад C++, а 16-розрядним кодом, який називається унікодом (Unicode). У Unicode набір символів представлений настільки широко, що він охоплює символи практично з усіх природних мов світу. Якщо для багатьох природних мов, зокрема англійської, французької та німецької, характерні відносно невеликі алфавіти, то в деяких інших мовах, наприклад китайській, вживаються досить обширні набори символів, які неможливо представити 8-розрядним кодом. Для подолання цього обмеження в C# визначений тип char , що представляє 16-розрядні значення без знаку в межах від 0 до 65 535. При цьому стандартний набір символів в 8-розрядному коді ASCII є підмножиною унікоду в межах від 0 до 127. Отже, символи в коді ASCII залишаються дійсними в C#.

Для того, щоб присвоїти значення символьній змінній, достатньо заключити це значення (тобто символ) в одинарні лапки. Так, у наведеному нижче фрагменті коду змінній ch присвоюється символ X (лістинг 2.9).

Лістинг 2.9 – Присвоєння значення символьній змінній

char ch;

ch = 'X';

Значення типу char можна вивести на екран за допомогою методу WriteLine(). Наприклад, у наступному рядку коду на екран виводиться значення змінної ch (лістинг 2.10).

Лістинг 2.10 – Вивід значення

```csharp
Console.WriteLine("Значення ch дорівнює: " + ch);
```

Незважаючи на те, що тип char визначений в C# як цілочисельний, його не слід плутати з усіма іншими цілочисельними типами. Справа в тому, що в C# відсутнє автоматичне перетворення символьних значень в цілочисельні і навпаки. Наприклад, наступний фрагмент коду містить помилку (лістинг 2.11).

Лістинг 2.11 – Фрагмент коду з помилкою

char ch;

ch = 88; // помилка, не вийде

Неправильність наведеного вище фрагмента коду пояснюється тим, що 88 — це ціле значення, яке не перетворюється автоматично в символьне. При спробі скомпілювати цей фрагмент коду буде виведено відповідне повідомлення про помилку. Для того щоб операція присвоєння цілого значення символьній змінній була допустимою, необхідно здійснити приведення типу, про яке йтиметься далі.

2.2.4 Логічний тип даних

Тип bool представляє два логічні значення: "істина" і "хиба". Ці логічні значення позначаються в C# зарезервованими словами true і false відповідно. Отже, змінна або вираз типу bool буде приймати одне з цих логічних значень. Крім того, в C# не визначено взаємне перетворення логічних і цілих значень. Наприклад, 1 не перетвориться в значення true , а 0 — в значення false (лістинг 2.12).

Лістинг 2.12 – Приклад використання типу bool

// Показати використання типу bool.

```csharp
using System;
class BoolDemo
static void Main()
```

bool b;

b = false;

```csharp
Console.WriteLine("b дорівнює " + b);
```

b = true;

```csharp
Console.WriteLine("b дорівнює " + b);
```

// Логічне значення може керувати оператором if.

```csharp
if (b) Console.WriteLine("Виконується.");
```

b = false;

```csharp
if (b) Console.WriteLine("Не виконується.");
```

// Результатом виконання оператора відношення

// є логічне значення.

```csharp
Console.WriteLine("10 > 9 дорівнює " + (10 > 9));
```

Програма дає наступний результат:

b дорівнює False

b дорівнює True

Виконується.

10 > 9 дорівнює True

У наведеній вище програмі виявляються три цікаві особливості. По-перше, при виводі логічного значення типу bool за допомогою методу WriteLine() на екрані з'являється значення " True " або " False " . По-друге, самого значення змінної типу bool достатньо для керування оператором if . Для цього не потрібно, наприклад, записувати оператор if наступним чином (лістинг 2.13).

Лістинг 2.13 – Приклад з if

if (b == true) ...

І по-третє, результатом виконання оператора відношення є логічне значення. Саме тому в результаті обчислення виразу 10 > 9 на екран виводиться значення " True. " Крім того, вираз 10 > 9 слід заключити в дужки, оскільки оператор + має вищий пріоритет, ніж оператор > .

2.2.5 Взаємодія з консоллю та форматування

До цього моменту при виводі за допомогою методу WriteLine() дані відображалися у форматі, що використовується за замовчуванням. Але в середовищі .NET Framework визначений достатньо розвинутий механізм форматування, що дозволяє в усіх деталях керувати виведенням даних. Форматований ввід-вивід детальніше розглядається далі у цій методичці, а до того часу корисно ознайомитися з деякими можливостями форматування. Вони дозволяють вказати, у якому саме вигляді слід виводити значення за допомогою методу WriteLine(). Завдяки цьому виведений результат виглядає більш привабливо. При виведенні списків даних у попередніх прикладах програм кожен елемент списку доводилося відокремлювати знаком +, як у наступному рядку (лістинг 2.14).

Лістинг 2.14 – Використання методу WriteLine()

int count = 2;

int price = 3;

```csharp
Console.WriteLine("Ви замовили " + count + " предмета по ціні $" + price + " кожен.");
Або можна використовувати більш свіжий підхід використовуючи конструкцію $"Ви замовили {count}" приклад коду нижче (лістинг 2.15).
Лістинг 2.15 – Використання конструкції $"Ви замовили {count}"
```

int count = 2;

int price = 3;

```csharp
Console.WriteLine($"Ви замовили {count} предмета по ціні $ {price} кожен.");
Використовуючи таку конструкцію {ім’я змінної} можна створювати більш наглядний код для форматування виводу.
```

Звичайно, такий спосіб виведення числової інформації зручний, але він не дозволяє керувати зовнішнім виглядом виведеної інформації. Наприклад, при виведенні значення з плаваючою точкою неможливо визначити кількість відображуваних десяткових розрядів (лістинг 2.16).

Лістинг 2.16 – Виведення значення з плаваючою точкою

```csharp
Console.WriteLine("Ділення 10/3 дає: " + 10.0/3.0);
```

Розглянемо оператор, який виводить наступний результат.

Ділення 10/3 дає: 3. 33333333333333

У деяких випадках такого виводу може вистачити, а в інших - він просто неприпустимий. Наприклад, у фінансових розрахунках після десяткової крапки звичайно вказувати лише два десяткових розряди. Для керування форматуванням числових даних використовується інша форма методу WriteLine(), що дозволяє вбудовувати інформацію форматування, як показано нижче (лістинг 2.17).

Лістинг 2.17 – Використання форматування

WriteLine("форматуючий рядок", arg0, arg1, ... , argN);

Форматуючий рядок складається з двох елементів: звичайних друкованих символів, призначених для виводу у вихідному вигляді, а також форматувальних специфікаторів. Останні вказуються у наступній загальній формі:

```csharp
{argnum, width: fmt},
де argnum —номер виводимого аргумента, починаючи з нуля; width —мінімальна ширина поля; fmt —формат. Параметри width і fmtє необов'язковими. Якщо під час виконання зустрічається форматуючий рядок зі специфікатором формату, то замість нього підставляється і відображається відповідний аргумент, позначений параметром argnum . Таким чином, розташування специфікатора формату в форматуючому рядку визначає місце відображення відповідних даних. Параметри width і fmt можна не вказувати. Це означає, що у своїй найпростішій формі специфікатор формату позначає конкретний відображуваний аргумент. Наприклад, специфікатор {0} позначає аргумент arg0, специфікатор {1}— аргумент arg1і т.д. Почнемо з найпростішого прикладу (лістинг 2.18).
```

Лістинг 2.18 – Приклад

```csharp
Console.WriteLine("В лютому {0} або {1} днів.", 28, 29);
```

При виконанні оператора отримуємо наступний результат:

В лютому 28 або 29 днів

```csharp
Як бачите, значення 28 підставляється замість специфікатора {0} , а значення 29 — замість специфікатора {1} . Отже, специфікатори формату вказують міс це в рядку, де відображаються відповідні аргументи (у цьому випадку — значення 28 і 29). Крім того, зверніть увагу на те, що додаткові значення розділяються комою, а не знаком +.
```

Нижче наведено змінений варіант попереднього оператора, в якому вказується ширина полів (лістинг 2.19).

Лістинг 2.19 – Змінений варіант попереднього оператора

```csharp
Console.WriteLine("В лютому {0,10} або {1,5} днів.", 28, 29);
```

Виконання цього оператора дає наступний результат:

В лютому 28 або 29 днів.

Як бачите, невикористані частини полів заповнені пробілами. Нагадаємо, що мінімальна ширина поля визначається параметром width . Якщо потрібно, її можна перевищити при виведенні результату.

Звичайно, аргументи, пов'язані з командою форматування, не обов'язково мають бути константами. Нижче наведено приклад програми, яка виводить таблицю результатів піднесення чисел до квадрату і кубу. У ній команди форматування використовуються для виведення відповідних значень (лістинг 2.20).

Лістинг 2.20 – Застосування команди форматування

// Застосувати команди форматування.

```csharp
using System;
class DisplayOptions
static void Main()
```

int i;

```csharp
Console.WriteLine("Число Квадрат Куб");
```

for (i = 1; i < 10; i++)

```csharp
Console.WriteLine("{0}\t{1}\t{2}", i, i * i, i * i * i);
```

Результат виконання цієї програми виглядає наступним чином:

Число Квадрат Куб

1 1 1

2 4 8

3 9 27

4 16 64

5 25 125

6 36 216

7 49 343

8 64 512

9 81 729

У вищезазначених прикладах самі виведені значення не форматувалися. Але головне призначення специфікаторів формату - керувати зовнішнім виглядом виведених даних. Найчастіше форматуванню підлягають наступні типи даних: з плаваючою точкою і десятковий. Найпростіший спосіб вказати формат даних - описати шаблон, який буде використовуватися в методі WriteLine() . Для цього вказується зразок потрібного формату за допомогою символів #, що позначають розряди чисел. Крім того, можна вказати десяткову точку і коми, що розділяють цифри. Нижче наведено приклад більш підходящого виводу результату ділення 10 на 3 (лістинг 2.21).

Лістинг 2.21 – Приклад виводу результату

```csharp
Console.WriteLine("Ділення 10/3 дає: (0:#.##)", 10.0/3.0);
```

Виконання цього оператора призводить до наступного результату:

Ділення 10/3 дає: 3.33

У даному прикладі шаблон #.## вказує методу WriteLine() відобразити два десяткових розряди у дробовій частині числа. Слід, однак, мати на увазі, що метод WriteLine() може відобразити стільки цифр зліва від десяткової точки, скільки потрібно для правильної інтерпретації виведеного значення.

Розглянемо ще один приклад (лістинг 2.22).

Лістинг 2.22 – Приклад виводу результату

```csharp
Console.WriteLine("{0:###,###.##}", 123456.56);
```

Оператор дає наступний результат:

123,456.56

Для виводу грошових сум, наприклад, рекомендується використовувати специфікатор формату С (лістинг 2.23).

Лістинг 2.23 – Приклад виводу грошових сум

decimal balance;

balance = 12323.09m;

```csharp
Console.WriteLine("Поточний баланс дорівнює {0:С}", balance);
```

Результат виконання цього фрагмента коду виводиться в форматі грошових сум, вказаних в доларах США.

Поточний баланс дорівнює $12,323.09

Форматом С можна також скористатися, щоб подати в більш підходящому вигляді результат виконання розглянутої раніше програми розрахунку ціни зі знижкою (лістинг 2.24).

Лістинг 2.24 – Приклад виводу результату в місцевій валюті

// результату в місцевій валюті.

```csharp
using System;
class UseDecimal
static void Main()
```

decimal price;

decimal discount;

decimal discounted_price;

// розрахувати ціну зі знижкою,

price = 19.95m;

discount = 0.15m; // норма знижки становить 15%

discounted_price = price - (price * discount);

```csharp
Console.WriteLine("Ціна зі знижкою: {0:С}", discounted_price);
```

Ось як тепер виглядає результат виконання цієї програми.

Ціна зі знижкою: 16,96 грн.

```csharp
Для вводу даних із консолі використовується метод Console.ReadLine(). Даний метод зчитує строку яку ви ввели з консолі, щоб її перетворити в числовий тип можна використовувати конструкцію int.Parse(Console.ReadLine()).
```

Лістинг 2.25 – Приклад вводу даних з консолі та перетворення їх в числа

```csharp
Console.WriteLine("Введіть значення строки str");
string str = Console.ReadLine();
Console.WriteLine("Значення введеного str = " + str);
Console.WriteLine("Введіть значення для зміної i");
int i = int.Parse(Console.ReadLine());
Console.WriteLine("Значення введеного i = " + i);
Console.WriteLine("Введіть значення для зміної d");
double d = double.Parse(Console.ReadLine());
Console.WriteLine("Значення введеного d = " + d);
Console.WriteLine("Введіть значення для зміної s");
short s = short.Parse(Console.ReadLine());
Console.WriteLine("Значення введеного s = " + s);
```

2.2.6 Літерали

У C# літералами називаються постійні значення, представлені в зручній для

сприйняття формі. Наприклад, число 100 є літералом. Самі літерали і їх призначення настільки зрозумілі, що вони застосовувалися в усіх попередніх прикладах програм без будь-яких пояснень. Але тепер настав час дати їм формальне пояснення.

У C# літерали можуть бути будь-якого простого типу. Представлення кожного літерала залежить від конкретного типу. Як пояснювалося раніше, символьні літерали заключаються у одинарні лапки. Наприклад, 'а' і '%' є символьними літералами.

Цілочисельні літерали вказуються у вигляді чисел без дробової частини. 10і – 100 – це цілочисельні літерали. Для позначення літералів з плаваючою точкою потрібно вказувати десяткову точку і дробову частину числа. 11.123 – це літерал з плаваючою точкою. Для дійсних чисел з плаваючою точкою в C# допускається також використовувати експоненціальне представлення.

У літералів також повинен бути конкретний тип, оскільки C# є строго типізованою мовою. У зв'язку з цим виникає природне питання: до якого типу слід віднести числовий літерал, наприклад 2,123987 або 0.23 ? На щастя, для відповіді на це питання в C# встановлено кілька простих правил, які потрібно дотримуватися.

По-перше, цілочисельним літералам повинен бути найменший цілочисельний тип, яким вони можуть бути представлені, починаючи з типу int. Отже, цілочисельним літералам може бути один з наступних типів: int, uint, long або ulong залежно від значення літерала. І по-друге, літерали з плаваючою точкою відносяться до типу double .

Якщо вас не влаштовує використовуваний за замовчуванням тип літерала, ви можете явно вказати інший його тип за допомогою суфікса. Так, для вказання типу long до літерала додається суфікс l або L. Наприклад, 12 — це літерал типу int, а 12L — літерал типу long . Для вказання цілочисельного типу без знаку до літерала додається суфікс u або U . Отже, 100 — це літерал типу int, а 100U — літерал типу uint. А для вказання довгого цілочисельного типу без знаку до літерала при додається суфікс ul або UL. Наприклад, 984375UL — це літерал типу ulong.

Крім того, для вказання типу float до літерала додається суфікс F або f . Наприклад, 10.19F - це літерал типу float . Ви навіть можете вказати тип double, додавши до літерала суфікс d або D , хоча це зайве. Адже, як зазначалося вище, за замовчуванням літерали з плаваючою точкою належать до типу double.

І нарешті, для вказання типу decimal до літерала додається суфікс m або М. Наприклад, 9.95М- це десятковий літерал типу decimal.

Незважаючи на те, що цілочисельні літерали за замовчуванням утворюють значення типу int, uint, long або ulong, їх можна присвоїти змінним типу byte, sbyte, short або ushort, за умови, що присвоюване значення може бути представлене цільовим типом.

2.2.7 Шістнадцяткові літерали

Вам, ймовірно, відомо, що в програмуванні іноді виявляється простіше користуватися системою числення за основою 16, ніж за основою 10. Система числення за основою 16 називається шістнадцятковою. У ній використовуються числа від 0 до 9, а також літери від А до F, якими позначаються десяткові числа 10, 11, 12, 13, 14 і 15. Наприклад, десятковому числу 16 відповідає шістнадцяткове число 10. Оскільки шістнадцяткові числа часто використовуються в програмуванні, в C# дозволяється вказувати цілочисельні літерали у шістнадцятковому форматі. Шістнадцяткові літерали повинні починатися з символів 0х , тобто нуля і наступної латинської літери " ікс "\. Нижче наведені деякі приклади шістнадцяткових літералів (лістинг 2.25).

Лістинг 2.26 – Приклад виводу результату в місцевій валюті

count = 0xFF; // 255 у десятковій системі

incr = 0x1а; // 26 у десятковій системі

2.2.8 Керуючі послідовності символів

Більшість друкованих символів достатньо заключити в одинарні лапки, але набір у текстовому редакторі деяких символів, наприклад повернення каретки, викликає особливі труднощі. Крім того, ряд інших символів, зокрема одинарні і подвійні лапки, мають спеціальне призначення в С#, тому їх не можна використовувати звати безпосередньо. З цих причин у C# передбачені спеціальні керуючі послідовності символів, іноді ще називаються константами з зворотньою косою рискою (таблиця 2.3). Такі послідовності застосовуються замість тих символів, які вони представляють.

Таблиця 2.3 – Керуючі послідовності символів

Наприклад, у наступному рядку коду змінній ch присвоюється символ табуляції (лістинг 2.26).

Лістинг 2.27 – Присвоєння символу табуляції

ch = '\t';

А в наведеному нижче прикладі коду змінній ch присвоюється символ одинарної лапки (лістинг 2.27).

Лістинг 2.28 – Присвоєння символу одинарної лапки

ch = '\'';

2.2.9 Рядкові літерали

У C# підтримується ще один тип літералів - рядковий. Рядковий літерал представляє собою набір символів, заключених у подвійні лапки.. Наприклад наступний фрагмент коду: "це тест" представляє собою текстовий рядок. Приклади подібних рядків неодноразово зустрічалися у наведених вище прикладах програм.

Крім звичайних символів, рядковий літерал може містити одну або кілька управляючих послідовностей символів, про які йшлося вище. Розглянемо для прикладу програму, в якій використовуються управляючі послідовності (лістинг 2.28).

Лістинг 2.29 – Використання керуючих символів у рядкових літералах

// Показати використання керуючих

// послідовностей символів у рядкових літералах.

```csharp
using System;
class StrDemo
static void Main()
Console.WriteLine("Перший рядок\nДругий рядок\nТретій рядок");
Console.WriteLine("Один\tДва\tТри");
Console.WriteLine("Чотири\tПять\tШість");
```

// Вставити лапки.

```csharp
Console.WriteLine("\"Навіщо?\", запитав він.");
```

Результат виконання програми наведений нижче.

Перший рядок

Другий рядок

Третій рядок

Один Два Три

Чотири Пять Шість

"Навіщо?", запитав він.

У наведеному вище прикладі програми зверніть увагу на те, що для переходу на новий рядок використовується керуюча послідовність. Для виводу кількох рядків зовсім не обов'язково викликати метод WriteLine() декілька разів – достатньо вставити керуючу послідовність у тих місцях подовженої текстової строки (або рядкового літерала), де має відбуватися перехід на новий рядок. Зверніть також увагу на те, як у текстовому рядку формується знак лапок.

Крім описаної вище форми рядкового літерала, також можна вказати бук вальний рядковий літерал. Такий літерал починається з символу @ , після якого слідує рядок у лапках. Зміст рядка у лапках сприймається без змінень і може бути розширений до двох і більше рядків. Це означає, що в літеральний рядковий літерал можна включити символи нового рядка, табуляції та інші, не звертаючись до керуючих послідовностей. Єдиний виняток становлять подвійні лапки ("), для вказання яких необхідно використовувати дві подвійні лапки підряд ( ""). У наведеному нижче прикладі програми демонструється застосування літеральних рядкових літералів (лістинг 2.29).

Лістинг 2.30 – Застосування літеральних рядків літералів

// Показати застосування літеральних рядкових літералів.

```csharp
using System;
class Verbatim
static void Main()
Console.WriteLine(@"Це літеральний
```

рядковий літерал, який займає кілька рядків.

");

```csharp
Console.WriteLine(@"А це вивід з табуляцією:
```

1 2 3 4

5 6 7 8

");

```csharp
Console.WriteLine(@"Відгук програміста: ""Мені подобається C#.""");
```

Результат виконання цієї програми наведено нижче.

Це літеральний

рядковий літерал, який

займає кілька рядків.

А це вивід з табуляцією:

1 2 3 4

5 6 7 8

Відгук програміста: "Мені подобається C#."

Слід особливо підкреслити, що літеральні рядкові літерали виводяться у тому же вигляді, в якому вони введені у вихідному тексті програми.

Перевага літеральних рядкових літералів полягає в тому, що вони дозволяють вказати в програмі виведений результат саме так, як він повинен виглядати на екрані. Але якщо виводиться кілька рядків, то перехід на новий рядок може порушити порядок набору початкового тексту програми з відступами. Саме з цієї причини в прикладах програм, наведених у цій книзі, використання літеральних рядкових літералів обмежено. Тим не менш, вони приносять багато чудових переваг у багатьох випадках, коли потрібне форматування виведених результатів.

І останнє зауваження: не плутайте рядки з символами. Символьний літерал, на приклад 'X', позначає одиночну букву типу char. А рядок, що складається з одного символу, наприклад "X", залишається текстовим рядком.

2.2.10 Неявно типізовані змінні

Як пояснювалося вище, всі змінні в C# повинні бути оголошені. Зазвичай, при оголошенні змінної спочатку вказується тип, наприклад int або bool , а потім ім'я змінної. Але починаючи з версії C# 3.0, компілятору надається можливість самому визначити тип локальної змінної, виходячи зі значення, яким вона ініціалізується. Така змінна називається неявно типізованою.

Неявно типізована змінна оголошується за допомогою ключового слова var і обов'язково повинна бути ініціалізована. Для визначення типу цієї змінної компілятору служить тип її ініціалізатора, тобто значення, яким вона ініціюється. Розглянемо такий приклад (лістинг 2.30).

Лістинг 2.31 – Оголошення неявно типізованої змінної

var е = 2.7183;

У даному прикладі змінна е ініціалізується літералом з плаваючою крапкою, який за замовчуванням має тип double, тому вона відноситься до типу double. Якби змінна е була оголошена таким чином, як у лістингу 2.31, то вона була віднесена до типу float.

Лістинг 2.32 – Оголошення неявно типізованої змінної

var е = 2.7183F;

У наведеному нижче прикладі програми демонструється застосування неявно типізованих змінних. Він представляє собою варіант програми з попереднього розділу, змінений таким чином, щоб всі змінні були типізовані неявно.

Лістинг 2.33 – Застосування неявно типізованих змінних

// Показати застосування неявно типізованих змінних.

```csharp
using System;
class ImplicitlyTypedVar
static void Main()
```

// Ці змінні типізовані неявно. Вони віднесені

// до типу double, оскільки ініціалізуючі їх

// вирази самі відносяться до типу double.

var s1 = 4.0;

var s2 = 5.0;

// Отже, змінна hypot неявно типізована і

// належить до типу double, оскільки результат,

// повернутий методом Sqrt(), має тип double.

var hypot = Math.Sqrt((s1 * s1) + (s2 * s2));

```csharp
Console.Write("Гіпотенуза трикутника зі сторонами " +
```

s1 + " by " + s2 + " дорівнює ");

```csharp
Console.WriteLine("{0:#.###}.", hypot);
```

// Наступний оператор не може бути скомпільований,

// оскільки змінна s1 має тип double і

// їй не можна присвоїти десяткове значення.

// s1 = 12.2М; // Помилка!

Результат виконання цієї програми виявляється таким самим, як і раніше. Важливо підкреслити, що неявно типізована змінна все ще залишається строго типізованою. Зверніть увагу на наступний закоментований рядок з вищезазначеної програми:

// s1 = 12.2М; // Помилка!

Ця операція присвоєння недійсна, оскільки змінна s1належить до типу double. Отже, їй не можна присвоїти десяткове значення. Єдина відмінність неявно типізованої змінної від звичайної, явно типізованої змінної, - у способі визначення її типу. Як тільки цей тип буде визначений, він закріплюється за змінною до кінця її існування. Це, зокрема, означає, що тип змінної s1 не може бути змінений під час виконання програми. Неявно типізовані змінні впроваджені в C# не для того, щоб замінити звичайні оголошення змінних. Навпаки, неявно типізовані змін ні призначені для особливих випадків, і найбільш помітний з них стосується мови інтегрованих запитів (LINQ). Отже, більшість оголошень змінних повинні і надалі залишатися явно типізованими, оскільки вони полегшують читання і розуміння вихідного тексту програми.

І останнє зауваження: одночасно можна оголосити лише одну неявно типізовану змінну. Тому оголошення є неправильним і не може бути скомпільованим (лістинг 2.33).

Лістинг 2.34 – Помилкове оголошення

var s1 = 4.0, s2 = 5.0; // Помилка!

Адже в ньому здійснюється спроба оголосити обидві змінні, s1 і s2, одночасно.

2.2.11 Область дії та час існування змінних

Усі змінні, що використовувалися в попередніх прикладах програм, оголошувалися на початку методу Main(). Але в C# дозволяється оголошувати локальну змінну в будь-якому кодовому блоці. Кодовий блок починається відкриваючою фігурною дужкою і закінчується закриваючою фігурною дужкою. Цей блок і визначає область дії. Отже, кожного разу, коли починається блок, утворюється нова область дії. Перш за все, область дії визначає видимість імен окремих елементів, включаючи змінні, в інших частинах про грами без додаткового уточнення. Вона також визначає час існування локальних змінних.

У C# до числа найважливіших належать області дії, визначені класом і методом. Розгляд області дії класу (і оголошених в ній змінних) доведеться відкласти до того моменту, коли в цій книзі будуть описуватися класи. А до того часу будуть розглядатися лише ті області дії, які визначаються методом або в самому методі.

Область дії, визначена методом, починається відкриваючою фігурною дужкою і закінчується закриваючою фігурною дужкою. Але якщо у цього методу є параметри, то вони також входять в область дії, визначену цим методом. Зазвичай, локальні змінні оголошуються в області дії, невидимій для коду, що знаходиться поза цією областю. Тому, оголошуючи змінну в певній області дії, ви таким чином захищаєте її від доступу або зміни за межами цієї області. Звичайно, правила області дії служать основою для інкапсуляції. Області дії можуть бути вкладеними. Наприклад, кожного разу, коли створюється кодовий блок, одночасно утворюється і нова, вкладена область дії. У цьому випадку зовнішня область дії охоплює внутрішню область. Це означає, що локальні змінні, оголошені в зовнішній області дії, будуть видимі для коду внутрішньої області дії. Але навпаки не є правдою: локальні змінні, оголошені внутрішньою областю дії, не будуть видимі поза цією областю.

Для того щоб стала більш зрозумілою сутність вкладених областей дії, розглянемо наступний приклад програми (лістинг 2.34).

Лістинг 2.35 – Область дії кодового блоку

// Показати область дії кодового блоку.

```csharp
using System;
class ScopeDemo
static void Main()
```

int x; // Ця змінна доступна для всього коду всередині методу Main().

х = 10;

if (x == 10)

```csharp
{ // почати нову область дії
```

int у = 20; // Ця змінна доступна тільки в даному кодовому блоку.

// Тут доступні обидві змінні, х і у.

```csharp
Console.WriteLine("х і у: " + х + " " + у);
```

х = у * 2;

// у = 100; // Помилка! Змінна у тут недоступна.

// А змінна х тут все ще доступна.

```csharp
Console.WriteLine("х дорівнює " + х);
```

Як пояснюється в коментарях до наведеної вище програми, змінна х оголошується на початку області дії методу Main() , і тому вона доступна для усього наступного коду в межах цього методу. У блоку умовного оператора if оголошується змінна у. А оскільки цей кодовий блок визначає свою власну область дії, то змінна у видима тільки для коду в межах даного блоку. Саме тому рядок line у = 100;, що знаходиться поза межами цього блоку, закоментований. Якщо видалити знаходяться перед нею символи коментаря ( // ), то під час компіляції програми станеться помилка, оскільки змінна у невидима за межами свого кодового блоку. У той же час змінна х може використовуватися в блоку умовного оператора if, оскільки коду з цього блоку, знаходячись у вкладеній області дії, доступні змінні, оголошені у зовнішній області дії, яка її оточує.

Змінні можуть бути оголошені в будь-якому місці кодового блоку, але вони стають дійсними лише після свого оголошення. Так, якщо оголосити змінну на початку методу, то вона буде доступна для всього іншого коду в межах цього методу. А якщо оголосити змінну в кінці блоку, то вона, по суті, буде непотрібною, оскільки не буде доступна жодному коду.

Якщо в оголошення змінної включається ініціалізатор, то така змінна ініціалізується повторно при кожному вході в той блок, в якому вона оголошена.

Розглянемо наступний приклад програми (лістинг 2.35).

Лістинг 2.36 – Демонстрація часу існування змінної

// Продемонструвати час існування змінної.

```csharp
using System;
class VarInitDemo
static void Main()
```

int x;

for (x = 0; x < 3; x++)

int у = -1; // Змінна у ініціалізується при кожному вході в блок.

```csharp
Console.WriteLine("у дорівнює: " + у); // Тут завжди виводиться -1
```

y = 100;

```csharp
Console.WriteLine("у тепер дорівнює: " + у);
```

Нижче наведено результат виконання цієї програми.

у дорівнює: -1 у тепер дорівнює: 100

у дорівнює: -1 у тепер дорівнює: 100

у дорівнює: -1 у тепер дорівнює: 100

Як бачите, змінна уповторно ініціалізується одним і тим самим значенням -1 при кожному вході во внутрішній цикл for. І незважаючи на те, що після цього циклу їй присвоюється значення 100, воно втрачається при повторній її ініціалізації.

У мові C# є ще одна особливість дотримання правил області дії: незалежно від того, що блоки можуть бути вкладені, жодна змінна з внутрішньої області дії не повинна мати таке саме ім'я, як і змінна з зовнішньої області дії. У наведеному нижче прикладі програми підприємство пробує оголосити дві різні змінні з одним і тим самим ім'ям, і тому програма не може бути скомпільована (лістинг 2.36).

Лістинг 2.37 – Приклад неправильного оголошення

/*У цій програмі намагаються оголосити змінну з таким самим ім'ям, як і змін-

на, визначена в зовнішній області дії.

*** Цю програму не можна скомпілювати. ***

```csharp
using System;
class NestVar
static void Main()
```

int count;

for (count = 0; count < 10; count = count + 1)

```csharp
Console.WriteLine("Це підрахунок: " + count);
```

int count; // Неприпустимо!!!

for (count = 0; count < 2; count++)

```csharp
Console.WriteLine("У цій програмі є помилка!");
```

Якщо у вас є деякий досвід програмування на С або C++, то вам повинно бути відомо, що в цих мовах немає обмежень на присвоєння імен змінним, оголошеним во внутрішній області дії. Отже, в С і C++ оголошення змінної count в кодовому блоку, що входить в зовнішній цикл for , як у наведеному вище прикладі, вважається повністю допустимим. Але в С і C++ таке оголошення одночасно означає приховування зовнішньої змінної. Розробники C# вважають, що таке приховування імен може легко призвести до програмних помилок, і тому вирішили заборонити його.

2.2.12 Перетворення та приведення типів

У програмуванні часто значення змінних одного типу присвоюються змінним іншого типу. Наприклад, у наведеному нижче фрагменті коду ціле значення типу int присвоюється змінній з плаваючою точкою типу float (лістинг 2.37).

Лістинг 2.38 – Приклад неправильного оголошення

int i;

float f;

i = 10;

f = i; // присвоїти ціле значення змінній типу float

Якщо в одній операції присвоювання змішуються сумісні типи даних, то значення в правій частині оператора присвоювання автоматично перетворюється в тип, зазначений в лівій його частині. Тому в наведеному вище фрагменті коду значення змінної i спочатку перетворюється в тип float, а потім присвоюється змінній f . Але внаслідок строгого контролю типів далеко не всі типи даних у C# виявляються повністю сумісними, а отже, не всі перетворення типів дозволені в неявному вигляді. Наприклад, типи bool і int несумісні.

На жаль, перетворення несумісних типів все ж може бути здійснено шляхом приведення. Приведення типів, по суті, означає явне їх перетворення. У цьому розділі розглядається як автоматичне перетворення, так і при ведення типів.

2.2.13 Автоматичне перетворення типів

Коли дані одного типу присвоюються змінній іншого типу, неявне перетворення типів відбувається автоматично за наступних умов:

обидва типи сумісні;

діапазон представлення чисел цільового типу ширший, ніж у вихідного типу.

Якщо обидва ці умови виконуються, то відбуваєтьсярозширююче перетворення. Наприклад, тип int достатньо великий, щоб вміщати всі дійсні значення типу byte, а крім того, обидва типи, int і byte, є сумісними цілими числовими типами, і тому для них цілком можливе неявне перетворення.

Числові типи, як цілочисельні, так і з плаваючою точкою, повністю сумісні один з одним для виконання розширюючих перетворень. Так, наведена нижче програма складена абсолютно правильно, оскільки перетворення типу long в тип double є розширюючим і виконується автоматично (лістинг 2.38).

Лістинг 2.39 – Приклад автоматичного перетворення

// Показати неявне перетворення типу long в тип double.

```csharp
using System;
class LtoD
static void Main()
```

long L;

double D;

L = 100123285L;

D = L;

```csharp
Console.WriteLine("L і D: " + L + " " + D);
```

Якщо тип long може бути перетворений в тип double неявно, то зворотне перетворення типу double в тип long неявно неможливо, оскільки воно не є розширюючим. Отже, наведений нижче варіант попередньої програми складений неправильно (лістинг 2.39).

Лістинг 2.40 – Приклад програми з помилкою

// *** Ця програма не може бути скомпільована. ***

```csharp
using System;
class LtoD
static void Main()
```

long L;

double D;

D = 100123285.0;

L = D; // Неприпустимо!!!

```csharp
Console.WriteLine("L і D: " + L + " " + D);
```

Крім згаданих вище обмежень, не допускається неявне взаємне перетворення типів decimal і float або double, а також числових типів і char або bool. Крім того, типи char і bool несумісні один з одним.

2.2.14 Приведення несумісних типів

Незважаючи на всю корисність неявних перетворень типів, вони не здатні задовольнити всі потреби в програмуванні, оскільки допускають лише розширюючі перетворення сумісних типів. А в усіх інших випадках доводиться звертатися до приведення типів. Приведення — це команда компілятору перетворити результат обчислення виразу в зазначений тип. А для цього потрібне явне перетворення типів. Нижче наведена загальна форма приведення типів.

(цільовий_тип) вираз

Тут цільовий_тип означає той тип, в який бажано перетворити вказаний вираз. Розглянемо для прикладу наступне оголошення змінних.

double х, у;

Якщо результат обчислення виразу х/у повинен бути типу int , то слід написати наступне.

(int) (х / у)

Незважаючи на те, що змінні х і у належать до типу double , результат обчислення виразу х/у перетворюється в тип int завдяки приведенню. У даному прикла ді вираз х/у слід обов'язково вказувати в дужках, інакше приведення до типу int буде поширюватися тільки на змінну х , а не на результат її ділення на змінну у. Приведення типів у даному випадку потрібне, оскільки неявне перетворення типу double в тип int неможливе.

Якщо приведення типів приводить до звужувального перетворення, то частина інформації може бути втрачена. Наприклад, в результаті приведення типу long до типу int частина інформації буде втрачена, якщо значення типу long буде більше діапазону представлення чисел для типу int , оскільки старші розряди цього числового значе ння будуть відкинуті. Коли значення з плаваючою точкою приводиться до цілочисель ного, то в результаті обрізання втрачається дробова частина цього числового значення. Так, якщо присвоїти значення 1,23 цілочисельній змінній, то в результаті в ній залишиться лише ціла частина початкового числа (1), а дробова його частина (0,23) буде втрачена.

У наступному прикладі програми демонструється ряд перетворень типів, які потребують приведення. У цьому прикладі також показано ряд ситуацій, в яких приведення типів призводить до втрати даних (лістинг 2.40).

Лістинг 2.41 – Приклад приведення типів

// Показати приведення типів.

```csharp
using System;
class CastDemo
static void Main()
```

double x, y;

byte b;

int i;

char ch;

uint u;

short s;

long 1;

x = 10.0;

у = 3.0;

// Приведення типу double до типу int, дробова частина числа втрачається.

i = (int)(х / у);

```csharp
Console.WriteLine("Цілочисельний результат ділення х / у: " + i);
Console.WriteLine();
```

// Приведення типу int до типу byte без втрати даних,

i = 255;

b = (byte)i;

```csharp
Console.WriteLine("b після присвоєння 255: " + b +
```

"--без втрати даних.");

// Приведення типу int до типу byte з втратою даних,

i = 257;

b = (byte)i;

```csharp
Console.WriteLine("b після присвоєння 257: " + b +
```

"--з втратою даних.");

```csharp
Console.WriteLine();
```

// Приведення типу uint до типу short без втрати даних.

u = 32000;

s = (short)u;

```csharp
Console.WriteLine("s після присвоєння 32000: " +
```

s + "--без втрати даних.");

// Приведення типу uint до типу short з втратою даних,

u = 64000;

s = (short)u;

```csharp
Console.WriteLine("s після присвоєння 64000: " +
```

s + "--з втратою даних.");

```csharp
Console.WriteLine();
```

// Приведення типу long до типу uint без втрати даних.

l = 64000;

u = (uint)l;

```csharp
Console.WriteLine("u після присвоєння 64000: " + u +
```

"--без втрати даних.");

// Приведення типу long до типу uint з втратою даних.

l = -12;

u = (uint)l;

```csharp
Console.WriteLine("і після присвоєння -12: " + u +
```

"--з втратою даних.");

```csharp
Console.WriteLine();
```

// Приведення типу int до типу char,

b = 88; // код ASCII символу X

ch = (char)b;

```csharp
Console.WriteLine("ch після присвоєння 88: " + ch);
```

Ось який результат дає виконання цієї програми.

Цілочисельний результат ділення х / у: 3

b після присвоєння 255: 255 -- без втрати даних.

b після присвоєння 257: 1 -- з втратою даних.

s після присвоєння 32000: 32000 -- без втрати даних.

s після присвоєння 64000: -1536 -- з втратою даних.

u після присвоєння 64000: 64000 -- без втрати даних.

u після присвоєння -12: 4294967284 -- з втратою даних.

ch після присвоєння 88: X

Розглянемо кожну операцію присвоєння в показаному вище прикладі програми окремо. Внаслідок приведення результату ділення х/у до типу int відкидається дробова частина числа, а отже, втрачається частина інформації.

Коли змінній b присвоюється значення 255, то інформація не втрачається, оскільки це значення входить в діапазон представлення чисел для типу byte . Але коли змінній b присвоюється значення 257, то частина інформації втрачається, оскільки це значення перевищує діапазон представлення чисел для типу byte. Приведення типів потрібне в обох випадках, оскільки неявне перетворення типу int в тип byte неможливе.

Коли змінній s типу short присвоюється значення 32 000 змінній і типу uint, втрати даних не відбувається, оскільки це значення входить в діапазон представлення чисел для типу short. Але в наступній операції присвоєння змінній і має значення 64 000, яке виявляється поза діапазоном представлення чисел для типу short, і тому дані втрачаються. Приведення типів потрібне в обох випадках, оскільки неявне перетворення типу uint в тип short неможливе.

Далі змінній u присвоюється значення 64 000 змінній l типу long.

У цьому випадку дані не втрачаються, оскільки значення 64 000 виявляється поза діапазоном представлення чисел для типу uint . Але коли змінній u присвоюється значення -12, дані втрачаються, оскільки від'ємні числа також виявляються поза діапазоном представлення чисел для типу uint . Приведення типів потрібне в обох випадках, оскільки неявне перетворення типу long в тип uint неможливе.

І нарешті, коли змінній char присвоюється значення типу byte , інформація не втрачається, але приведення типів все ж потрібне.

2.2.15 Перетворення типів у виразу

Крім операцій присвоєння, конвертація типів відбувається і в самому виразі. У виразі можна вільно змішувати два або більше типи даних, за умови їх сумісності один з одним. Наприклад, в одному виразі допускається застосування типів short і long, оскільки обидва типи є числовими. Коли в виразі змішуються різні типи даних, вони перетворюються в один і той самий тип згідно з порядком операцій.

Конвертація типів виконується згідно з прийнятими в C# правилами просування типів. Нижче наведено алгоритм, визначений цими правилами для операцій з двома операндами.

ЯКЩО один операнд має тип decimal, ТО другий операнд просувається до типу decimal (але якщо другий операнд має тип floatабо double, результат буде неправильним).

ЯКЩО один операнд має тип double, ТО другий операнд просувається до типу double.

ЯКЩО один операнд має тип float, ТО другий операнд просувається до типу float.

ЯКЩО один операнд має тип ulong, ТО другий операнд просувається до типу ulong(але якщо другий операнд має тип sbyte, short, intабо long, результат буде неправильним).

ЯКЩО один операнд має тип long, ТО другий операнд просувається до типу long.

ЯКЩО один операнд має тип uint, а другий - тип sbyte, short або int, ТО обидва операнди просуваються до типу long.

ЯКЩО один операнд має тип uint, ТО другий операнд просувається до типу uint.

ІНАКШЕ обидва операнди просуваються до типу int.

Щодо правил продвиження типів необхідно зробити кілька важливих зауважень. По-перше, не всі типи можуть змішуватися в виразі. Зокрема, неявне перетворення типу float або double в тип decimal неможливе, як і змішування типу ulong з будь-яким цілочисельним типом зі знаком. Для змішування цих типів потрібне явне їх приведення.

По-друге, особливої уваги потребує останнє з наведених вище правил. Воно гласить: якщо жодне з попередніх правил не застосовується, то всі операнди переносяться до типу int. Отже, всі значення типу char, sbyte, byte, ushort і short переносяться до типу int для обчислення виразу. Таке перенесення типів називається цілочисельним. Це також означає, що результат виконання всіх арифметичних операцій матиме тип не нижче int.

Слід мати на увазі, що правила перенесення типів застосовуються лише до значень, якими операціють при обчисленні виразу. Так, якщо значення змінної типу byte переносяться до типу int всередині виразу, то поза виразом ця змінна все ще належить до типу byte. Перенесення типів стосується лише обчислення виразу.

Але просування типів іноді може призвести до неочікуваних результатів. Якщо, наприклад, в арифметичній операції використовуються два значення типу byte, то відбувається наступне. Спочатку операнди типу byte просуваються до типу int. А потім виконується операція, що дає результат типу int . Отже, результат виконання операції, в якій беруть участь два значення типу byte , буде мати тип int. Але це не той результат, який можна було б очікувати з очевидністю.

Розглянемо наступний приклад програми (лістинг 2.41).

Лістинг 2.42 – Приклад неочікуваного результату просування типів

// Приклад неочікуваного результату просування типів!

```csharp
using System;
class PromDemo
static void Main()
```

byte b;

b = 10;

b = (byte)(b * b); // Необхідне приведення типів!!

```csharp
Console.WriteLine("b: " + b);
```

Дивно, але коли результат обчислення виразу b*b присвоюється зворотно змінній b , виникає потреба в приведенні до типу byte! Це пояснюється тим, що в виразі b*b значення змінної b переміщується до типу int і тому не може бути присвоєне змінній типу byte без приведення типів. Майте це на увазі, якщо отримаєте неочікуване повідомлення про помилку несумісності типів в виразах, які, на перший погляд, здаються абсолютно правильними.

Аналогічна ситуація виникає при виконанні операцій з символьними операндами. Наприклад, у наступному фрагменті коду потрібне зворотне приведення до типу char, оскільки операнди ch1 і ch2 у виразі просуваються до типу int (лістинг 2.42).

Лістинг 2.43 – Приклад зворотного приведення

char ch1 = 'a', ch2 = 'b';

ch1 = (char) (ch1 + ch2);

Без приведення типів результат додавання операндів ch1і ch2 буде мати тип int, і тому його не можна присвоїти змінній типу char.

Просування типів відбувається і при виконанні унарних операцій, наприклад з унарним мінусом. Операнди унарних операцій меншого типу, ніж int(byte, sbyte, short і ushort), тобто з більш вузьким діапазоном представлення чисел, про двигаються до типу int. Те саме відбувається і з операндом типу char. Крім того, якщо виконується унарна операція заперечення значення типу uint, то результат про двигається до типу long.

2.2.16 Приведення типів у виразах

Приведення типів можна застосовувати і до окремих частин великого виразу. Це дозволяє точніше керувати перетвореннями типів при обчисленні виразу. Розглянемо наступний приклад програми, в якій виводяться квадратні корені чисел від 1 до 10 та окремо цілі та дробові частини кожного числового результату. Для цього в даній програмі застосовується приведення типів, завдяки якому результат, повернений методом Math.Sqrt(), перетворюється в тип int (лістинг 2.43).

Лістинг 2.44 – Приведення типів у виразах

// Приклад приведення типів у виразах.

```csharp
using System;
class CastExpr
static void Main()
```

double n;

```csharp
for (n = 1.0; n <= 10; n ++) {
Console.WriteLine("Квадратний корінь з {0} дорівнює {1}",
```

n, Math.Sqrt(n));

```csharp
Console.WriteLine("Ціла частина числа: (0)",
```

(int)Math.Sqrt(n));

```csharp
Console.WriteLine("Дробова частина числа:(0)",
```

Math.Sqrt(n) - (int)Math.Sqrt(n));

```csharp
Console.WriteLine();
```

Ось як виглядає результат виконання цієї програми.

Квадратний корінь з дорівнює 1

Ціла частина числа: 1

Дробова частина числа: 0

Квадратний корінь з дорівнює 1.4142135623731

Ціла частина числа: Дробова частина числа1: 0.414213562373095

Квадратний корінь з дорівнює 1.73205080756888

Ціла частина числа: 1 Дробова частина числа: 0.732050807568877

Квадратний корінь з дорівнює 2

Ціла частина числа: 2

Дробова частина числа: 0

Квадратний корінь з дорівнює 2.23606797749979

Ціла частина числа: 2 Дробова частина числа: 0.23606797749979

Квадратний корінь з дорівнює 2.44948974278318

Ціла частина числа: 2 Дробова частина числа: 0.449489742783178

Квадратний корінь з дорівнює 2.64575131106459

Ціла частина числа: 2 Дробова частина числа: 0.645751311064591

Квадратний корінь з дорівнює 2.82842712474619

Ціла частина числа: 2 Дробова частина числа: 0.82842712474619

Квадратний корінь з дорівнює 3

Ціла частина числа: 3

Дробова частина числа: 0

Квадратний корінь з дорівнює 3.16227766016838

Ціла частина числа: 3 Дробова частина числа: 0.16227766016838

Як бачите, приведення результату, що повертає методMath.Sqrt(), до типу int дозволяє отримати цілу частину числа. Так, у виразі Math.Sqrt(n) - (int) Math.Sqrt(n),

приведення до типу int дає цілу частину числа, яка потім віднімається від всього числа, і в результаті отримується дробова його частина. Отже, результат обчислення цього виразу має тип double. Але до типу int приводиться лише значення, повернене другим методом Math.Sqrt().


---

[◀️ До змісту](../README.md)
