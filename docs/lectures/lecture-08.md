# Детальніше про методи та класи

[◀️ До змісту лекцій](README.md)

---

У цьому розділі продовжується розгляд класів і методів. Він починається з пояснення механізму управління доступом до членів класу. А потім обговорюються такі питання, як передача і повернення об'єктів, перевантаження методів, різні форми методу Main(), рекурсія і застосування ключового слова static.

8.1 Керування доступом до членів класу

Підтримка властивості інкапсуляції в класі надає два основні переваги. По-перше, клас пов'язує дані з кодом. І по-друге, клас надає засоби для управління доступом до його членів. Саме ця друга основна особливість і буде розглянута нижче.

У мові C# фактично існують два типи членів класу: відкриті та закриті, хоча насправді це трохи складніше. Доступ до відкритого члена вільно здійснюється з коду, що визначений поза класом. Саме цей тип члена класу використовувався в розглянутих до цього прикладах програм. А закритий член класу доступний лише методам, що визначені в самому класі. За допомогою закритих членів організується керування доступом.

Обмеження доступу до членів класу є основоположним етапом об'єктно орієнтованого програмування, оскільки дозволяє уникнути неправильного використання об'єкта. Дозволяючи доступ до закритих даним тільки за допомогою строго визначеного ряду методів, можна запобігти присвоєнню невірних значень цим даним, виконуючи, наприклад, перевірку діапазону представлення чисел. Для закритого члена класу не можна задати значення непосередньо в коді за межами класу. Але в той же час можна повністю керувати тим, як і коли дані використовуються в об'єкті. Отже, правильно реалізований клас утворює певну "чорну скриньку", якою можна користуватися, але внутрішній механізм його дії закритий для втручання ззовні.

8.2 Модифікатори доступу

Керування доступом в мові C# організується за допомогою чотирьох модифікаторів доступу: public , private , protected і internal . У цій главі основна увага приділяється модифікаторам доступу public і private . Модифікатор protected застосовується тільки в тих випадках, які пов'язані з успадкуванням. А модифікатор internal використовується в основному для збірки, яка в широкому розумінні означає в C# розгорнуту програму або бібліотеку. Коли член класу позначається специфікатором public, він стає доступним з будь-якого іншого коду в програмі, включаючи методи, визначені в інших класах. Коли ж член класу позначається специфікатором private , він може бути доступни лише іншим членам цього класу. Отже, методи з інших класів не мають доступу до закритого члена ( private ) даного класу. Як пояснювалося в розділі 6, якщо жоден зі специфікаторів доступу не вказаний, член класу вважається закритим для свого класу за замовчуванням. Тому при створенні закритих членів класу специфікатор private вказувати для них необов'язково. Специфікатор доступу вказується перед рештою опису типу окремого члена. Це означає, що саме з нього повинен починатися оператор оголошення члена класу. Нижче наведено відповідні приклади.

Лістинг 8.1 - Приклад коду із різними правами доступу

```csharp
using System; class MyClass { private int alpha; // закритий доступ, вказується явно int beta; // закритий доступ за замовчуванням public int gamma; // відкритий доступ // Методи, яким доступні члени alpha та beta даного класу. // Член класу може мати доступ до закритого члена цього ж класу. public void SetAlpha(int а) { alpha = а; } public int GetAlpha() { return alpha; } public void SetBeta(int a) { beta = a; } public int GetBeta() { return beta; } }
```

8.3 Організація закритого і відкритого доступу

Правильна організація закритого і відкритого доступу — запорука успіху в об'єктно орієнтованому програмуванні. І хоча для цього не існує твердо встановлених правил, нижче перераховано ряд загальних принципів, які можуть служити в якості керівництва до дії.

• Члени, використовувані тільки в класі, повинні бути закритими.

• Дані екземпляра, що не виходять за визначені межі значень, повинні бути закритими, а при організації доступу до них за допомогою відкритих методів слід виконувати перевірку діапазону представлення чисел.

• Якщо зміна члена призводить до наслідків, які поширюються за межі області дії самого члена, тобто впливають на інші аспекти об'єкта, то цей член повинен бути закритим, а доступ до нього - контрольованим.

• Члени, здатні завдати шкоди об'єкту, якщо вони використовуються неправильно, повинні бути закритими. Доступ до цих членів слід організувати за допомогою відкритих методів, що виключають неправильне їх використання.

• Методи, що отримують і встановлюють значення закритих даних, повинні бути відкритими.

• Змінні екземпляра дозволяється робити відкритими лише у випадку, якщо немає жодних підстав для того, щоб вони були закритими.

Звичайно, існує багато ситуацій, на які наведені вище принципи не поширюються, а в особливих випадках один або кілька цих принципів можуть взагалі порушуватися. Але в цілому, дотримуючись цих правил, ви зможете створювати об'єкти, стійкі до спроб неправильного їх використання.

8.4 Передача об'єктів методам за посиланням

У раніше наведених прикладах програми, коли були вказані параметри, передавані методам, використовувалися значні типи, наприклад int або double . Але в методах також можна використовувати параметри посилання, що не тільки правильно, але й досить поширено в ООП. Аналогічним чином об'єкти можуть бути передані методам за посиланням. Як приклад розглянемо наступну програму.

Лістинг 8.2 - Приклад передачі об'єктів методам за посиланням

```csharp
using System; class MyClass { int alpha, beta; public MyClass(int i, int j) { alpha = i; beta = j; } // Повернути значення true, якщо параметр ob // має ті ж значення, що й викликаючий об'єкт. public bool SameAs(MyClass ob) { if((ob.alpha == alpha) & (ob.beta == beta)) return true; else return false; } // Зробити копію об'єкта ob. public void Copy(MyClass ob) { alpha = ob.alpha; beta = ob.beta; } public void Show() { Console.WriteLine("alpha: (0), beta: (1}", alpha, beta); } } class PassOb { static void Main() { MyClass ob1 = new MyClass(4, 5); MyClass ob2 = new MyClass(6, 7); Console.Write("ob1: "); ob1.Show(); Console.Write("ob2: "); ob2.Show(); if(ob1.SameAs(ob2)) Console.WriteLine("ob1 і ob2 мають однакові значення."); else Console.WriteLine("ob1 і ob2 мають різні значення."); Console.WriteLine(); // А тепер зробити об'єкт ob1 копією об'єкта ob2. ob1.Copy(ob2); Console.Write("ob1 після копіювання: "); ob1.Show(); if(ob1.SameAs(ob2)) Console.WriteLine("ob1 і ob2 мають однакові значення."); else Console.WriteLine("ob1 і ob2 мають різні значення."); } }
```

Кожен з методів SameAs()і Сору()у вищезазначеній програмі отримує посилання на об'єкт типу MyClassяк аргумент. Метод SameAs()порівнює значення змінних екземпляра alphaі betaу викликаючому об'єкті зі значеннями аналогічних змінних в об'єкті, переданому через параметр ob. Цей метод повертає логічне значення true тільки у випадку, якщо обидва об'єкти мають однакові значення цих змінних екземпляра. А метод Сору() присвоює значення змінних alphaі betaз об'єкта, переданого по посиланню через параметр ob, змінним alpha і beta у викликаючому об'єкті. Як показує цей приклад, з точки зору синтаксису об'єкти передаються методам по посиланню так само, як і значення звичайних типів.

8.5 Способи передачі аргументів методу

Як показує вищезазначений приклад, передача об'єкта методу за посиланням робиться досить просто. Але в цьому прикладі не показані всі нюанси даного процесу. У деяких випадках наслідки передачі об'єкта за посиланням будуть відрізнятися від результатів, до яких призводить передача значення звичайного типу.

Для вияснення причин цих відмінностей розглянемо два способи передачі аргументів методу. Першим способом є виклик за значенням. У цьому випадку значення аргумента копіюється в формальний параметр методу.. Отже, зміни, внесені в параметр методу, не впливають на аргумент, використаний для ви

клику. А другим способом передачі аргумента є виклик за посиланням. У цьому випадку параметру методу передається посилання на аргумент, а не значення аргумента. У методі це посилання використовується для доступу до конкретного аргументу, вказаного при ви клику.

Це означає, що зміни, внесені в параметр, будуть впливати на аргумент, використаний для виклику методу. За замовчуванням в C# використовується передача за значенням, що означає, що створюється копія аргументу і передається приймаючому параметру. Отже, при передачі значення звичайного типу, наприклад int або double , все, що відбувається з параметром, що приймає аргумент, не має жодного впливу за межами методу. Як приклад розглянемо наступну програму.

Лістинг 8.3 - Передача аргументів звичайних типів за значенням

```csharp
using System; class Test { /* Цей метод не має жодного впливу на аргументи, що використовуються для його виклику. */ public void NoChange(int i, int j) { i = i + j; j = ++j; } } class CallByValue { static void Main() { Test ob = new Test(); int a = 15, b = 20; Console.WriteLine("а і b до виклику: " + a + " " + b); ob.NoChange(a, b); Console.WriteLine("а і b після виклику: " + a + " " + b); } }
```

Як бачите, операції, виконувані в методі NoChange(), не мають жодного

впливу на значення аргументів аі b, використовуваних для виклику цього методу. Це знову пояснюється тим, що параметрам i і j передані копії значень аргументів а і b, а самі аргументи а і b зовсім не залежать від параметрів i і j.

Зокрема, присвоєння параметру i нового значення не матиме жодного впливу на аргумент а. Справа трохи ускладнюється при передачі методу посилання на об'єкт. У цьому випадку саме посилання все ще передається за значенням. Отже, створюється копія посилання, а зміни, внесені в параметр, не впливають на аргу мент. (Так, якщо організувати посилання параметра на новий об'єкт, то ця зміна не призведе до наслідків для об'єкта, на який посилається аргумент).

Але головна відмінність виклику за посиланням полягає в тому, що зміни, які відбуваються з об'єктом, на який посилається параметр, впливатимуть на той об'єкт, на який посилається аргумент. Спробуємо з'ясувати причини подібного впливу. Нагадаємо, що при створенні змінної типу класу формується лише посилання на об'єкт. Тому при передачі цього посилання методу, що його приймає параметр буде посилатися на той самий об'єкт, на який посилається аргумент.

Це означає, що як аргумент, так і параметр посилаються на один і той самий об'єкт і що об'єкти, по суті, передаються методам посиланням. Отже, об'єкт в методі буде впливати на об'єкт, що використовується як аргумент. Для прикладу розглянемо наступну програму.

Лістинг 8.4 - Передача об'єктів посиланням.

```csharp
using System; class Test { public int a, b; public Test(int i, int j) { a = i; b = j; } /* Передати об'єкт. Тепер змінні ob.а і ob.b з об'єкта використаного при виклику методу, будуть зміне,ні. */ public void Change(Test ob) { ob.a = ob.a + ob.b; ob.b = ++ob.b; } } class CallByRef { static void Main() { Test ob = new Test(15, 20); Console.WriteLine("ob.а і ob.b до виклику: " + ob.a + " " + ob.b); ob.Change(ob); Console.WriteLine("ob.а і ob.b після виклику: " + ob.a + " " + ob.b); } }
```

Як бачите , дії в методі Change() показали в даному випадку вплив на об'єкт, що використовувався як аргумент. Так, підведемо короткий підсумок. Коли об'єкт передається методу за посиланням, саме посилання передається за значенням, і, отже, створюється копія цього посилання.

Але ця копія все ще буде посилатися на той самий об'єкт, що і відповідний аргумент. Це означає, що об'єкти передаються методам неявним чином за посиланням.

8.6 Використання модифікаторів параметрів ref і out

Як пояснювалося вище, аргументи простих типів, наприклад int або char передаються методу за значенням. Це означає, що зміни, внесені в параметр, що приймає значення, не будуть мати жодного впливу на аргумент, використаний для виклику. Але таку поведінку можна змінити, використовуючи ключові слова ref і out для передачі значень звичайних типів за посиланням. Це дозволяє змінити в самому методі аргумент, вказаний при його виклику. Перш ніж переходити до особливостей використання ключових слів ref і out, корисно зрозуміти причини, чому значення простого типу іноді потрібно передавати за посиланням. Загалом, для цього існують дві причини: дозволити методу змінити вміст його аргументів або повернути кілька значень. Розглянемо кожну з цих причин більш детально. даються за значенням, то, використовуючи вибраний в C# за замовчуванням механізм виклику за значенням для передачі аргумента параметру, неможливо написати метод, що змінює місцями значення двох його аргументів, наприклад типу int . Цю складність роз рішує модифікатор ref .

Як вам вже повинно бути відомо, значення повертається з методу викликаючої частини програми за допомогою оператора return . Але метод може одночасно повернути лише одне значення. А що, якщо з методу потрібно повернути два або більше фрагменти інформації, наприклад, цілу і дробову частини числового значення з плаваючою точкою? Такий метод можна написати, використовуючи модифікатор out .

Модифікатор параметра ref примусово організовує виклик за посиланням, а не за значенням. Цей модифікатор вказується як при оголошенні, так і при викликуметоду. Для початку розглянемо простий приклад. У наведеній нижче програмі створюється метод Sqr(), який повертає замість свого аргумента квадрат його цілочисельного значення. Зверніть особливу увагу на застосування та розташування модифікато ра ref.

Лістинг 8.5 - Приклад використання оператора ref

```csharp
using System; class RefTest { // Цей метод змінює свій аргумент. Зверніть // увагу на використання модифікатора ref. public void Sqr(ref int i) { i = i * i; } } class RefDemo { static void Main() { RefTest ob = new RefTest(); int a = 10; Console.WriteLine("до виклику: " + a); ob.Sqr(ref a); // зверніть увагу на використання модифікатора ref Console.WriteLine("після виклику: " + а); } }
```

Як бачите, модифікатор refвказується перед оголошенням параметра в самому методі і перед аргументом при виклику методу. Нижче наведено результат виконання даної програми, який підтверджує, що значення аргумента а дійсно було змінено за допомогою методу Sqr() до виклику 10 після виклику 100.

Тепер, використовуючи модифікатор ref , можна написати метод, який переміщує значення двох своїх аргументів простого типу. Нижче наведено програму якприклад, в якій метод Swap() виконує обмін значеннями двох своїх цілих аргументів при виклику.

Лістинг 8.6 - Обміняти місцями два значення.

```csharp
using System; class ValueSwap { // Цей метод обмінює свої аргументи місцями. public void Swap(ref int a, ref int b) { int t; t = a; a = b; b = t; } } class ValueSwapDemo { static void Main() { ValueSwap ob = new ValueSwap(); int x = 10, у = 20; Console.WriteLine("x і у до виклику: " + х + " " + у); ob.Swap(ref х, ref у); Console.WriteLine("х і у після виклику: " + х + " " + у); } }
```

Щодо модифікатора ref слід мати на увазі наступне. Аргументу, переданому за посиланням за допомогою цього модифікатора, повинно бути присвоєно значення до виклику методу. Справа в тому, що в методі, який отримує такий аргумент як параметр, передбачається, що параметр посилається на дійсне значення. Отже, при використанні модифікатора ref в методі не можна задати початкове значення аргумента.

Іноді посилальний параметр потрібно використовувати для отримання значення з методу, а не для передачі йому значення. Припустимо, що є метод, який виконує певну функцію, наприклад, відкриття мережевого сокету і повернення коду успішнго або невдачного завершення даної операції в якості посилального параметра.

У цьому випадку методу не передається жодної інформації, але в той же час він повинен повернути певну інформацію. Головна складність при цьому полягає в тому, методу. Отже, щоб скористатися параметром типу ref , доведеться задати для аргумента фіктивне значення і таким чином подолати дане обмеження. Справді, в C# є більш підходящий варіант виходу з подібної складності — скористатися модифікатором параметра out .

Модифікатор параметра out схожий на модифікатор ref , за винятком одного: він служить лише для передачі значення поза межі методу. Тому змінній, що використовується як параметр out , не потрібно (і навіть непотрібно) присвоювати яке-небудь значення. Більше того, в методі параметр out вважається неініціалізованим, тобто припускається, що він не має початкового значення.

Це означає, що значення повинно бути присвоєне даному параметру в методі до його завершення. Отже, після виклику методу параметр out буде містити яке-небудь значення. Нижче наведено приклад застосування модифікатора параметра out. У цьому прикладі програми для розділення числа з плаваючою точкою на цілу і дробову частини використовується метод GetParts() з класу Decompose. Зверніть увагу на те, як повертається кожна частина початкового числа.

Лістинг 8.7 - Використовувати модифікатор параметра out.

```csharp
using System; class Decompose { /* Розділити числове значення з плаваючою точкою на цілу і дробову частини. */ public int GetParts(double n, out double frac) { int whole; whole = (int) n; frac = n % whole; // передати дробову частину числа через параметр frac return whole; // повернути цілу частину числа } } class UseOut { static void Main() { Decompose ob = new Decompose(); int i; double f; i = ob.GetParts(10.125, out f); Console.WriteLine("Ціла частина числа дорівнює " + i); Console.WriteLine("Дробова частина числа дорівнює " + f); } }
```

Застосування модифікаторів ref і out не обмежується лише передачею значе нь звичайних типів. За допомогою них також можна передавати посилання на об'єкти. Якщо модифікатор ref або out вказує на посилання, то саме посилання передається за посиланням.

Це дозволяє змінити в методі об'єкт, на який вказує посилання. Розглянемо як приклад наступну програму, в якій посилальні параметри типу ref використовуються для зміни об'єктів, на які вказують посилання.

Лістинг 8.8 - Поміняти місцями дві посилання.

```csharp
using System; class RefSwap { int a, b; public RefSwap(int i, int j) { a = i; b = j; } public void Show() { Console.WriteLine("a: {0}, b: {l}", a, b); } // Цей метод змінює свої аргументи. public void Swap(ref RefSwap ob1, ref RefSwap ob2) { RefSwap t; t = ob1; ob1 = ob2; ob2 = t; } } class RefSwapDemo { static void Main() { RefSwap x = new RefSwap(1, 2); RefSwap у = new RefSwap(3, 4); Console.Write("x до виклику: "); x.Show(); Console.Write("у до виклику: "); у.Show(); Console.WriteLine(); // Зміна об'єктів, на які посилаються аргументи х і у. х.Swap(ref х, ref у); Console.Write("х після виклику: "); х.Show(); Console.Write("у після виклику: "); у.Show(); } }
```

У цьому прикладі в методі Swap() виконується зміна об'єктів, на які посилаються два його аргументи. До виклику методу Swap() аргумент х посилається на об'єкт, що містить значення 1 і 2, тоді як аргумент у посилається на об'єкт, що містить значення 3 і 4. А після виклику методу Swap() аргумент х посилається на об'єкт, що містить значення 3 і 4, тоді як аргумент у посилається на об'єкт, що містить значення 1 і 2. Якби не параметри типу ref , то перестановка в методі Swap() не мала б жодних наслідків поза межами цього методу. Щоб переконатися в цьому, виключіть параметри типу ref з методу Swap().

8.7 Перевантаження методів

У C# дозволяється спільне використання одного і того ж імені двома або більше методами одного і того ж класу, за умови, що їх параметри оголошуються порізному. У цьому випадку говорять, що методи перевантажуються, а сам процес називається перевантаженням методів. Перевантаження методів відноситься до одного з способів реаліза ції поліморфізму в C#.

Загалом, для перевантаження методу достатньо оголосити різні його варіанти, а решта поклопочеться компілятор. Але при цьому необхідно дотриматися наступної важливої умови: тип або кількість параметрів у кожного методу повинні бути різними Зовсім недостатньо, щоб два методи відрізнялися лише типами повертаємих значень. Вони повинні також відрізнятися типами або кількістю своїх параметрів. (В будь-якому випадку, типи повертаємих значень надають недостатньо інформації компілятору C#, щоб вирішити, який саме метод слід використовувати).

Звичайно, перевантажувані методи можуть відрізнятися і типами повертаємих значень. Коли викликається перевантажуваний метод, то виконується той його варіант, параметри якого відповідають (за типом і кількістю) переданим аргументам.

Лістинг 8.9 - Приклад перевантаження методів.

```csharp
using System; class Overload { public void OvlDemo() { Console.WriteLine("Без параметрів"); } public int OvlDemo(int a) { Console.WriteLine("З параметром int"); return a; } public double OvlDemo(double a, double b) { Console.WriteLine("З двума парамтероами дабл параметрів"); return a + b; } }
```

Перевантаження методів підтримує властивість поліморфізму, оскільки саме таким способом в C# реалізується головний принцип поліморфізму: один інтерфейс множина методів. Щоб краще зрозуміти, як це робиться, звернемося до конкретного прикладу. У мовах програмування, які не підтримують перевантаження методів, кожному методу повинно бути присвоєне унікальне ім'я. Але в програмуванні часто виникає потреба реалізувати по суті один і той самий метод для обробки різних типів даних. Припустимо, що потрібна функція, яка визначає абсолютне значення. У мовах, які не підтримують перевантаження методів, зазвичай доводиться створювати три або більше варіантів такої функції з дещо відрізняю чимися, але все ж різними іменами. Наприклад, у С функція abs() повертає аб солютне значення цілого числа, функція labs() — абсолютне значення довгого цілого числа, а функція fabs() — абсолютне значення числа з плаваючою точністю звичайної (одинарної) точності.

8.8 Необов'язкові аргументи

У версії C# 4.0 впроваджено новий засіб, що покращує зручність вказання аргументів при виклику методу. Цей засіб називається необов'язковими аргументами і дозволяє визначити значення за замовчуванням для параметра методу.

Дане значення буде використовуватися за замовчуванням у випадку, якщо для параметра не вказано відповідний аргумент при виклику методу. Отже, вказувати аргумент для такого параметра не обов'язково. Необов'язкові аргументи дозволяють спростити виклик методів, де до деяких параметрів застосовуються аргументи, вибирані за замовчуванням. Їх також можна використовувати як "скорочену" форму перевантаження методів.

Застосування необов'язкового аргумента дозволяється при створенні необов'язкового параметра. Для цього достатньо вказати використовуване за замовчуванням значення па раметра за допомогою синтаксису, аналогічного ініціалізації змінної. Використо вуване за замовчуванням значення повинно бути константним виразом. В якості прикладу розглянемо наступне визначення методу.

```csharp
static void OptArgMeth(int alpha, int beta=10, int gamma = 20)
```

У цьому рядку коду оголошуються два необов'язкові параметри: beta і gamma, при чому параметру beta за замовчуванням присвоюється значення 10, а параметру gamma — значення 20. Ці значення використовуються за замовчуванням, якщо для даних параметрів не вказуються аргументи при виклику методу. Також слід мати на увазі, що параметр alpha не є необов'язковим. Навпаки, це звичайний параметр, для якого завжди потрібно вказувати аргумент. Беручи до уваги наведене вище оголошення методу OptArgMeth(),

останній можна викликати наступними способами.

// Передати всі аргументи явним чином.

OptArgMeth(1, 2, 3);

// Зробити аргумент гамма необов'язковим.

OptArgMeth(1, 2);

// Зробити обидва аргументи бета і гамма необов'язковими.

OptArgMeth(1);

8.9 Застосування ключового слова static

Іноді потрібно визначити такий член класу, який буде використовуватися незалежно від усіх інших об'єктів цього класу. Зазвичай доступ до члена класу організовується за допомогою об'єкта цього класу, але в той же час можна створити член класу для самостійного застосування без посилання на конкретний екземпляр об'єкта. Для того, щоб створити такий член класу, достатньо вказати на початку його оголошення ключове слово static . Якщо член класу оголошується як static, то він стає доступним до створення будь-яких об'єктів свого класу і без посилання на який-небудь об'єкт. За допомогою ключового слова static можна оголошувати як змінні, так і методи.

Найхарактернішим прикладом члена типу static є метод Main(), який оголошується таким через те, що його повинна викликати операційна система на початку виконуваної програми. Щоб скористатися членом типу static поза межами класу, потрібно вказати ім'я цього класу з оператором-крапкою. Але для цього не потрібно створювати об'єкт. Насправді член типу static доступний не за посиланням на об'єкт, а за ім'ям свого класу. Так, якщо потрібно присвоїти значення 10 змінній count типу static , яка є членом класу Timer , то для цього можна скористатися наступним рядком коду.

Timer.count = 10;

Ця форма запису схожа на ту, що використовується для доступу до звичайних змінних екземпляра за допомогою об'єкта, але в ній вказується ім'я класу, а не об'єкта. Аналогічним чином можна викликати метод типу static, використовуючи ім'я класу та оператор-крапку.

Змінні, оголошені як static , по суті, є глобальними. Коли ж об'єкти оголошуються у своєму класі, то копія змінної типу static не створюється. Замість цього всі екземпляри класу спільно користуються однією й тією самою змінної типу static . Така змінна ініціалізується перед її застосуванням у класі.

Коли ж її ініціалізатор не вказаний явно, то вона ініціалізується нульовим значенням, якщо належить до числового типу даних, пустим значенням, якщо належить до посилального типу, або логічним значенням false , якщо належить до типу bool. Отже, змінні типу static завжди мають якусь значення.

Метод типу static відрізняється від звичайного методу тим, що його можна викликати за ім'ям його класу, не створюючи екземпляр об'єкта цього класу. Приклад такого виклику вже наводився раніше. Це був метод Sqrt() типу static, що належить до класу System.Math зі стандартної бібліотеки класів C#. Нижче наведено приклад програми, в якій оголошуються змінна і метод типу static.

Лістинг 8.10 - Приклад static.

```csharp
using System; class StaticDemo { // Змінна типу static. public static int Val = 100; // Метод типу static. public static int ValDiv2() { return Val/2; } } class SDemo { static void Main() { Console.WriteLine("Початкове значення змінної " + "StaticDemo.Val дорівнює " + StaticDemo.Val); StaticDemo.Val = 8; Console.WriteLine("Поточне значення змінної" + "StaticDemo.Val дорівнює " + StaticDemo.Val); Console.WriteLine("StaticDemo.ValDiv2(): " + StaticDemo.ValDiv2()); } }
```

9. Перевантаження операторів

У мові C# допускається визначати призначення оператора щодо створюваного класу. Цей процес називається перевантаженням операторів. Завдяки перевантаженню розширюється сфера застосування оператора в класі. При цьому дія оператора повністю контролюється і може змінюватися залежно від конкретного класу . Наприклад, оператор + може використовуватися для введення об'єкта в зв'язаний список в одному класі, де визначається такий список, тоді як в іншому класі його призначення може бути зовсім іншим. Коли оператор перевантажується, жодне з його початкових призначень не втрачається. Він просто виконує ще одну, нову операцію щодо конкретного об'єкта. Тому перевантаження оператора + , наприклад, для обробки зв'язаного списку не змінює його призначення щодо цілих чисел, тобто до їх додавання. Головна перевага перевантаження операторів полягає в тому, що воно дозволяє плавно інтегрувати клас нового типу в середовище програмування. Такий розширюваність типів є важливою складовою ефективності такої об'єктно орієнтованої мови програмування, як С#. Як тільки для класу визначаються оператори, з'являється можливість оперувати об'єктами цього класу, використовуючи звичайний синтаксис виразів в С#. Перевантаження операторів є одним з найсильніших аспектів мови С#.

9.1 Основи перевантаження операторів

Перевантаження операторів тісно пов'язане з перевантаженням методів. Для перевантаження оператора використовується ключове слово operator , що визначає метод оператора, який, у свою чергу, визначає дію оператора щодо свого класу. Існують дві форми операторних методів ( operator ): одна - для унарних операторів, інша - для бінарних. Нижче наведена загальна форма для кожного виду цих методів.

// Загальна форма перевантаження унарного оператора.

public static повертаємий_тип operator(тип_параметра операнд)

// операції

// Загальна форма перевантаження бінарного оператора.

public static повертаємий_тип operator(тип_параметра1 операнд1, тп операнд2)

// операції

Тут замість або підставляється перевантажуваний оператор, наприклад + або / ; а повертаємий_тип означає конкретний тип значення, яке повертається вказаною операцією. Це значення може бути будь-якого типу, але часто воно вказується такого ж типу, як і у класі, для якого перевантажується оператор. Така кореляція спрощує застосування перевантажуваних операторів у виразах. Для унарних операторів операнд означає передаваний операнд, а для бінарних операторів те саме означають операнд1 і операнд2 . Зверніть увагу, що операторні методи повинні мати обидва типи, public та static . Тип операнда унарних операторів повинен бути таким самим, як і у класу, для якого перевантажується оператор. А в бінарних операторах хоча б один з операндів повинен бути такого ж типу, як і у його класу. Отже, в C# не допускається перевантаження будьяких операторів для об'єктів, які ще не були створені. Наприклад, призначення оператора + не можна перевизначити для елементів типу int або string . І ще одне зауваження: в параметрах оператора не можна використовувати модифікатор ref або out.

9.2 Перевантаження бінарних операторів

Для того щоб продемонструвати принцип дії перевантаження операторів, почнемо з простого прикладу, в якому перевантажуються два оператори — + і - . У наведеній нижче програмі створюється клас ThreeD , що містить координати об'єкта у тривимірному просторі. Перевантажуваний оператор + додає окремі координати одного об'єкта типу ThreeD з координатами іншого. А перевантажуваний оператор - віднімає координати одного об'єкта від координат іншого.

Лістинг 9.1 - Приклад перевантаження бінарних операторів.

```csharp
using System;
```

// Клас для зберігання тривимірних координат.

```csharp
class ThreeD
```

int х, у, z; // тривимірні координати

```csharp
public ThreeD() { x = y = z = 0; }
public ThreeD(int i, int j, int k) { x = i; y = j; z = k; }
```

// Перевантажити бінарний оператор +.

public static ThreeD operator +(ThreeD op1, ThreeD op2)

ThreeD result = new ThreeD();

/* Додати координати двох точок і повернути результат. */

result.x = op1.x + op2.x; // Ці оператори виконують

result.y = op1.y + op2.y; // цілочисельне додавання,

result.z = op1.z + op2.z; // зберігаючи своє початкове призначення.

return result;

// Перевантажити бінарний оператор –.

public static ThreeD operator -(ThreeD op1, ThreeD op2)

ThreeD result = new ThreeD();

/* Зверніть увагу на порядок слідування операндів:

op1 - лівий операнд, а op2 - правий операнд. */

result.x = op1.x - op2.x; // Ці оператори

result.y = op1.y - op2.y; // виконують цілочисельне

result.z = op1.z - op2.z; // віднімання

return result;

// Вивести координати X, Y, Z.

public void Show()

```csharp
Console.WriteLine(x + ", " + y + ", " + z);
```

9.3 Перевантаження унарних операторів

Унарні оператори перевантажуються так само, як і бінарні. Головна відмінність полягає, звичайно, в тому, що вони мають лише один операнд. Як приклад наведено нижче метод, який перевантажує оператор унарного мінуса для класу ThreeD .

Лістинг 9.2 - Перевантажити оператор унарного мінуса.

public static ThreeD operator - (ThreeD op)

ThreeD result = new ThreeD ();

result.x = -op.x;

result.у = -op.у;

result.z = -op.z;

return result;

У цьому прикладі створюється новий об'єкт, в полях якого зберігаються від'ємні значення операнда перевантажуваного унарного оператора, після чого цей об'єкт повертається операторним методом. Зверніть увагу на те, що сам операнд не змінюється. Це означає, що і в даному випадку зберігається звичайне призначення оператора унарного мінуса. Наприклад, результатом виразу а = -b є від'ємне значення операнда b, але сам операнд bне змінюється. У C# перевантаження операторів ++ і -- здійснюється досить просто. Для цього достатньо повернути інкрементоване або декрементоване значення, але не змінювати викликаючий об'єкт. А все інше візьме на себе компілятор C#, роз розрізняючи префіксні і постфіксні форми цих операторів. Як приклад нижче наведено операторний методoperator++()для класу ThreeD.

Лістинг 9.3 - Перевантажити унарний оператор ++.

public static ThreeD operator ++(ThreeD op)

ThreeD result = new ThreeD();

// Повернути результат інкрементування.

result.x = op.x + 1;

result.у = op.у + 1;

result.z = op.z + 1;

return result;

9.3 Виконання операцій з вбудованими типами даних в C#

Для будь-якого заданого класу та оператора також є можливість перевантажити сам операторний метод. Це, зокрема, потрібно для того, щоб дозволити операції з типом класу та іншими типами даних, включаючи вбудовані. Знову звернемося до класу ThreeD. На прикладі цього класу раніше було показано, як оператор + перевантажується для додавання координат одного об'єкта типу ThreeD з координатами іншого. Але це далеко не єдиний спосіб визначення операції додавання для класу ThreeD. Так, було б не менш корисно додати ціле значення до кожної координати об'єкта типу ThreeD. Подібна операція була б корисною для переміщення осей координат. Але для її виконання доведеться перевантажити оператор + ще раз, як показано нижче.

Лістинг 9.4 - Перевантажити бінарний оператор + для додавання об'єкта

public static ThreeD operator +(ThreeD op1, int op2)

ThreeD result = new ThreeD();

result.x = op1.x + op2;

result.у = op1.y + op2;

result.z = op1.z + op2;

return result;

Як бачите, другий параметр операторного методу має тип int. Отже, у цьому методі дозволяється додавання цілого значення до кожного поля об'єкта типу ThreeD. Така операція цілком допустима, оскільки, як пояснювалося вище, при перевантаженні бінарного оператора один з його операндів повинен бути того ж типу, що і клас, для якого цей оператор перевантажується. Але у другого операнда цього оператора може бути будь-який інший тип.

9.4 Перевантаження операторів відношення

Оператори відношення, наприклад == і < , також можуть бути перевантажені, і це дуже просто. Зазвичай, перевантажений оператор відношення повертає ло гічне значення true і false . Це повністю відповідає правилам звичайного застосування подібних операторів і дозволяє використовувати їх перевантажувані варіанти в умовних виразах. Якщо повертається результат іншого типу, то цим суттєво обмежується застосування операторів від відношення. Нижче наведено наступний варіант класу ThreeD , в якому перевантажуються оператори < і > . У цьому прикладі ці оператори використовуються для порівняння об'єктів ThreeD , виходячи з їх відстані до початку координат. Один об'єкт вважається більшим іншого, якщо він знаходиться далі від початку координат. А крім того, один об'єкт вважається меншим іншого, якщо він знаходиться ближче до початку координат. Такий варі ант реалізації дозволяє, зокрема, визначити, яка з двох заданих точок на ходиться на більшій сфері. Якщо ж жоден з операторів не повертає логічне значення true , то обидві точки знаходяться на одній і тій же сфері. Звичайно, можливі і інші алгоритми упорядкування.

Лістинг 9.5 - Перевантажити оператори < і >.

```csharp
using System;
```

// Клас для зберігання тривимірних координат.

```csharp
class ThreeD
```

int х, у, z; // тривимірні координати

```csharp
public ThreeD() { x = y = z = 0; }
public ThreeD(int i, int j, int k) { x = i; y = j; z = k; }
```

// Перевантажити оператор <.

public static bool operator <(ThreeD op1, ThreeD op2)

if (Math.Sqrt(op1.x * op1.x + op1.y * op1.y + op1.z * op1.z) <

Math.Sqrt(op2.x * op2.x + op2.у * op2.y + op2.z * op2.z))

return true;

else

return false;

// Перевантажити оператор >.

public static bool operator >(ThreeD op1, ThreeD op2)

if (Math.Sqrt(op1.x * op1.x + op1.y * op1.y + op1.z * op1.z) >

Math.Sqrt(op2.x * op2.x + op2.у * op2.у + op2.z * op2.z))

return true;

else

return false;

// Вивести координати X, Y, Z.

public void Show()

```csharp
Console.WriteLine(x + ", " + y + ", " + z);
```

9.5 Перевантаження операторів true і false

Ключові слова true і false також можна використовувати як унарні опера тори для цілей перевантаження. Перевантажувані варіанти цих операторів дозволяють визначити призначення ключових слів true і false спеціально для створюваних класів . Після перевантаження цих ключових слів як унарних операторів для конкретного класу з'являється можливість використовувати об'єкти цього класу для керування операторами if , while , for і do while або ж у умовному виразі ? . Оператори true і false повинні перевантажуватися попарно, а не окремо. Нижче наведена загальна форма перевантаження цих унарних операторів.

```csharp
public static bool operator true(тип_параметра операнд) {
```

// Повернення логічного значення true або false.

```csharp
public static bool operator false(тип_параметра операнд) {
```

// Повернення логічного значення true або false.

Зверніть увагу на те, що і в одному, і в іншому випадку повертається результат типу bool. Нижче наведений приклад програми, що демонструє реалізацію операторів true і false в класі ThreeD . У кожному з цих операторів перевіряється наступна умова: якщо хоча б одна з координат об'єкта типу ThreeD дорівнює нулю, то цей об'єкт істинний, а якщо всі три його координати дорівнюють нулю, то такий об'єкт хибний. У цьому прикладі програми також реалізований оператор декремента виключно з метою демонстрації.

9.6 Оператори перетворення

Іноді об'єкт певного класу потрібно використовувати в виразі, що включає дані інших типів. У деяких випадках для цієї цілі виявляється придатна перевантаження одного або більше операторів, а в інших випадках — звичайне перетворення типу класу в цільовий тип. Для подібних ситуацій в C# передбачена спеціальна різновидність операторного методу, називана оператором перетворення. Такий оператор перетворює об'єкт вихідного класу в інший тип. Оператори перетворення допомагають повністю інтегрувати типи класів у середовище програмування на C#, дозволяючи вільно користуватися класами разом з іншими типами даних, за умови, що визначений порядок перетворення в ці типи. Існують дві форми операторів перетворення: явна і неявна. Нижче вони представлені у загальному вигляді:

```csharp
public static explicit operator цільовий_тип(вихідний_тип v) {return значення ;}
public static implicit operator цільовий_тип(вихідний_тип v) {return значення ;}
```

де цільовий_тип означає той тип, в який виконується перетворення; вхідний_тип — той тип, який перетворюється; значення — конкретне значення, що набуває клас після перетворення. Оператори перетворення повертають дані, що мають цільовий_ тип , причому вказувати інші повернуті типи даних не дозволяється. Якщо оператор перетворення вказаний у неявній формі ( implicit ), то перетворення викликається автоматично, наприклад, у випадку, коли об'єкт використовується у виразі разом із значенням цільового типу. Якщо ж оператор перетворення вказаний у явній формі ( explicit ), то перетворення викликається у випадку, коли виконується приведення типів. Для одних і тих же вихідних і цільових типів даних не можна вказувати оператор перетворення одночасно у явній і неявній формі. Створимо оператор перетворення спеціально для класу ThreeD, щоб проде монструвати його застосування. Припустимо, що потрібно перетворити об'єкт типу ThreeD в ціле значення, щоб потім використовувати його в цілочисельному виразі. Таке перетворення потрібне, зокрема, для отримання добутку всіх трьох координат об'єкта. З цією метою ми скористаємося наступною неявною формою опе ратора перетворення.

Лістинг 9.6 - Приклад застосування оператора неявного перетворення.

```csharp
using System;
```

// Клас для зберігання тривимірних координат.

```csharp
class ThreeD
```

int х, у, z; // тривимірні координати

```csharp
public ThreeD() { x = y = z = 0; }
public ThreeD(int i, int j, int k) { x = i; y = j; z = k; }
```

// Перевантажити бінарний оператор +.

public static ThreeD operator +(ThreeD op1, ThreeD op2)

ThreeD result = new ThreeD();

result.x = op1.x + op2.x;

result.у = op1.у + op2.y;

result.z = op1.z + op2.z;

return result;

// Неявне перетворення об'єкта типу ThreeD до типу int.

public static implicit operator int(ThreeD op1)

return op1.x * op1.у * op1.z;

// Вивести координати X, Y, Z.

public void Show()

```csharp
Console.WriteLine(x + ", " + y + ", " + z);
```

Як випливає з наведеного вище прикладу програми, коли об'єкт типу ThreeD використовується в цілочисельному виразі, такому як i = а , відбувається його перетворення. У цьому конкретному випадку перетворення призводить до повернення цілого значення 6 , яке є добутком координат точки а , що зберігаються в об'єкті з такою самою назвою. Але якщо для обчислення виразу не потрібне перетворення в тип int , то оператор перетворення не викликається. Саме тому операторний метод operator int() не викликається при обчисленні виразу с = а + b . Але для різних цілей можна створити різні оператори перетворення. Так, для перетворення об'єкта типу ThreeD в тип double можна було б визначити другий оператор перетворення. При цьому кожен вид перетворення виконувався автоматично і незалежно від іншого.

10 Індексатори та властивості

У цій главі розглядаються дві особливі і тісно пов'язані одна з одною різновидності членів класу: індексатори і властивості. Кожен з них по-своєму розширює можливості класу, сприяючи більш повному його інтеграції в систему типів C# і підвищуючи його гнучкість. Зокрема, індексатори надають механізм для індексування об'єктів подібно до масивів, а властивості - раціональний спосіб керування доступом до даних екземпляра класу. Ці члени класу тісно пов'язані один з одним, оскільки обидва ґрунтуються на ще одному доступному в C# засобі: аксесор.

10.1 Створення одновимірних індексаторів

Як вам вже повинно бути відомо, індексування масиву здійснюється за допомогою оператора []. Для створюваних класів можна визначити оператор [], але для цієї мети замість операторного методу створюється індексатор, який дозволяє індексувати об'єкт, подібно до масиву. Індексатори застосовуються, головним чином, як засіб, що підтримує створення спеціалізованих масивів, на які накладається одне або кілька обмежень. Тим не менш, індексатори можуть служити практично будь-яким цілям, для яких вигідним виявляється такий самий синтаксис, як і у масивів. Індексатори можуть бути одно - або багатовимірними. Спочатку розглянемо одновимірні індексатори.

Нижче наведена загальна форма одновимірного індексатора:

```csharp
тип_елементу this[int індекс] {
```

// Аксесор для отримання даних.

```csharp
get { // Повернення значення, яке визначає індекс. }
```

// Аксесор для встановлення даних.

```csharp
set { // Встановлення значення, яке визначає індекс. }
```

де тип_елементу означає конкретний тип елемента індексатора. Отже, у кожного елемента, доступного за допомогою індексатора, повинен бути визначений тип_елементу . Цей тип відповідає типу елемента масиву. Параметр індекс отримує конкретний індекс елемента, до якого здійснюється доступ. Формально цей параметр зовсім не обов'язково повинен мати тип int , але оскільки індексато ри, як правило, застосовуються для індексування масивів, то найчастіше використовується цілочисельний тип даного параметра. У тілі індексатора визначені два аксесори (тобто засоби доступу до даних): get і set. Аксесор схожий на метод, за винятком того, що в ньому не оголошується тип поверненого значення або параметри. Аксесори викликаються автоматично при використанні індексатора, і обидва отримуютьіндексяк параметр. Так, якщо індексатор вказується в лівій частині оператора присвоєння, то викликається аксесор set і встановлюється елемент, на який вказує параметр індекс . В іншому випадку викликається аксесор getі повертається значення, що відповідає параметру індекс. Крім того, аксесор set отримує неявний параметр value , що містить значення, призначене за вказаним індексом. Перевага індексатора полягає, зокрема, в тому, що він дозволяє повністю керувати доступом до масиву, уникнувши небажаного доступу. Як приклад розглянемо програму, в якій створюється клас FailSoftArray , що реалізує масив для виявлення помилок порушення меж масиву, а отже, для запобігання виникненню виключних ситуацій, що виникають під час виконання у зв'язку з індексуванням масиву за його межами. Для цього масив інкапсулюється як закрите поле класу, а доступ до нього здійснюється лише за допомогою індексатора. При такому підході виключається будь-яка спроба отримати доступ до масиву за його межами, причому ця спроба припиняється без катастрофічних наслідків для програми. А оскільки в класі FailSoftArray використовується індексатор, то до масиву можна звертатися за допомогою звичайної форми запису.

Лістинг 10.01 - Приклад одномірних індексів

```csharp
using System;
class FailSoftArray
```

int[] a; // посилання на базовий масив

public int Length; // відкрита змінна довжини масиву

public bool ErrFlag; // позначає результат останньої операції

// Побудувати масив заданого розміру.

public FailSoftArray(int size)

a = new int[size];

Length = size;

// Це індексатор для класу FailSoftArray.

public int this[int index]

// Це аксесор get.

get

if (ok(index))

ErrFlag = false;

return a[index];

else

ErrFlag = true;

return 0;

// Це аксесор set.

set

if (ok(index))

a[index] = value;

ErrFlag = false;

else ErrFlag = true;

// Повернути логічне значення true, якщо

// індекс знаходиться в установлених межах.

private bool ok(int index)

if (index >= 0 & index < Length) return true;

return false;

Індексатор запобігає порушенню меж масиву. Уважно проаналізуємо кожну частину коду індексатора. Він починається з наступного рядка.

```csharp
public int this[int index] { У цьому рядку коду оголошується індексатор, що працює з елементами типу int . Йому передається індекс у якості параметра index. Крім того, індексатор оголошується відкритим ( public ), що дає можливість використовувати цей індексатор у коді за межами його класу. Розглянемо наступний код аксесора get.
```

Лістинг 10.2 - код аксесора get

```csharp
get {
if(ok(index)) {
```

ErrFlag = false;

return a[index];

```csharp
} else {
```

ErrFlag = true;

return 0;

Аксесор get запобігає помилкам порушення меж масиву, перевіряючи спочатку , чи знаходиться індекс у встановлених межах. Ця перевірка меж ви повнюється в методі ok() , який повертає логічне значення true , якщо індекс правильний, а інакше - логічне значення false . Так, якщо вказаний індекс на знаходиться б встановлених межах, то за цим індексом повертається відповідний елемент. А якщо індекс виявляється поза встановленими межами, то жодних опе рацій не виконується , але в той же час не виникає жодних помилок переповнення. У цьому варіанті класу FailSoftArray змінна ErrFlag містить результат кожної операції. Її вміст можна перевірити після кожної операції на успішне або неуспішне виконання останньої. А тепер розглянемо наступний код аксесора set, що запобігає помилкам порушення меж масиву.

Лістинг 10.3 - код аксесора set

```csharp
set {
if(ok(index)) {
```

a[index] = value;

ErrFlag = false;

else ErrFlag = true;

повідному елементу масиву присвоюється значення, передане з параметра value . У протилежному випадку встановлюється логічне значення true змінній ErrFlag . Нагадаємо, що value у будь-якому аксесорному методі є неявним параметром, що містить присвоюване значення. Його не потрібно (і навіть неможливо) окремо оголошувати. Наявність обох аксесорів, get і set, в індексаторі не є обов'язковою. Так, можна створити індексатор тільки для читання, реалізувавши в ньому лише аксесор get, або ж індексатор тільки для запису з єдиним аксесором set.

10.2 Перевантаження індексаторів

Індексатор може бути перевантажений. У цьому випадку для виконання вибирається той варіант індексатора, в якому точніше дотримується відповідність його параметра і аргумента, вказуваного як індекс. Нижче наведено приклад програми, в якій індексатор масиву класу FailSoftArray перевантажується для індексів типу double . При цьому індексатор типу double округлює свій індекс до найближчого цілого значення.

Лістинг 10.4 - Це індексатор типу int для масиву FailSoftArray.

```csharp
public int this[int index] {
```

// Це аксесор get.

```csharp
get {
if(ok(index)) {
```

ErrFlag = false;

return a[index];

```csharp
} else {
```

ErrFlag = true;

return 0;

// Це аксесор set.

```csharp
set {
if(ok(index)) {
```

a[index] = value;

ErrFlag = false;

else ErrFlag = true;

Лістинг 10.5 - Це ще один індексатор для масиву FailSoftArray. Він округлює свій аргумент до найближчого цілого індексу.

```csharp
public int this[double idx] {
```

// Це аксесор get.

```csharp
get {
```

int index;

// Округлити до найближчого цілого.

if( (idx - (int) idx) < 0.5) index = (int) idx;

else index = (int) idx + 1;

```csharp
if(ok(index)) {
```

ErrFlag = false;

return a[index];

```csharp
} else {
```

ErrFlag = true;

return 0;

// Це аксесор set.

```csharp
set {
```

int index;

// Округлити до найближчого цілого.

if( (idx - (int) idx) < 0.5) index = (int) idx;

else index = (int) idx + 1;

```csharp
if(ok(index)) {
```

a[index] = value;

ErrFlag = false;

else ErrFlag = true;

Представлений вище приклад програми наочно демонструє доцільність перевантаження індексаторів, але на практиці воно застосовується рідко. Зазвичай, індексатори перевантажуються для того, щоб використовувати об'єкт певного класу в якості індексу, обчисленого якимось особливим способом.

10.3 Індексатори без базового масиву

Слід особливо підкреслити, що індексатор зовсім не обов'язково повинен працювати з масивом. Його основне призначення - надати користувачу функціональні можливості, аналогічні масиву. Як приклад у наведеній нижче програмі демонструється індексатор, що виконує роль масиву лише для читання, що містить степені числа 2 від 0 до 15. Зверніть увагу на те, що в цій програмі відсутній конкретний масив. Замість цього індексатор просто обчислює підходяще значення для заданого індексу.

Лістинг 10.6 - Індексатори зовсім не обов'язково повинні оперувати окремими масивами.

```csharp
using System;
class PwrOfTwo
```

/* Доступ до логічного масиву, що містить степені

числа 2 від 0 до 15. */

public int this[int index]

// Обчислити і повернути степінь числа 2.

get

if ((index >= 0) && (index < 16)) return pwr(index);

else return 1;

// Аксесор set відсутній.

int pwr(int p)

int result = 1;

for (int i = 0; i < p; i++)

result *= 2;

return result;

```csharp
class UsePwrOfTwo
static void Main()
```

PwrOfTwo pwr = new PwrOfTwo();

```csharp
Console.Write("Перші 8 степенів числа 2: ");
```

for (int i = 0; i < 8; i++)

```csharp
Console.Write(pwr[i] + " ");
Console.WriteLine();
Console.Write("А ось деякі помилки: ");
Console.Write(pwr[1] + " " + pwr[17]);
Console.WriteLine();
```

Зверніть увагу на те, що в індексатор класу PwrOfTwo включений лише аксесор get , але він не має аксесора set . Як пояснювалося вище, такий індексатор призначений лише для читання. Отже, об'єкт класу PwrOfTwo може бути вказаний лише в правій частині оператора присвоєння, а не в його лівій частині. Наприклад, спроба ввести наступний рядок коду в показану вище програму не призведе до бажаного результату. pwr[0] = 11; // не підлягає компіляції Такий оператор присвоєння стане причиною появи помилки під час компіляції, оскільки для індексатора не визначений аксесор set. На застосування індексаторів накладаються два суттєві обмеження. По-перше, значення, яке повертає індексатор, не можна передавати методу як параметр ref або out, оскільки в індексаторі не визначено місце в пам'яті для його зберігання. І по-друге, індексатор.

10.4 Багатовимірні індексатори

Індексатори можна створювати і для багатовимірних масивів. Як приклад нижче наведено двовимірний надійний масив. Зверніть особливу увагу на оголошення індексатора в цьому прикладі.

Лістинг 10.7 - Двовимірний масив з відмовостійкістю.

```csharp
class FailSoftArray2D
```

int[,] a; // посилання на базовий двовимірний масив

int rows, cols; // розміри масиву

public int Length; // відкрита змінна довжини масиву

public bool ErrFlag; // позначає результат останньої операції

// Побудувати масив заданих розмірів.

public FailSoftArray2D(int r, int с)

rows = r;

cols = с;

а = new int[rows, cols];

Length = rows * cols;

// Це індексатор для класу FailSoftArray2D.

public int this[int index1, int index2]

// Це аксесор get.

get

if (ok(index1, index2))

ErrFlag = false;

return a[index1, index2];

```csharp
else {
```

ErrFlag = true;

return 0;

// Це аксесор set.

set

if (ok(index1, index2))

a[index1, index2] = value;

ErrFlag = false;

else ErrFlag = true;

// Повернути логічне значення true, якщо

// індекси знаходяться в установлених межах.

private bool ok(int index1, int index2)

if (index1 >= 0 & index1 < rows &

index2 >= 0 & index2 < cols)

return true;

return false;

```csharp
class TwoDIndexerDemo
static void Main()
```

FailSoftArray2D fs = new FailSoftArray2D(3, 5);

int x;

// Виявити приховані збої.

```csharp
Console.WriteLine("Прихована помилка.");
```

for (int i = 0; i < 6; i++)

fs[i, i] = i * 10;

for (int i = 0; i < 6; i++)

x = fs[i, i];

```csharp
if (x != -1) Console.Write(x + " ");
Console.WriteLine();
```

// А тепер показати збої.

```csharp
Console.WriteLine(" Помилка з повідомленням про помилку.");
```

for (int i = 0; i < 6; i++)

fs[i, i] = i * 10; if (fs.ErrFlag)

```csharp
Console.WriteLine("fs[" + i + ", " + i + "] поза межами");
```

for (int i = 0; i < 6; i++)

x = fs[i, i];

```csharp
if (!fs.ErrFlag) Console.Write(x + " ");
```

else

```csharp
Console.WriteLine("fs[" + i + ", " + i + "] поза межами");
```

10.5 Властивості

Ще одним видом члена класу є властивість. Зазвичай, властивість поєднує в собі поле з методами доступу до нього. Як було показано в попередніх прикладах програм , поле часто створюється, щоб стати доступним для користувачів об'єкта, але при цьому бажано зберегти контроль над операціями, дозволеними для цього поля, наприклад, обмежити діапазон значень, присвоєних даному полю. Цієї мети можна, звичайно, досягти і за допомогою закритої змінної, а також методів доступу до її значення, але властивість надає більш повний і раціональний шлях для досягнення тієї ж самої мети. Властивості дуже схожі на індексатори. Зокрема, властивість складається з імені та аксесорів get і set . Аксесори використовуються для отримання та встановлення значення змінної. Головною перевагою властивості є те, що її ім'я може бути використане в виразах та операторах присвоєння аналогічно імені звичайної змінної, але фактично при зверненні до властивості за ім'ям автоматично викликаються її аксесори get і set . Аналогічним чином використовуються аксесори get і set індексатора. Нижче наведено загальна форма властивості:

```csharp
тип ім'я {
get { // код аксесора для читання з поля }
set { // код аксесора для запису в поле }
```

де тип означає конкретний тип властивості, наприклад int, а ім'я — присвоєне властивості ім'я. Як тільки властивість буде визначена, будь-яке звернення до властивості за іменем призведе до автоматичного виклику відповідного аксесора. Крім того, аксесор set приймає неявний параметр value, який містить значення, при присвоєному властивості.

Слід, однак, мати на увазі, що властивості не визначають місце в пам'яті для зберігання полів, а лише керують доступом до полів. Це означає, що сама властивість не надає поле, і тому поле повинно бути визначене незалежно від властивості. Нижче наведено простий приклад програми, в якій визначається властивість MyProp, призначена для доступу до поля prop. У цьому прикладі властивість допу скає присвоєння лише позитивних значень.

Лістинг 10.8 - Простий приклад застосування властивості.

```csharp
class SimpProp
```

int prop; // поле, кероване властивістю МуРrор

```csharp
public SimpProp() { prop = 0; }
```

/* Ця властивість забезпечує доступ до закритої змінної екземпляра prop.

Вона дозволяє присвоювати лише позитивні значення. */

public int MyProp

get

return prop;

set

if (value >= 0) prop = value;

```csharp
class PropertyDemo
static void Main()
```

SimpProp ob = new SimpProp();

```csharp
Console.WriteLine("Початкове значення ob.МуРrор: " + ob.МуРrор);
```

ob.МуРrор = 100; // присвоїти значення

```csharp
Console.WriteLine("Поточне значення ob.МуРrор: " + ob.МуРrор);
```

// Змінній prop не можна присвоїти від'ємне значення.

```csharp
Console.WriteLine("Спроба присвоїти значення " +
```

"-10 властивості ob.МуРrор");

ob.МуРrор = -10;

```csharp
Console.WriteLine("Поточне значення ob.МуРrор: " + ob.МуРrор);
```

Розглянемо наведений вище код більш детально. У цьому коді визначається одне закрите поле propі властивість MyProp, що керує доступом до поля prop. Як пояснювалося вище, сама властивість не визначає місце в пам'яті для зберігання поля, а лише керує доступом до поля. Крім того, поле prop є закритим, а отже, воно доступне тільки через властивість MyProp. Властивість MyProp вказано як public, тому вона доступна з коду за межами його класу. І в цьому є своя логіка, оскільки дана властивість забезпечує доступ до поля prop, яке є закритим. Аксесор get цієї властивості просто повертає значення з поля prop, тоді як аксесор set встановлює зна чення в поле prop тільки у випадку, якщо це значення є додатнім. Отже, властивість MyProp контролює значення , які можуть зберігатися в полі prop. В цьому, власне, і полягає основне призначення властивостей. Тип властивості MyProp визначається як для читання, так і для запису, оскільки вона дозволяє читати і записувати дані в базове поле. Проте властивості можна створювати доступними тільки для читання або тільки для запису. Так, якщо потрібно створити властивість, доступну тільки для читання, то достатньо визначити єдиний аксесор get. А якщо потрібно створити властивість, доступну тільки для запису, то достатньо визначити єдиний аксесор set. Скористаємося властивістю для подальшого вдосконалення надійного масиву. Як вам має бути відомо, у всіх масивів є відповідне властивість довжини (Length). До цього часу в класіFailSoftArray для цієї цілі іс пользовалося відкрите цілочисельне поле Length. Але це далеко не найкращий підхід, оскільки він дозволяє встановлення значень, відмінних від довжини надійно стійкого масиву. Для того щоб виправити це положення, перетворимо поле Length в властивість "тільки для читання", як по казано в наведеному нижче, зміненому варіанті класу FailSoftArray.

Лістинг 10.9 - Додати властивість Length в клас FailSoftArray

```csharp
class FailSoftArray
```

int[] a; // посилання на базовий масив

int len; // довжина масиву - основа для властивості Length

public bool ErrFlag; // позначає результат останньої операції

// Побудувати масив заданого розміру.

public FailSoftArray(int size)

a = new int[size];

len = size;

// Властивість Length тільки для читання.

public int Length

get

return len;

// Це індексатор для класу FailSoftArray.

public int this[int index]

// Це аксесор get.

get

if (ok(index))

ErrFlag = false;

return a[index];

else

ErrFlag = true;

return 0;

// Це аксесор set.

set

if (ok(index))

a[index] = value;

ErrFlag = false;

else ErrFlag = true;

// Повернути логічне значення true, якщо

// індекс знаходиться в установлених межах.

private bool ok(int index)

if (index >= 0 & index < Length) return true;

return false;

// Показати застосування вдосконаленого

// масиву з відмовостійкістю.

```csharp
class ImprovedFSDemo
static void Main()
```

FailSoftArray fs = new FailSoftArray(5);

int x;

// Дозволити читання властивості Length.

for (int i = 0; i < fs.Length; i++)

fs[i] = i * 10;

for (int i = 0; i < fs.Length; i++)

x = fs[i];

```csharp
if (x != 1) Console.Write(x + " ");
Console.WriteLine();
```

// fs.Length = 10; // Помилка, запис заборонено!

Тепер Length - це властивість, в якій місцем для зберігання даних слугує закрита змінна len. А оскільки в цій властивості визначений єдиний акceccop get , то воно доступно тільки для читання. Це означає, що значення властивості Length можна тільки читати, але не змінювати. Для того, щоб переконатися в цьому, спробуйте видалити символи коментаря на початку наступного рядка з наведеного вище коду.

10.6 Автоматично реалізовані властивості

Починаючи з версії C# 3.0, з'явилася можливість для реалізації дуже простих властивостей, не вдаючись до явного визначення змінної, якою керує властивість. Замість цього базову змінну для властивості автоматично надає компілятор. Така властивість називається автоматично реалізованою і має наступну загальну форму

```csharp
тип ім'я { get; set; }
```

де типозначає конкретний тип властивості, а ім'я —присвоєне властивості ім'я. Зверніть увагу на те, що після позначень аксесорів get і set відразу ж слідує крапка з комою, а тіло вони не мають. Такий синтаксис наказує компіля тору створити автоматично змінну, іноді ще називається підтримуючим по лем , для зберігання значення. Така змінна недоступна безпосередньо і не має імені. Але в той же час вона може бути доступна через властивість. Нижче наведено приклад оголошення властивості, автоматично реалізованої під іменем UserCount.

```csharp
public int UserCount { get; set; }
```

Як бачите, в цьому рядку коду змінна явно не оголошується. І як пояснювалося вище, компілятор автоматично створює анонімне поле, в якому зберігається зна чення. А в іншому автоматично реалізована властивість UserCountподібно до всіх інших властивостей. Але на відміну від звичайних властивостей автоматично реалізована властивість не може бути доступною тільки для читання або тільки для запису. При оголошенні цієї властивості в будь-якому випадку необхідно вказувати обидва аксесори — get і set . Хоча досягти бажаного (тобто зробити автоматично реалізовану властивість доступною тільки для читання або тільки для запису) все ж таки можна, оголосивши непотрібний аксесор як private (детальніше про це — у розділі " Застосування модифікаторів доступу в аксесорах " ). Незважаючи на очевидні зручності автоматично реалізованих властивостей, їх застосування обмежується в основному тими ситуаціями, в яких не потрібне керування встановленням або отриманням значень з підтримуючих полів. Нагадаємо, що підтримуюче поле недоступне безпосередньо. Це означає, що на значення, яке може мати автоматично реалізована властивість, не можна накласти жодних обмежень. Отже, імена автоматично реалізованих властивостей просто замінюють собою імена самих полів, а часто саме це і потрібно в програмі. Автоматично реалізовані властивості можуть бути корисними і в тих випадках, коли за допомогою властивостей функціональні можливості програми відкриваються для сторонніх користувачів, і для цієї цілі можуть навіть застосовуватися спеціальні засоби проектування.

10.7 Застосування ініціалізаторів об'єктів у властивостях

Як пояснювалося в розділі 8, ініціалізатор об'єкта застосовується як альтернатива явному виклику конструктора при створенні об'єкта. За допомогою ініціалізаторів об'єктів задаються початкові значення полів або властивостей, які потрібно ініціалізувати. При цьому синтаксис ініціалізаторів об'єктів виявляється однаковим як для властивостей, так і для полів. Як приклад нижче наведена програма з розділу 8, змінена з метою продемонструвати застосування ініціалізаторів об'єктів в властивостях. Нагадаємо, що в версії цієї програми з розділу 8 використовувалися поля, а наведена нижче версія відрізняється лише тим, що в ній поля Count і Str перетворені в властивості. У той же час синтаксис ініціалізаторів об'єктів не змінився.

Лістинг 10.10 - Застосувати ініціалізатори об'єктів в властивостях.

```csharp
class MyClass
```

// Тепер це властивості.

```csharp
public int Count { get; set; }
public string Str { get; set; }
class ObjInitDemo
static void Main()
```

// Побудувати об'єкт типу MyClass за допомогою ініціалізаторів об'єктів.

MyClass obj =

```csharp
new MyClass { Count = 100, Str = "Тестування" };
Console.WriteLine(obj.Count + " " + obj.Str);
```

Як бачите, властивості Countі Strвстановлюються в виразах з ініціалізато ром об'єкта. Представлена вище програма дає такий самий результат, як і програма з глави 8, а саме: 100 Тестування Як пояснювалося в главі 8, синтаксис ініціалізатора об'єкта виявляється найбільш зручним для роботи з анонімними типами, формованими в LINQ-виразах. А в інших випадках найчастіше використовується синтаксис звичайних конструкторів.

Властивостям притаманний ряд суттєвих обмежень. По-перше, властивість не визначає місце для зберігання даних, тому не може бути передана методу як параметр ref або out . По-друге, властивість не підлягає перевантаженню. Допускається наявність двох різних властивостей з доступом до однієї й тієї ж змінної, але це, скоріше, виняток, ніж правило. І нарешті, властивість не повинна змінювати стан базо вої змінної при виклику аксесора get . І хоча компілятор не дотримується цього обмежувального правила, його порушення вважається семантичною помилкою. Дія аксесора get не повинна мати характер втручання в функціонування змінної.

10.8 Застосування модифікаторів доступу в аксесорах

За замовчуванням доступність аксесорів set і get показується такою ж, як і у індексатора і властивості, частиною яких вони є. Так, якщо властивість оголошується як public , то за замовчуванням її аксесори set і get також стають відкритими ( public ). Проте для аксесора set або get можна вказати власний модифікатор доступу, наприклад private . Але в будь-якому випадку доступність аксесора, визначена таким модифікатором, повинна бути більш обмеженою, ніж доступність, вказана для його властивості або індексатора. Існує цілий ряд причин, чому потрібно обмежити доступність аксесора. Припустимо, що потрібно надати вільний доступ до значення властивості, але водночас дати можливість встановлювати цю властивість тільки членам його класу. Для цього достатньо оголосити аксесор даної властивості як private. У наведеному нижче прикладі використовується властивість MyProp, аксесор setякої вказаний як private.

Лістинг 10.11 - Застосувати модифікатор доступу в аксесорі.

```csharp
class PropAccess
```

int prop; // поле, кероване властивістю МуРrор

```csharp
public PropAccess() { prop = 0; }
```

public int МуРrор

get

return prop;

private set

```csharp
{ // тепер це закритий аксесор
```

prop = value;

// Цей член класу інкрементує значення властивості МуРrор.

public void IncrProp()

MyProp++; // Допускається в. тому ж самому класі.

```csharp
class PropAccessDemo
static void Main()
```

PropAccess ob = new PropAccess();

```csharp
Console.WriteLine("Початкове значення ob.МуРrор: " + ob.МуРrор);
```

// ob.МуРrор = 100; // недоступно для встановлення

ob.IncrProp();

```csharp
Console.WriteLine("Значення ob.МуРrор після інкрементування: " +
```

ob.МуРrор);

В класі PropAccess аксесор set вказаний як private . Це означає, що він доступний тільки іншим членам цього класу, наприклад методу IncrProp() , але недоступний для коду поза класом PropAccess . Саме тому спроба Присвоїти властивості ob.МуРrор значення в класі PropAccessDemo закоментована. Ймовірно, обмеження доступу до аксесорів є найважливішим для роботи з автоматично реалізованими властивостями. Як пояснювалося вище, створити автоматично реалізована властивість тільки для читання або ж тільки для запису неможливо, оскільки обидва аксесори, get і set, повинні бути вказані при оголошенні такої властивості. Проте досягти бажаного результату все ж можна, оголосивши один з аксесорів автоматично реалізованої властивості як private. В якості прикладу нижче наведено оголошення автоматично реалізованої властивості Length для класу FailSoftArray, яке фактично стає доступним тільки для читання.

```csharp
public int Length { get; private set; }
```

Властивість Lengthможе бути встановлена тільки з коду в його класі, оскільки його аксесор set оголошений як private. А змінювати властивість Lengthза межами його класу не дозволяється. Це означає, що за межами свого класу властивість, по суті, стає доступною тільки для читання. Аналогічним чином можна оголосити і властивість Error, як показано нижче.

```csharp
public bool Error { get; private set; }
```

Завдяки цьому властивість Error становиться доступною для читання, але не для встановлення за межами класу FailSoftArray . Для перевірки автоматично реалізованих варіантів властивостей Length і Error в класіFailSoftArray видалимо спочатку змінні lenі ErrFlag, оскільки вони більше не потрібні, а потім замінимо кожне використання змінних lenі ErrFlag властивостями Lengthі Errorв класіFailSoftArray. Нижче наведено оновлений варіант класу FailSoftArray разом з методом Main(), що демонструє його застосування.

Лістинг 10.12 - Застосувати автоматично реалізовані та доступні тільки для читання властивості Length і Error.

```csharp
class FailSoftArray
```

int[] a; // посилання на базовий масив

// Побудувати масив за заданим розміром.

public FailSoftArray(int size)

a = new int[size];

Length = size;

// Автоматично реалізована та доступна тільки для читання властивість Length.

```csharp
public int Length { get; private set; }
```

// Автоматично реалізована та доступна тільки для читання властивість Error.

```csharp
public bool Error { get; private set; }
```

// Це індексатор для масиву FailSoftArray.

public int this[int index]

// Це аксесор get.

```csharp
get {
```

if (ok(index))

Error = false;

return a[index];

else

Error = true;

return 0;

// Це аксесор set.

set

if (ok(index))

a[index] = value;

Error = false;

else Error = true;

// Повернути логічне значення true, якщо

// індекс знаходиться в установлених межах.

private bool ok(int index)

if (index >= 0 & index < Length) return true;

return false;

// Показати застосування вдосконаленого

// масиву з відмовостійкістю.

```csharp
class FinalFSDemo
static void Main()
```

FailSoftArray fs = new FailSoftArray(5);

// Використовувати властивість Error.

for (int i = 0; i < fs.Length + 1; i++)

fs[i] = i * 10;

if (fs.Error)

```csharp
Console.WriteLine("Помилка в індексі " + i);
```

Цей варіант класу FailSoftArray діє так само, як і попередній, але в ньому відсутні підтримуючі поля, оголошені явно. На застосування модифікаторів доступу в аксесорах накладаються наступні обмеження. По-перше, дії модифікатора доступу підлягає тільки один ак сесор: set або get , але не обидва одночасно. По-друге, модифікатор повинен забезпечувати більш обмежений доступ до аксесора, ніж доступ на рівні властивості або індексато ра. І нарешті, модифікатор доступу не можна використовувати при оголошенні аксесора в інтерфейсі або при реалізації аксесора, вказаного в інтерфейсі.


---

[◀️ До змісту](../README.md)
