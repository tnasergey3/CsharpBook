# Інтерфейси, структури і перелічення

[◀️ До змісту лекцій](README.md)

---

У цьому розділі розглядається один з найважливіших у C# засобів: інтерфейс що визначає ряд методів для реалізації в класі. Але оскільки в самому інтерфейсі жоден з методів не реалізується, інтерфейс представляє собою чисто логічну конструкцію, що описує функціональні можливості без конкретної їх реалізації. Крім того, у цьому розділі представлені ще два типи даних C#: структури і перелічення. Структури подібні класам, за винятком того, що вони трактуються як типи значень, а не посилальні типи. Аперелічення представляють собою переліки цілочисельних констант. Структури і перелічення розширюють багатий арсенал засобів програмування на C#.

12.1 Інтерфейси

Іноді в об'єктно-орієнтованому програмуванні корисно визначити, що саме повинен робити клас, але не як він повинен це робити. Прикладом цього може служити згадуваний раніше абстрактний метод. У абстрактному методі визначаються повернений тип і сигнатура методу, але не надається його реалізація. А в похідному класі повинна бути забезпечена власна реалізація кожного абстрактного методу, визначеного в його базовому класі. Отже, абстрактний метод визначає інтерфейс, але не реалізацію методу. Звичайно, абстрактні класи і методи приносять певну користь, але принцип, на якому вони базуються, може бути розвиток продовжується. У C# передбачено розділення інтерфейсу класу та його реалізації за допомогою ключового слова interface . З синтаксичної точки зору інтерфейси схожі на абстрактні класи. Але в інтер фейсі жоден з методів не повинен мати тіла. Це означає, що в інтерфейсі взагалі не надається жодної реалізації. В ньому вказується тільки, що саме слід робити, але не як це робити. Як тільки інтерфейс буде визначений, його можна реалізувати в будь-якій кількості класів. Крім того, в одному класі може бути реалізовано будь-яку кількість інтерфейсів. Для реалізації інтерфейсу в класі повинні бути надані тіла (тобто кон кретні реалізації) методів, описаних у цьому інтерфейсі. Кожному класу надається повна свобода для визначення деталей своєї власної реалізації інтерфейсу. Отже, один і той самий інтерфейс може бути реалізований у двох класах по-різному. Проте в кожному з них повинен підтримуватися один і той самий набір методів даного інтерфейсу. А в тому коді, де відомий такий інтерфейс, можуть використовуватися об'єкти будь-якого з цих двох класів, оскільки інтерфейс для всіх цих об'єктів залишається однаковим. Завдяки підтримці інтерфейсів у C# може бути повністю реалізований головний принцип поліморфізму: один інтер фейс - множина методів.

Інтерфейси оголошуються за допомогою ключового слова interface. Нижче наведено спрощена форма оголошення інтерфейсу.

```csharp
interface ім'я {
```

повертаємий_тип ім'я_методу1(список_параметрів);

повертаємий_тип ім'я_методу2(список_параметрів);

```csharp
// ... повертаємий_тип ім'я_методуN{список_параметрів);
```

де ім'я — це конкретне ім'я інтерфейсу. У оголошенні методів інтерфейсу використовуються тільки їх повертаємий_тип та сигнатура. Вони, по суті, є абстрактними методами. Як пояснювалося вище, в інтерфейсі не може бути жодної реалізації. Тому всі методи інтерфейсу повинні бути реалізовані в кожному класі, що включає цей інтерфейс. У самому інтерфейсі методи неявно вважаються відкритими, тому доступ до них не потрібно вказувати явно. Нижче наведено приклад оголошення інтерфейсу для класу, що генерує послідовний ряд чисел.

Лістинг 12.1 - Приклад інтерфейсу

public interface ISeries

int GetNext(); // повернути наступне за порядком число

void Reset(); // перезапустити

void SetStart(int х); // задати початкове значення

Як тільки інтерфейс буде визначений, його можна реалізувати в одному або декількох класах. Для реалізації інтерфейсу достатньо вказати його ім'я після імені класу, аналогічно базовому класу. Нижче наведена загальна форма реалізації інтерфейсу в класі.

```csharp
class ім'я_класу : ім'я_інтерфейсу { // тіло класу }
```

Де ім'я_інтерфейсу —це конкретне ім'я реалізованого інтерфейсу. Якщо ін терфейс реалізується в класі, то це повинно бути зроблено повністю. Зокрема, реалізувати інтерфейс вибірково і тільки частково не можна. У класі можна реалізувати кілька інтерфейсів. У цьому випадку всі реалізовані в класі інтерфейси вказуються списком через кому. У класі можна успадкувати базовий клас і водночас реалізувати один або більше інтерфейс. У такому випадку ім'я базового класу повинно бути вказано перед списком інтерфейсів, розділених комою. Методи, що реалізують інтерфейс, повинні бути оголошені як public . Справа в тому, що в самому інтерфейсі ці методи неявно підразуміваються як відкриті, тому їх реалізація також повинна бути відкритою. Крім того, повернений тип і сигнатура реалізованого методу повинні точно відповідати поверненому типу і сигнатурі, зазначеним у визначенні інтерфейсу. Нижче наведений приклад програми, в якій реалізується представлений раніше інтерфейс ISeries . У цій програмі створюється клас ByTwos , що генерує послідовний ряд чисел, в якому кожне наступне число на два більше попереднього.

Лістинг 12.2 - Приклад класу що реалізує інтерфейс

```csharp
class ByTwos : ISeries
```

int start;

int val;

public ByTwos()

start = 0;

val = 0;

public int GetNext()

val += 2;

return val;

public void Reset()

val = start;

public void SetStart(int x)

start = x;

val = start;

Як бачите, в класі ByTwos реалізуються три методи, визначені в інтерфейсі ISeries. Як пояснювалося вище, це доводиться робити тому, що в класі неможливо реалізувати інтерфейс частково.

12.2 Застосування інтерфейсних посилань

Як це не здається дивним, але в C# дозволяється оголошувати змінні посилання на інтерфейсний тип, тобто змінні посилання на інтерфейс. Така змінна може посилатися на будь-який об'єкт, що реалізує його інтерфейс. При виклику методу для об'єкта за допомогою інтерфейсного посилання виконується його варіант, реалізований в класі даного об'єкта. У наведеному нижче прикладі програми демонструється застосування інтер фейсного посилання. У цій програмі змінна посилання на інтерфейс використовується з метою викликати методи для об'єктів обох класів — ByTwosі Primes. Для ясності в даному прикладі показані всі частини програми, зібрані в єдиний файл.

Лістинг 12.3 - Приклад застосування інтерфейсних посилань

// Визначити інтерфейс.

public interface ISeries

int GetNext(); // повернути наступне за порядком число

void Reset(); // перезапустити

void SetStart(int х); // задати початкове значення

// Використовувати інтерфейс ISeries для реалізації процесу

// генерування послідовного ряду чисел, в якому кожне

// наступне число на два більше попереднього.

```csharp
class ByTwos : ISeries
```

int start;

int val;

public ByTwos()

start = 0;

val = 0;

public int GetNext()

val += 2;

return val;

public void Reset()

val = start;

public void SetStart(int x)

start = x;

val = start;

```csharp
class Primes : ISeries
```

int start;

int val;

public Primes()

start = 2;

val = 2;

public int GetNext()

int i, j;

bool isprime;

val++;

for (i = val; i < 1000000; i++)

isprime = true;

for (j = 2; j <= i / j; j++)

if ((i % j) == 0)

isprime = false;

break;

if (isprime)

val = i;

break;

return val;

public void Reset()

val = start;

public void SetStart(int x)

start = x;

val = start;

```csharp
class SeriesDemo2
static void Main()
```

ByTwos twoOb = new ByTwos();

Primes primeOb = new Primes();

ISeries ob;

for (int i = 0; i < 5; i++)

ob = twoOb;

```csharp
Console.WriteLine("Наступне парне число дорівнює " + ob.GetNext());
```

ob = primeOb;

```csharp
Console.WriteLine("Наступне просте число " + "дорівнює " + ob.GetNext());
```

Ось до якого результату призводить виконання цієї програми:

Наступне парне число дорівнює 2

Наступне просте число дорівнює 3

Наступне парне число дорівнює 4

Наступне просте число дорівнює 5

Наступне парне число дорівнює 6

Наступне просте число дорівнює 7

Наступне парне число дорівнює 8

Наступне просте число дорівнює 11

Наступне парне число дорівнює 10

Наступне просте число дорівнює 13

У методі Main() змінна ob оголошується для посилання на інтерфейс ISeries . Це означає, що в ній можуть зберігатися посилання на об'єкт будь-якого класу, що реалізує даний інтерфейс ISeries . У даному випадку вона служить для посилання на об'єкти twoOb і primeOb класів ByTwos і Primes відповідно, в яких реалізований інтерфейс ISeries. І ще одне зауваження: змінній посилання на інтерфейс доступні тільки методи, оголошені в його інтерфейсі. Тому інтерфейсне посилання не можна використовувати для доступу до будь-яких інших змінних і методів, які не підтримуються об'єктом класу , що реалізує цей інтерфейс.

12.3 Інтерфейсні властивості

Аналогічно методам, властивості вказуються в інтерфейсі без тіла. Нижче наведена загальна форма оголошення інтерфейсної властивості.

// Інтерфейсна властивість

```csharp
тип ім'я{ get; set; }
```

Очевидно, що в означенні інтерфейсних властивостей, доступних тільки для читання або тільки для запису, повинен бути присутній єдиний аксесор: getабо set відповідно. Незважаючи на те, що оголошення властивості в інтерфейсі дуже схоже на оголошення автоматично реалізованої властивості в класі, між ними все ж таки є відмінність. При оголошенні в інтерфейсі властивості вона не стає автоматично реалізованою.

У цьому випадку вказується лише ім'я і тип властивості, а її реалізацію надається кожному реалізуючому класу. Крім того, при оголошенні властивості в інтерфейсі не дозволяється вказувати модифікатори доступу для аксесорів. Наприклад, аксесор set не може бути вказаний в інтерфейсі як private. Нижче наведено перероблений варіант інтерфейсу ISeries та класу ByTwos, в якому використовується властивість Next для отримання та встановлення наступного числа, яке є більшим за попереднє на два.

Лістинг 12.4 - Приклад властивостей в інтерфейсі

public interface ISeries

// Інтерфейсна властивість.

int Next

get; // повернути наступне число за порядком

set; // встановити наступне число

// Реалізувати інтерфейс ISeries.

```csharp
class ByTwos : ISeries
```

int val;

public ByTwos()

val = 0;

// Отримати або встановити значення.

public int Next

get

val += 2;

return val;

set

val = value;

12.4 Інтерфейсні індексатори

В інтерфейсі також можна вказувати індексатори. Нижче наведено загальна форма оголошення інтерфейсного індексатора.

тип_елементу this[int індекс]

get;

set;

Як і раніше, при оголошенні інтерфейсних індексаторів, доступних тільки для читання або тільки для запису, повинен бути присутній єдиний аксесор: get або setвідповідно. Нижче наведено ще один приклад реалізації інтерфейсу ISeries, в якому додано індексатор тільки для читання, що повертає i-йеле мент числового ряду.

Лістинг 12.5 - Приклад інтерфейсу с індексатором

public interface ISeries

// Інтерфейсна властивість.

int Next

get; // повернути наступне число за порядком

set; // встановити наступне число

// Інтерфейсний індексатор.

int this[int index]

get; // повернути вказане в ряду число

// Реалізувати інтерфейс ISeries.

```csharp
class ByTwos : ISeries
```

int val;

public ByTwos()

val = 0;

// Отримати або встановити значення за допомогою властивості.

public int Next

get

val += 2;

return val;

set

val = value;

// Отримати значення за індексом.

public int this[int index]

get

val = 0;

for (int i = 0; i < index; i++)

val += 2;

return val;

12.5 Успадкування інтерфейсів

Один інтерфейс може успадковувати інший. Синтаксис успадкування інтерфейсів такий самий, як і у класів. Коли в класі реалізується один інтерфейс, успадковуючи інший, в ньому повинні бути реалізовані всі члени, визначені в ланцюжку успадкування інтерфейсів, як у наведеному нижче прикладі.

Лістинг 12.6 - Приклад успадкування інтерфейсів

public interface IA

void Meth1();

void Meth2();

// В базовий інтерфейс включені методи Meth1() і Meth2().

// а в похідний інтерфейс додано ще один метод - Meth3().

public interface IB : IA

void Meth3();

// У цьому класі повинні бути реалізовані всі методи інтерфейсів IA і IB.

```csharp
class MyClass : IB
```

public void Methl()

```csharp
Console.WriteLine("Реалізувати метод Meth1().");
```

public void Meth2()

```csharp
Console.WriteLine("Реалізувати метод Meth2().");
```

public void Meth3()

```csharp
Console.WriteLine("Реалізувати метод Meth3().");
class IFExtend
static void Main()
```

MyClass ob = new MyClass();

ob.Meth1();

ob.Meth2();

ob.Meth3();

Заради цікавості спробуйте видалити реалізацію методу Meth1()з класу MyClass. Це призведе до помилки під час компіляції. Як пояснювалося раніше, в будь-якому класі, що реалізує інтерфейс, повинні бути реалізовані всі методи, визначені в цьому інтерфейсі, включаючи ті, що успадковуються з інших інтерфейсів.

Коли один інтерфейс успадковує інший, то в похідному інтерфейсі може бути оголошений член, який приховує член з аналогічним ім'ям в базовому інтерфейсі. Таке приховування імені відбувається у випадку, якщо член в похідному інтерфейсі оголошується так само, як і в базовому інтерфейсі. Але якщо не вказати у оголошенні члена похідного інтерфейсу ключове слово new, то компілятор ви дасть відповідне попереджувальне повідомлення.

12.6 Структури

Як вам вже повинно бути відомо, класи належать до посилальних типів даних. Це означає, що об'єкти конкретного класу доступні за посиланням, на відміну від значень простих типів, доступних безпосередньо. Але іноді прямий доступ до об'єктів як до значень простих типів виявляється корисним мати, наприклад, для підвищення ефективності програми. Адже кожен доступ до об'єктів (навіть найдрібніших) за посиланням пов'язаний з додатковими витратами на використання обчислювальних ресурсів та оперативної пам'яті. Для вирішення подібних проблем в C# передбачена структура, яка схожа на клас, але належить до типу значення, а не посилального типу даних. Структури оголошуються за допомогою ключового слова struct і з точки зору синтаксису схожі на класи. Нижче наведена загальна форма оголошення структури:

```csharp
struct ім'я : інтерфейси { // оголошення членів }
```

Де ім'я позначає конкретне ім'я структури.

Деякі структури не можуть успадковувати інші структури та класи або служити як базові для інших структур і класів. (Звичайно, структури, так само як і всі інші типи даних в C#, успадковують клас object .) Однак у структурі мож на реалізувати один або кілька інтерфейсів, які вказуються після імені структури списком через кому. Як і у класів, у кожної структури є свої члени: методи, поля, індексатори, властивості, операторні методи та події.

У структурах також допускається визначати конструктори, але не деструктори. Тим часом для структури не можна визначити конструктор, що використовується за замовчуванням (тобто кон структор без параметрів). Справа в тому, що конструктор, який викликається за замовчуванням, визначається для всіх структур автоматично і не підлягає зміні. Такий кон структор ініціалізує поля структури значеннями, заданими за замовчуванням. Оскільки структури не підтримують успадкування, їх члени не можна вказувати як abstract, virtual або protected. Об'єкт структури може бути створений за допомогою оператора new так само, як і об'єкт класу, але це не є обов'язковим.

Адже коли використовується оператор new , то викликається конструктор, який використовується за замовчуванням. А коли цей оператор не використовується, об'єкт все одно створюється, хоча і не ініціалізується. У цьому випадку ініціалізацію будь-яких членів структури доведеться виконати вручну. У наведеному нижче прикладі програми демонструється застосування структури для зберігання інформації про книгу.

Лістинг 12.7 - Приклад структури

struct Book

public string Author;

public string Title;

public int Copyright;

public Book(string a, string t, int c)

Author = a;

Title = t;

Copyright = c;

```csharp
class StructDemo
static void Main()
```

Book book1 = new Book("Герберт Шилдт",

"Повний довідник пo C# 4.0",

2010); // виклик явно заданого конструктора

Book book2 = new Book(); // виклик конструктора за замовчуванням

Book bоок3; // конструктор не викликається

```csharp
Console.WriteLine(book1.Author + ", " +
```

book1.Title + ",(c) " + book1.Copyright);

```csharp
Console.WriteLine();
```

if (book2.Title == null)

```csharp
Console.WriteLine("Член book2.Title пуст.");
```

// А тепер ввести інформацію в структуру book2.

book2.Title = "Про дивний новий світ";

book2.Author = "Олдос Хакслі";

book2.Copyright = 1932;

```csharp
Console.Write("Структура book2 тепер містить: ");
Console.WriteLine(book2.Author + ", " +
```

book2.Title + ", (c) " + book2.Copyright);

```csharp
Console.WriteLine();
```

ЬоокЗ.Title = "Червона буря";

```csharp
Console.WriteLine(ЬоокЗ.Title); // тепер правильно
```

Як показує приклад програми вище, структуру можна ініціалізувати за допомогою оператора new для виклику конструктора або просто оголошення об'єкта. Так, якщо використовується оператор new, то поля структури ініціалізуються конструктором, який викликається за замовчуванням (у цьому випадку всі поля отримують значення за замовчуванням) або конструктором, визначеним користувачем. А якщо оператор new не використовується, як у випадку зі структурою bоок3 , то об'єкт структури не ініціалізується, а його поля повинні бути встановлені вручну перед використанням цього об'єкта. Коли одна структура присвоюється іншій, створюється копія її об'єкта. У цьому за ключається одна з основних відмінностей структури від класу.

Як пояснювалося раніше, коли посилання на один клас присвоюється посиланню на інший клас, в результаті посилання у лівій частині оператора присвоєння вказує на той самий об'єкт, що і посилання у правій його частині. А коли змінна однієї структури присвоюється змінній іншої структури, створюється копія об'єкта структури з правої частини оператора при присвоєнні. Розглянемо як приклад наступну програму.

Лістинг 12.8 - Приклад копіювання структури

struct MyStruct

public int x;

```csharp
class StructAssignment
static void Main()
```

MyStruct a;

MyStruct b;

a.x = 10;

b.x = 20;

```csharp
Console.WriteLine("a.x {0}, b.x {1}", a.x, b.x);
```

a = b;

b.x = 30;

```csharp
Console.WriteLine("a.x {0}, b.x {1}", a.x, b.x);
```

Як показує вищезазначений результат, після присвоєння а = b; змінні структури а і b залишаються абсолютно відокремленими, тобто змінна а не вказує на змінну b і не пов'язана з нею, окрім того, що вона містить копію значення змінної b . Ситуація була б зовсім іншою, якби змінні а і b були посилального типу, вказуючи на об'єкти певного класу.

У зв'язку з викладеним вище виникає розумне питання: чому в C# включена структура, якщо вона має більш скромні можливості, ніж клас? Відповідь на це питання полягає в підвищенні ефективності та продуктивності програм. Структури відносяться до типів значень, і тому ними можна оперувати безпосередньо, а не за посиланням. Отже, для роботи зі структурою взагалі не потрібна змінна посилального типу, а це означає у ряді випадків значну економію оперативної пам'яті. Більше того, робота зі структурою не призводить до погіршення продуктивності, що є характерним для роботи з об'єктом класу. Оскільки класи відносяться до посилального типу даних, доступ до структури здійснюється безпосередньо, а до об'єктів - за посиланням. Непрямий доступ до об'єктів передбачає додаткові витрати обчислювальних ресурсів для кожного такого доступу , тоді як доступ до структур не супроводжується подібними витратами. Взагалі-то, якщо потрібно просто зберегти групу пов'язаних даних, які не потребують успадкування та доступу за посиланням, то з точки зору продуктивності краще вибрати структуру.

12.7 Перелічення

Перерахування представляє собою множину іменованих цілих констант. Перераховуваний тип даних оголошується за допомогою ключового слова enum . Нижче наведена загальна форма оголошення перерахування:

```csharp
enum ім'я {список_перерахування};
```

де ім'я — це ім'я типу перерахування, а список_перерахування — список ідентифікаторів, розділених комами. У наведеному нижче прикладі оголошується перерахування Apple різних сортів яблук.

```csharp
enum Apple { Jonathan, GoldenDel, RedDel, Winesap, Cortland, McIntosh };
```

Слід особливо підкреслити, що кожна символічно позначена константа у перерахуванні має ціле значення. Проте неявні перетворення перераховуваного типу вбудованими цілими типами і навпаки в C# не визначені, тому в таких випадках потрібне явне приведення типів. Крім того, приве дення типів потрібне при перетворенні двох перераховуваних типів. Але оскільки перерахування позначають цілі значення, їх можна, наприклад, використовувати для управління оператором вибору switch або оператором циклу for . Для кожної наступної символічно позначеної константи в переліку задається ціле значення, яке на одиницю більше, ніж у попередньої константи. За замовчуванням значення першої символічно позначеної константи в переліку дорівнює нулю. Отже, у наведеному вище прикладі переліку Apple константа Jonathan дорівнює нулю, константа GoldenDel— 1, константа RedDel— 2 і т.д.

Лістинг 12.9 - Приклад перелічення

```csharp
class EnumDemo
```

enum Apple

Jonathan, GoldenDel, RedDel, Winesap,

Cortland, McIntosh

```csharp
static void Main()
string[] color = {
```

"червоний",

"жовтий",

"червоний",

"червоний",

"червоний",

"червонозелений"

Apple i; // оголосити змінну перелічуваного типу

// Використовувати змінну i для циклічного

// звертання до членів переліку.

for (i = Apple.Jonathan; i <= Apple.McIntosh; i++)

```csharp
Console.WriteLine(i + " має значення " + (int)i);
Console.WriteLine();
```

// Використовувати перелік для індексування масиву.

for (i = Apple.Jonathan; i <= Apple.McIntosh; i++)

```csharp
Console.WriteLine("Колір сорту " + i + " - " +
```

color[(int)i]);

13 Обробка виняткових ситуацій

Виняткова ситуація, або просто виключення, виникає під час виконання. Використовуючи під систему обробки виняткових ситуацій в С#, можна обробляти структурованим і контрольованим способом помилки, що виникають під час виконання програми. Головна перевага обробки виняткових ситуацій полягає в тому, що вона дозволяє автоматизувати отримання більшої частини коду, який раніше доводилося вводити в будь -яку велику програму вручну для обробки помилок. Так, якщо програма написана на мові програмування без обробки виняткових ситуацій, то при невдачному виконанні методів доводиться повертати коди помилок, які необхідно перевіряти вручну при кожному виклику метода.

Це не тільки трудомісткий, але й повний помилок процес. Обробка виняткових ситуацій раціоналізу є весь процес обробки помилок, дозволяючи визначити у програмі блок коду, який називається обробником винятків і виконується автоматично, коли виникає помилка. Це звільняє від необхідності перевіряти вручну, наскільки успішно або неуспішно завершилась конкретна операція або виклик методу. Якщо виникне помилка, вона буде оброблена відповідним чином обробником помилок.

Обробка виняткових ситуацій важна ще й тому, що в С# визначені стандартні винятки для типових програмних помилок, наприклад ділення на нуль або вихід індексу за межі масиву. Для реагування на подібні помилки в програмі повинно бути організоване відстеження та обробка відповідних виняткових ситуацій. Адже в кінцевому рахунку для успішного програмування на C# необхідно навчитися вміло користуватися підсистемою обробки виняткових ситуацій.

У C# винятки представлені у вигляді класів. Всі класи винятків повинні бути похідними від вбудованого класу Exception, який є частиною простору імен System. Отже, всі винятки є підкласами класу Exception . До числа найважливіших підкласів Exception належить клас SystemException . Саме від цього класу походять всі винятки, що генеруються виконавчою системою C# (тобто системою CLR). Клас SystemException нічого не додає до класу Exception , а просто визначає вершину ієрархії стандартних винятків. У середовищі .NET Framework визначено кілька вбудованих виключень, які є похідними від класу SystemException . Наприклад, при спробі виконати ділення на нуль генерується виключення DivideByZeroException . Як буде показано далі в цьому розділі, в C# можна створювати власні класи виключень, похідні від класу Exception .

13.1 Основи обробки виняткових ситуацій

Обробка виняткових ситуацій в C# організовується за допомогою чотирьох ключових слів: try, catch, throw та finally. Вони утворюють взаємопов'язану підсистему, в якій застосування одного з ключових слів передбачає застосування іншого. Протягом цього розділу буде розглянуто призначення та застосування кожного згаданих вище ключових слів в деталях. Але спочатку необхідно дати загальне уявлення про роль кожного з них у обробці виняткових ситуацій. Тому нижче коротко описано принцип їх дії.

Оператори програми, які потрібно контролювати на появу винятків, заключаються в блок try. Якщо всередині блоку try виникає виняткова ситуація, генерується виняток. Цей виняток може бути перехоплений та оброблений якимось раціональним способом у коді програми за допомогою оператора, позначеного ключовим словом catch. Винятки, що виникають на рівні системи, генеруються виконавчою системою автоматично. А для генерування винятків вручну служить ключове слово throw. Будь-який код, який повинен бути обов'язково виконаний після виходу з блоку try , поміщається в блок finally.

Основу обробки виняткових ситуацій в C# складає пара ключових слів try і catch. Ці ключові слова діють разом і не можуть бути використані окремо. Нижче наведена загальна форма визначення блоків try/catch для обробки виняткових ситуацій.

Лістинг 13.1 - приклад try/catch

```csharp
try {
```

// Блок коду, перевіряється на наявність помилок.

```csharp
} catch (ExcepType1 exOb) {
```

// Обробник винятка типу ExcepType1.

```csharp
catch (ExcepType2 exOb) {
```

// Обробник винятка типу ExcepType2.

де ExcepType – це тип виникаючої виняткової ситуації. Коли виняток генерується оператором try , він перехоплюється його парним оператором catch , який потім обробляє цей виняток. Залежно від типу винятка виконується відповідний оператор catch. Так, якщо типи генеруємого винятка й того, що вказується в операторі catch , співпадають, то виконується саме цей оператор, а всі інші пропускаються. Коли виняток перехоплюється, змінна винятка exOb отримує своє значення.

Насправді, вказувати змінну ехОb необов'язково. Так, її необов'язково вказувати, якщо обробнику винятків не потрібний доступ до об'єкту винятка, що часто буває. Для обробки винятка достатньо знати його тип. Саме тому в багатьох прикладах програм, наведених у цій главі, змінна ехОb пропускається.

Слід, однак, мати на увазі, що якщо виняток не генерується, то блок оператора try завершується як звичайно, і всі його оператори catch пропускаються. Виконання програми продовжується з першого оператора, що йде після завершального оператора catch. Таким чином, оператор catch виконується лише у випадку, якщо генерується виняток.

Розглянемо простий приклад, що демонструє відстеження та перехоплення винятка. Як вам має бути вже відомо, спроба індексувати масив за його межами призводить до помилки. Коли виникає подібна помилка, система CLR генерує виняток IndexOutOfRangeException, який визначений як стандартний для середовища .NET Framework. У наведеній нижче програмі такий виняток генерується навмисно і потім перехоплюється.

Лістинг 13.2 - Приклад перехоплення виключення IndexOutOfRangeException

```csharp
using System;
class ExcDemol
static void Main()
```

int[] nums = new int[4];

try

```csharp
Console.WriteLine("Перед генеруванням винятка.");
```

// Сгенерувати виняток у зв'язку з виходом індексу за межі масиву.

for (int i = 0; i < 10; i++)

nums[i] = i;

```csharp
Console.WriteLine("nums[{0)]: {1}", i, nums[i]);
Console.WriteLine("He підлягає виводу");
```

catch (IndexOutOfRangeException)

// Перехопити виняток.

```csharp
Console.WriteLine("Індекс вийшов за межі масиву!");
Console.WriteLine("Після блоку перехоплення винятка.");
```

У даному прикладі масив nums типу int складається з чотирьох елементів. Але в циклі for приймається спроба індексувати цей масив від 0 до 9, що і призводить до появи винятка IndexOutOfRangeException , коли звертається до елементу масиву за індексом 4. Незважаючи на всю свою краткість, наведений вище приклад наочно демонструє ряд основних моментів процесу обробки виняткових ситуацій. По-перше, код, який потрібно контролювати на наявність помилок, міститься в блоку try . По-друге, коли виникає виняткова ситуація (у даному випадку - при спробі індексувати масив nums за його межами в циклі for ), в блоку try генерується виняток, який потім перехоплюється в блоку catch . В цей момент виконання коду в блоку try завершується і керування передається блоку catch . Це означає, що оператор catch не викликається спеціально, а виконання коду переходить до нього автоматично. Отже, оператор, що містить метод WriteLine() і йде безпосередньо після циклу for , де відбувається вихід індексу за межі масиву, взагалі не виконується. А в завдання обробника винятків входить виправлення помилки, що призвела до виняткової ситуації, щоб продовжити виконання програми в нормальному режимі.

Зверніть увагу на те, що в операторі catch вказано лише тип винятку (у даному випадку — IndexOutOfRangeException ), а змінна винятку відсутня. Як зазначалося раніше, змінну винятку потрібно вказувати лише у випадку, якщо потрібний доступ до об'єкту винятку. У деяких випадках значення об'єкта винятку може бути використано обробником винятків для отримання додаткової інформації про саму помилку , але часто для обробки виняткової ситуації достатньо просто знати, що вона сталася . Тому змінна винятку часто відсутня в обробниках винятків, як у розглянутому тут прикладі.

Слід особливо підкреслити, що весь код, що виконується в блоку try, контролюється на предмет виняткових ситуацій, включаючи ті, які можуть виникнути в результаті виклику методу з самого блоку try. Виняток, що генерується методом в блоку try, може бути перехоплений в тому ж блоку, якщо, звичайно, цього не буде зроблено в самому методі.

Як ще один приклад розглянемо наступну програму, де блок try розміщується в методі Main() . З цього блоку викликається метод GenException() , в якому генерується виняток IndexOutOfRangeException. Цей виняток не перехоплюється методом GenException() . Але оскільки метод GenException() викликається з блоку try в методі Main() , то виняток перехоплюється в блоку catch , пов'язаному безпосередньо з цим блоком try .

Лістинг 13.3 - Виняток може бути згенерований одним методом і перехоплений іншим

```csharp
class ExcTest
```

// Згенерувати виняток.

```csharp
public static void GenException()
```

int[] nums = new int[4];

```csharp
Console.WriteLine("Перед генеруванням винятка.");
```

// Згенерувати виняток через вихід індексу за межі

масиву.

for (int i = 0; i < 10; i++)

nums[i] = i;

```csharp
Console.WriteLine("nums [{0}] : {1}", i, nums[i]);
Console.WriteLine("He підлягає виводу");
class ExcDemo2
static void Main()
```

try

ExcTest.GenException();

catch (IndexOutOfRangeException)

// Перехопити виняток.

```csharp
Console.WriteLine("Індекс вийшов за межі масиву!");
Console.WriteLine("Після блоку перехоплення винятка.");
```

Як пояснювалося вище, метод GenException() викликається з блоку try, і тому генероване ним виняток перехоплюється не в ньому, а в блоку catch всередині методу Main(). А якби виняток перехоплювався в методі GenException(), він не був би переданий назад методу Main().

13.2 Наслідки неперехоплення винятків

Перехоплення одного зі стандартних винятків, як у вищезазначених прикладах, дає ще одну перевагу: воно уникне аварійного завершення програми. Як тільки виняток буде згенеровано, його потрібно перехопити якимось фрагментом коду в певному місці програми. Загалом, якщо виняток не перехоплюється в програмі, то його перехопить виконуюча система. Але справа в тому, що виконуюча система видасть повідомлення про помилку і припинить виконання програми. Так, у наведеному нижче прикладі програми виняток у зв'язку з виходом індексу за межі масиву не перехоплюється.

Лістинг 13.4 - Надати можливість виконавчій системі C# обробляти помилки самостійно

```csharp
using System;
class NotHandled
static void Main()
```

int[] nums = new int[4];

```csharp
Console.WriteLine("Перед генеруванням винятка.");
```

// Сгенерувати виняток у зв'язку з виходом індексу за межі масиву.

for (int i = 0; i < 10; i++)

nums[i] = i;

```csharp
Console.WriteLine("nums[{0}]: {1}", i, nums[i]);
```

Коли виникає помилка індексування масиву, виконання програми припиняється і виводиться наступне повідомлення про помилку. Необроблене виняткове ситуація: System.IndexOutOfRangeException: Індекс знаходився поза межами масиву. в NotHandled.Main() в <ім'я_файлу>:рядок 16 Це повідомлення повідомляє про виявлення в методі NotHandled.Main() необробленого винятку типу System.IndexOutOfRangeException , яке пов'язане з виходом індексу за межі масиву. Такі повідомлення про помилки корисні для налагодження програми, але, принаймні, небажані при її використанні на практиці! Тому так важливо організувати обробку виняткових ситуацій у самій програмі.

Як зазначалося раніше, тип генерованого винятку повинен відповідати типу, вказаному в операторі catch. У протилежному випадку виняток не буде перехоплено. Наприклад, у наведеній нижче програмі здійснюється спроба перехопити помилку порушення меж масиву в блоку catch, що реагує на виняток DivideByZeroException, пов'язаний з діленням на нуль і є ще одним стандартним винятком. Коли індексування масиву виходить за його межі, генерується виняток IndexOutOfRangeException, але він не буде перехоплено блоком catch, що призведе до аварійного завершення програми.

Лістинг 13.5 - Приклад перехоплення не того виключення

```csharp
class ExcTypeMismatch
static void Main()
```

int[] nums = new int[4];

try

```csharp
Console.WriteLine("Перед генеруванням винятка.");
```

// Сгенерувати виняток у зв'язку з виходом індексу за межі масиву.

for (int i = 0; i < 10; i++)

nums[i] = i;

```csharp
Console.WriteLine("nums[{0}]:{1}", i, nums[i]);
Console.WriteLine("He підлягає виводу");
```

/* Якщо перехоплення розраховане на виняток DivideByZeroException,

то перехопити помилку порушення межі масиву не вдасться. */

catch (DivideByZeroException)

// Перехопити виняток.

```csharp
Console.WriteLine("Індекс вийшов за межі масиву!");
Console.WriteLine("Після блоку перехоплення винятка.");
```

Як видно з наведеного вище результату, в блоку catch, реагуючому на виняток DivideByZeroException, не вдалося перехопити виняток IndexOutOfRangeException.

13.3 Обробка виняткових ситуацій - “елегантний” спосіб усунення програмних помилок

Однією з основних переваг обробки виняткових ситуацій є те, що вона дозволяє вчасно реагувати на помилку в програмі і потім продовжувати її виконання. Як приклад розглянемо ще одну програму, в якій елементи одного масиву діляться на елементи іншого. Якщо при цьому відбувається ділення на нуль, то генерується виняток DivideByZeroException . Обробка подібної виняткової ситуації полягає в тому, що програма повідомляє про помилку і потім продовжує своє виконання. Таким чином, спроба ділення на нуль не призведе до аварійного завершення програми через помилку при її виконанні. Замість цього помилка обробляється "елегантно", не перериваючи виконання програми.

Лістинг 13.6 - Приклад обробки винятків

```csharp
using System;
class ExcDemo3
static void Main()
int[] numer = { 4, 8, 16, 32, 64, 128 };
int[] denom = { 2, 0, 4, 4, 0, 8 };
```

for (int i = 0; i < numer.Length; i++)

try

```csharp
Console.WriteLine(numer[i] + " / " +
```

denom[i] + " дорівнює " +

numer[i] / denom[i]);

catch (DivideByZeroException)

// Перехопити виняток.

```csharp
Console.WriteLine("Ділити на нуль не можна!");
```

З даного прикладу випливає ще один важливий висновок: як тільки виняток оброблено, він видаляється з системи. Тому в наведеній вище програмі перевірка помилок у блоку try починається знову на кожному кроці циклу for, за умови, що всі попередні виняткові ситуації були оброблені. Це дозволяє обробляти в програмі повторювані помилки.

13.4 Застосування кількох операторів catch

З одним оператором try можна пов'язати кілька операторів catch . І на прак тиці це робиться досить часто. Але всі оператори catch повинні перехоплювати винятки різного типу. Як приклад нижче наведена програма, в якій перехоплюються помилки виходу за межі масиву та ділення на нуль.

Лістинг 13.7 - Приклад обробки декількох винятків

```csharp
class ExcDemo4
static void Main()
```

// Тут масив numer довший за масив denom.

```csharp
int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };
int[] denom = { 2, 0, 4, 4, 0, 8 };
```

for (int i = 0; i < numer.Length; i++)

try

```csharp
Console.WriteLine(numer[i] + " / " +
```

denom[i] + " дорівнює " +

numer[i] / denom[i]);

catch (DivideByZeroException)

```csharp
Console.WriteLine("Ділити на нуль не можна!");
```

catch (IndexOutOfRangeException)

```csharp
Console.WriteLine("Підходящий елемент не знайдено.");
```

Як випливає з вищезазначеного результату, кожен оператор catch реагує тільки на свій тип винятку. Загалом, оператори catch виконуються в порядку їх послідовності в про грамі. Але виконується тільки один блок catch, в якому тип винятку співпадає з типом генерованого винятку. А всі інші блоки catch пропускаються.

13.5 Перехоплення всіх винятків

Час від часу виникає потреба в перехопленні всіх винятків незалежно від їх типу. Для цієї цілі служить оператор catch, в якому тип і змінна винятку не вказуються. Нижче наведена загальна форма такого оператора. За допомогою такої форми створюється "універсальний" обробник всіх винятків, які перехоплюються в програмі. Нижче наведено приклад такого "універсального" обробника винятків. Зверніть увагу на те, що він перехоплює і обробляє обидва винятки, IndexOutOfRangeException і DivideByZeroException , які генеруються в програмі.

Лістинг 13.8 - Приклад обробки всіх винятків

```csharp
class ExcDemo5
static void Main()
```

// Тут масив numer довший за масив denom.

```csharp
int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };
int[] denom = { 2, 0, 4, 4, 0, 8 };
```

for (int i = 0; i < numer.Length; i++)

try

```csharp
Console.WriteLine(numer[i] + " / " +
```

denom[i] + " дорівнює " +

numer[i] / denom[i]);

catch

```csharp
{ // "Універсальний" перехоплювач.
Console.WriteLine("Виникла деяка виняткова ситуація.");
```

Застосовуючи "універсальний" перехоплення, слід мати на увазі, що його блок повинен розташовуватися останнім за порядком серед усіх блоків catch.

13.6 Вкладення блоків try

Один блок try може бути вкладений в інший. Виняток, генерований у внутрішньому блоку try і не перехоплений у відповідному блоку catch, передається у зовнішній блок try. Нижче наведено приклад програми, в якій виняток IndexOutOfRangeException перехоплюється не у внутрішньому, а у зовнішньому блоку try.

Лістинг 13.9 - Використовувати вкладений блок try.

```csharp
using System;
class NestTrys
static void Main()
```

// Тут масив numer довший за масив denom.

```csharp
int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };
int[] denom = {2, 0, 4, 4, 0, 8};
```

try

```csharp
{ // зовнішній блок try
```

for (int i = 0; i < numer.Length; i++)

try

```csharp
{ // вкладений блок try
Console.WriteLine(numer[i] + " / " +
```

denom[i] + " дорівнює " +

numer[i] / denom[i]);

catch (DivideByZeroException)

```csharp
Console.WriteLine("Ділити на нуль не можна!");
```

catch (IndexOutOfRangeException)

```csharp
Console.WriteLine("Підходящий елемент не знайдено.");
Console.WriteLine("Незворотна помилка  програма перервана.");
```

У даному прикладі виняток, який обробляється внутрішнім блоком try і пов'язаний з помилкою через ділення на нуль, не заважає подальшому виконанню програми. Але помилка в порушенні меж масиву, виявлена в зовнішньому блоку try, призводить до переривання програми. Безумовно, наведений вище приклад демонструє далеко не єдине підставу для застосування вкладених блоків try , проте з нього можна зробити важливий загальний висновок.

Вкладені блоки try часто застосовуються для обробки різних категорій помилок різними способами. Зокрема, деякі помилки вважаються незворотними і не підлягають виправленню, а інші помилки незначні і можуть бути оброблені негайно. Зазвичай, зовнішній блок try служить для виявлення обробки найсерйозніших помилок, а внутрішні блоки try обробляються менш серйозні помилки. Крім того, зовнішній блок try може стати " універсальним " для тих помилок, які не підлягають обробці внутрішнім блоком.

13.7 Генерація винятків вручну

У вищезазначених прикладах перехоплювалися винятки, що генерувалися виконавчою системою автоматично. Але виняток може бути згенерований вручну за допомогою оператора throw. Нижче наведена загальна форма такої гене рації: throw exceptOb; де як exceptOb повинен бути позначений об'єкт класу винятків, похідного від класу Exception . Нижче наведений приклад програми, в якій демонструється застосування оператора throw для генерації винятка DivideByZeroException .

Лістинг 13.10 - Генерація винятків вручну

```csharp
using System;
class ThrowDemo
static void Main()
try {
Console.WriteLine("Перед генерацією винятку.");
```

throw new DivideByZeroException();

catch (DivideByZeroException)

```csharp
Console.WriteLine("Виняток перехоплено.");
Console.WriteLine("Після пари операторів try/catch.");
```

Зверніть увагу на те, що виняток DivideByZeroException був створений за допомогою ключового слова new у операторі throw . Не слід забувати, що в даному випадку генерується конкретний об'єкт, а отже, він повинен бути створений перед генерацією винятку. Це означає, що генерувати виняток тільки за його типом неможливо. У даному прикладі для створення об'єкта DivideByZeroException був автоматично викликаний конструктор, який використовується за замовчуванням, хоча для генерації винятків доступні й інші конструктори.

Виняток, перехоплений в одному блоку catch , може бути повторно згенеровано в іншому блоку, щоб бути перехопленим у зовнішньому блоку catch . Найбільш ймовірною причиною для повторного генерування винятка є надання доступу до винятка декільком обробникам. Припустимо, що один обробник оперує якимось одним аспектом винятка, а інший обробник - іншим його аспектом. Для повторного генерування винятка достатньо вказати оператор throw без супровідного виразу, як у наведеній нижче формі.

Лістинг 13.11 - Згенерувати виняток повторно

```csharp
class Rethrow
public static void GenException()
```

// Тут масив numer довший за масив denom.

```csharp
int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };
int[] denom = { 2, 0, 4, 4, 0, 8 };
for (int i = 0; i < numer.Length; i++) {
```

try

```csharp
Console.WriteLine(numer[i] + " / " +
```

denom[i] + " дорівнює " +

numer[i] / denom[i]);

catch (DivideByZeroException)

```csharp
Console.WriteLine("Ділити на нуль не можна!");
```

catch (IndexOutOfRangeException)

```csharp
Console.WriteLine("Підходящий елемент не знайдено.");
```

throw; // згенерувати виняток повторно

```csharp
class RethrowDemo
static void Main()
```

try

Rethrow.GenException();

catch (IndexOutOfRangeException)

// перехопити виняток повторно

```csharp
Console.WriteLine("Незворотна помилка  програма перервана.");
```

У цьому прикладі програми помилки через ділення на нуль обробляються локаль но в методі GenException(), але помилка виходу за межі масиву генерується повторно. У даному випадку виняток IndexOutOfRangeException обробляється в методі Main().

13.8 Використання блоку finally

Іноді потрібно визначити кодовий блок, який буде виконуватися після виходу з блоку try/catch . Зокрема, виняткова ситуація може виникнути у зв'язку з помилкою, що призводить до передчасного повернення з поточного методу. Але в цьому методі може бути відкритий файл, який потрібно закрити, або встановлене мережеве з'єднання, яке потребує розриву. Подібні ситуації не рідкість у програмуванні, тому для їх вирішення в C# передбачений зручний спосіб: скористатися блоком finally.

Щоб вказати кодовий блок, який має виконуватися після блоку try/catch, достатньо вставити блок finally в кінець послідовності операторів try/catch. Нижче наведена загальна форма спільного використання блоків try/ catchі finally.

Лістинг 13.12 - Приклад структури try catch finally

try

// Блок коду, призначений для обробки помилок.

catch (ExcepType1 exOb)

// Обробник винятку типу ExcepType1.

catch (ExcepType2 ехОb)

// Обробник винятку типу ЕхсерТуре2.

finally

// Код завершення обробки винятків.

Блок finally буде виконуватися кожного разу, коли відбувається вихід з блоку try/ catch, незалежно від причин, які до цього призвели. Це означає, що якщо блок try завершується нормально або через виняток, то останнім виконується код, визначений у блоку finally. Блок finally виконується і у випадку, якщо будь-який код у блоку tryабо в пов'язаних з ним блоках catch призводить до повернення з методу.

13.9 Отримання похідних класів винятків

Незважаючи на те, що вбудовані винятки охоплюють найпоширен ші програмні помилки, обробка виняткових ситуацій в C# не обмежується тільки цими помилками . Насправді, однією з сильних сторін прийнятого в C# підходу до обробки виняткових ситуацій є те, що в цій мові дозволяється використовувати винятки, визначені користувачем, тобто тими, хто про грамує на С#. Зокрема, такі спеціальні винятки можна використовувати для обробки помилок у власному коді, а створюються вони дуже просто. Для цього достатньо визначити клас, похідний від класу Exception . У таких класах зов сім не обов'язково щось реалізовувати — одного лише їх існування в систе мі типів вже достатньо, щоб використовувати їх як винятки.

Створювані користувачем класи автоматично отримуватимуть властивості та мето ди, визначені в класі Exception і доступні для них. Звичайно, будь-який з цих членів класу Exception можна перевизначити в створюваних класах винятків. Коли створюється власний клас винятків, зазвичай бажано, щоб в ньому підтримувалися всі конструктори, визначені в класі Exception . У простих спеціальних класах винятків цього нескладно досягти, оскільки для цього достатньо передати відповідні аргументи відповідному конструктору класу Exception , використовуючи ключове слово base . Але формально потрібно надати лише ті конструктори, які фактично використовуються в програмі.

Розглянемо приклад програми, в якій використовується виняток спеціального типу. Нагадаємо, що в кінці глави 10 був розроблений клас RangeArray , що підтримує одновимірні масиви, в яких початковий і кінцевий індекси визначаються користувачем. Так, наприклад, повністю допустимим вважається масив, індексований в межах від -5 до 27. Якщо ж індекс виходив за межі масиву, то для обробки цієї помилки в класі RangeArray була визначена спеціальна змінна. Така змінна встановлювалась і перевірялась після кожної операції доступу до масиву в коді, що використовував клас RangeArray. Безумовно, такий підхід до обробки помилок "незграбний" і повний додаткових помилок. У наведеному нижче вдосконаленому варіанті класу RangeArray обробка помилок порушення меж масиву виконується більш елегантним і надійним способом за допомогою спеціально генерованого винятку.

Лістинг 13.13 - Створити виняток для класу RangeArray.

```csharp
class RangeArrayException : Exception
```

/* Реалізувати всі конструктори класу Exception. Такі конструктори просто

реалізують конструктор базового класу. А оскільки клас винятка

RangeArrayException нічого не додає до класу Exception, то ніяких

додаткових дій не потрібно. */

```csharp
public RangeArrayException() : base() { }
public RangeArrayException(string str) : base(str) { }
```

public RangeArrayException(

```csharp
string str, Exception inner) : base(str, inner) { }
```

protected RangeArrayException(

System.Runtime.Serialization.SerializationInfo si,

System.Runtime.Serialization.StreamingContext sc) :

base(si, sc)

```csharp
{ }
```

// Перевизначити метод ToString() для класу винятка RangeArrayException.

public override string ToString()

return Message;

Зверніть увагу на те, що в тілі конструкторів класу винятка RangeArrayException відсутні будь-які оператори, але замість цього вони просто передають свої аргументи класу Exception , використовуючи ключове слово base . Як пояснювалося раніше, у тих випадках, коли похідний клас винятків не доповнює функції базового класу, весь процес створення винятків можна покласти на кон структори класу Exception . Адже похідний клас винятків зовсім не обов'язково повинен щось доповнювати функції, успадковані від класу Exception . Перш ніж переходити до подальшого читання, спробуйте трохи експериментувати з наведеною вище програмою. Зокрема, спробуйте закоментувати перевизначення методу ToString() і спостерігайте за результатами. Крім того, спробуйте створити виняток, використовуючи конструктор, який викликається за замовчуванням, і подивіться, яке повідомлення при цьому сформується стандартними засобами C#.

13.10 Перехоплення винятків похідних класів

При спробі перехопити типи винятків, що належать як до базових, так і до похідних класів, слід особливо уважно дотримуватися порядку слідування операторів catch , оскільки перехоплення винятка базового класу буде співпадати з перехопленням винятків будь-яких його похідних класів. Наприклад, клас Exception є базовим для всіх винятків, і тому разом з винятком типу Exception можуть бути перехоплені і всі інші винятки похідних від нього класів. Звичайно, для більш чіткого перехоплення всіх винятків можна скористатися згаданою раніше формою оператора catch без вказання конкретного типу винятка. Але питання перехоплення винятків похідних класів стає дуже актуальним і в інших ситуаціях, особливо при створенні власних винятків. Якщо потрібно перехоплювати винятки базового і похідного класів, то першим за порядком повинен йти оператор catch , який перехоплює виняток похідного класу. Це правило необхідно дотримуватися, оскільки при перехопленні винятка базового класу також будуть перехоплені винятки всіх похідних від нього класів. Справді , це правило дотримується автоматично: якщо першим розташувати в коді оператор catch , який перехоплює виняток базового класу, то під час компіляції цього коду буде видано повідомлення про помилку. У наведеному нижче прикладі програм створюються два класи винятків: ExceptA і ExceptB . Клас ExceptA є похідним від класу Exception , а клас ExceptB — похідним від класу ExceptA . Потім у програмі генеруються винятки кожного типу. З метою кратності в класах спеціальних винятків надається лише один конструктор, що приймає символьний рядок, що описує виняток. Але при розробці програм комерційного призначення в класах спеціальних винятків зазвичай потрібно надавати всі чотири конструктори, визначені в класі Exception.

Лістинг 13.14 - Приклад обробки своїх виключень

```csharp
class ExceptA : Exception
public ExceptA(string str) : base(str) { }
```

public override string ToString()

return Message;

// Створити клас винятка, похідний від класу ExceptA.

```csharp
class ExceptB : ExceptA
public ExceptB(string str) : base(str) { }
```

public override string ToString()

return Message;

```csharp
class OrderMatters
static void Main()
```

for (int x = 0; x < 3; x++)

try

if (x == 0) throw new ExceptA("Перехоплення винятка типу ExceptA");

else if (x == 1) throw new ExceptB("Перехоплення винятка типу ExceptB");

else throw new Exception();

catch (ExceptB exc)

```csharp
Console.WriteLine(exc);
```

catch (ExceptA exc)

```csharp
Console.WriteLine(exc);
```

catch (Exception exc)

```csharp
Console.WriteLine(exc);
```

Зверніть увагу на порядок виконання операторів catch . Саме в такому порядку вони й повинні виконуватися. Клас ExceptB є похідним від класу ExceptA , тому виняток типу ExceptB повинен перехоплюватися перед винятком типу ExceptA . Аналогічно, виняток типу Exception (тобто базового класу для всіх винятків) повинен перехоплюватися останнім. Для того, щоб переконатися в цьому, змініть порядок виконання операторів catch . В результаті це призведе до помилки під час компіляції. Прикладом використання оператора catch , який перехоплює винятки базового класу, є перехоплення всієї категорії винятків. Припустимо, що створюється низка винятків для керування певним пристроєм. Якщо зробити їх класами, що походять від загального базового класу, то в додатках, де не обов'язково визначати конкретну причину виникнення помилки, достатньо перехоплювати виняток базового класу і таким чином уникнути непотрібного дублювання коду.

13.11 Застосування ключових слів checked та unchecked

У C# є спеціальний засіб, пов'язаний з генерацією винятків, що виникають при переповненні в арифметичних обчисленнях. Як вам має бути відомо, результати деяких видів арифметичних обчислень можуть перевищувати діапазон представлення чисел для типу даних, що використовується в обчисленні. У цьому випадку відбувається так зване переповнення. Розглянемо як при клад наступний фрагмент коду.

У C# допускається вказувати, чи буде в коді згенеровано виняток при переповненні, за допомогою ключових слів checked і unchecked . Так, якщо потрібно вказати, що вираз буде перевірятися на переповнення, слід використовувати ключове слово checked , а якщо потрібно проігнорувати переповнення - ключове слово unchecked . У останньому випадку результат обрізається, щоб не вийти за межі діапазону представлення чисел для цільового типу виразу. У ключового слова checked є дві загальні форми. У одній формі перевіряється конкретний вираз, тому вона називається операторною. У іншій формі перевіряється блок операторів, тому вона називається блочною. Нижче наведені обидві форми:

checked (вираз)

```csharp
checked { // перевіряються оператори }
```

де вираз означає перевіряючий вираз. Якщо обчислення перевіряючого виразу призводить до переповнення, то генерується виняток OverflowException . У ключового слова unchecked також є дві загальні форми. У першій, операторній формі переповнення ігнорується при обчисленні конкретного виразу. У другій, блочній формі вона ігнорується при виконанні блоку операторів:

unchecked (вираз )

```csharp
unchecked { // оператори, для яких переповнення ігнорується }
```

де вираз означає конкретний вираз, при обчисленні якого переповнення ігнорується . Якщо в неперевіреному виразі відбувається переповнення, то результат його обчислення обрізається.

Лістинг 13.15 - Демонстрація застосування ключових слів checked і unchecked

```csharp
class CheckedDemo
static void Main()
```

byte a, b;

byte result;

a = 127;

b = 127;

try

result = unchecked((byte)(a * b));

```csharp
Console.WriteLine("Неперевірений на переповнення результат: " +
```

result);

result = checked((byte)(a * b)); // ця операція призводить до

// виключної ситуації

```csharp
Console.WriteLine("Перевірений на переповнення результат: " +
```

result); //не підлягає виконанню

catch (OverflowException exc)

```csharp
Console.WriteLine(exc);
```

---

[◀️ До змісту](../README.md)
