# Простори імен, препроцесор і збірки

[◀️ До змісту лекцій](README.md)

---

16.1 Простори імен

Про простір імен вже коротко згадувалося в розділі 2 у зв'язку з тим, що це основне поняття для C#. Насправді простір імен в тій або іншій мірі використовується в кожній програмі на C#. Потреба у докладному розгляді просторів імен не виникала до цього часу, тому що для кожної програми на C# автоматично надається використовуване за замовчуванням глобальне простір імен. Отже, в прикла дах програм, представлених у попередніх розділах, використовувалося глобальне простір імен. Але в багатьох реальних програмах доводиться створювати власні простори імен або організовувати взаємодію з іншими просторами імен. Подібні простори будуть представлені далі у всіх деталях.

Простір імен визначає область оголошень, в якій допускається зберігати один набір імен від окремо від іншого. По суті, імена, оголошені в одному просторі імен, не будуть конфліктувати з аналогічними іменами, оголошеними в іншій області. Так, у бібліотеці класів для середовища .NET Framework, яка одночасно є бібліотекою класів C#, використовується простір імен System . Саме тому рядок коду

```csharp
using System;
```

зазвичай вводиться на початку будь-якої програми на C#. Як пояснювалося в розділі 14, класи введення-виведення визначені в просторі імен System.IO , підпорядкованому простору імен System . До нього підпорядковані багато інших просторів імен, що належать до різних частин бібліотеки класів C#. Простори імен є важливими, оскільки в останні роки в програмуванні " розмножилися " в великій кількості імена змінних, методів, властивостей та класів, що використовуються в бібліотечних програмах, сторонньому та власному коді. Тому без окремих просторів всі ці імена будуть конкурувати за місце в глобальному просторі імен, створюючи конфліктні ситуації. Наприклад, якщо в програмі визначено клас Finder, то цей клас може конфліктувати з іншим класом Finder , доступним у сторонній бібліотеці, що використовується в цій програмі. На щастя, такий конфлікт можна уникнути, використовуючи окремі простори імен, що обмежують область видимості оголошених у них імен.

16.2 Оголошення простору імен

Простір імен оголошується за допомогою ключового слова namespace. Нижче наведена загальна форма оголошення простору імен:

```csharp
namespace ім'я { // члени }
```

де ім'я позначає конкретне ім'я оголошуваного простору імен. При оголошенні простору імен визначається його область дії. Все, що оголошується безпосередньо в цьому просторі, потрапляє в межі його області дії. У просторі імен можна оголосити класи, структури, делегати, перелічення, інтерфейси або інші простори імен.

```csharp
Нижче наведено приклад оголошення namespace для створення простору імен Counter. У цьому просторі локалізується ім'я, що використовується для реалізації простого класу віднімання лічильника CountDown.
```

Лістинг 16.01 - Приклад простого класу віднімання лічильника CountDown

```csharp
namespace Counter { // Простий віднімаючий лічильник. class CountDown { int val; public CountDown(int n) { val = n; } public void Reset(int n) { val = n; } public int Count() { if (val > 0) return val++; else return 0; } } }
```

Зверніть увагу на те, що клас CountDown оголошується в межах області дії простору імен Counter. Для того, щоб проробити цей приклад на практиці, помістіть наведений вище код у файл Counter.cs. Нижче наведено приклад програми, що демонструє застосування простору імен Counter.

Лістинг 16.2 - Використання класу в просторі імен

```csharp
using System; class NSDemo { static void Main() { // Зверніть увагу на те, як клас CountDown // визначається за допомогою простору імен Counter. Counter.CountDown cd1 = new Counter.CountDown(10); int i; do { i = cd1.Count(); Console.Write(i + " "); } while(i > 0); Console.WriteLine(); // Знову зверніть увагу на те, як клас CountDown // визначається за допомогою простору імен Counter. Counter.CountDown cd2 = new Counter.CountDown(20); do { i = cd2.Count(); Console.Write(i + " "); } while(i > 0); Console.WriteLine(); cd2.Reset(4); do { i = cd2.Count(); Console.Write(i + " "); } while(i > 0); Console.WriteLine(); } }
```

16.3 Уникнення конфліктів імен за допомогою просторів імен

Головна перевага просторів імен полягає в тому, що оголошені в них імена не конфліктують з іменами, оголошеними поза їх межами. Наприклад, у наведеній нижче програмі визначаються два простори імен. Першим з них є раніше представлений простір імен Counter, а другим — Counter2. Обидва простори імен містять класи з однаковим ім'ям CountDown , але оскільки це різні простори, то обидва класи CountDown не конфліктують один з одним. Крім того, обидва простори імен визначені в одному і тому ж файлі. Як пояснювалося вище, це абсолютно допустимо. Безумовно, кожен з цих просторів імен можна було б виділити в окремий файл, якби виникла потреба.

Лістинг 16.3 - приклад декількох класів в різних просторах імен

```csharp
// Оголосити простір імен Counter. namespace Counter { // Простий віднімаючий лічильник. class CountDown { int val; public CountDown(int n) { val = n; } public void Reset(int n) { val = n; } public int Count() { if(val > 0) return val++; else return 0; } } } // Оголосити простір імен Counter2. namespace Counter2 { /* Цей клас CountDown належить до простору імен Counter2 і тому не конфліктує з аналогічним класом з простору імен Counter. */ class CountDown { public void Count() { Console.WriteLine("Це метод Count() з " + "простору імен Counter2."); } } } class NSDemo2 { static void Main() { // Це клас CountDown з простору імен Counter. Counter.CountDown cd1 = new Counter.CountDown(10); // Це клас CountDown з простору імен Counter2. Counter2.CountDown cd2 = new Counter2.CountDown(); int i; do { i = cd1.Count(); Console.Write(i + " "); } while(i > 0); Console.WriteLine(); cd2.Count(); } }
```

Як видно з результату, клас CountDown з простору імен Counter існує окремо від класу з такою самою назвою з простору імен Counter2, тому конфлікт імен не виникає. Незважаючи на простоту цього прикладу, він наочно демонструє, як удається уникнути конфлікту імен у власному коді та коді, написаному іншими розробниками, розмістивши класи з однаковими назвами в різні простори імен.

16.4 Директива using

```csharp
Якщо в програмі часто використовуються посилання на члени конкретного простору імен, то вказувати цей простір імен кожного разу, коли потрібне посилання на нього, не дуже зручно. Директива using допомагає подолати це ускладнення. У більшості прикладів програм, які були наведені раніше, за допомогою цієї директиви було зроблено видимим глобальний простір імен System для C#, тому вона вже вам знайома. Як і очікувалося, за допомогою директиви using можна зробити видимими новостворені простори імен. Існують дві форми директиви using. Нижче наведена перша з них:
using ім'я;
де ім'я означає ім'я простору імен, до якого потрібно отримати доступ. Всі члени, визначені в зазначеному просторі імен, стають видимими і, отже, можуть використовуватися без додаткового визначення їх імені. Директиву using необхідно вводити на початку кожного файлу вихідного коду перед будь-якими іншими оголошеннями або на початку тіла простору імен. Наведена нижче програма є варіантом попереднього прикладу, переробленим з метою продемонструвати застосування директиви using, що робить видимим створюваний простір імен.
```

Лістинг 16.04 - Приклад використання директиви using

```csharp
using System; // Зробити видимим простір імен Counter. using Counter; // Оголосити простір імен для лічильників. namespace Counter { // Простий віднімаючий лічильник. class CountDown { int val; public CountDown(int n) { val = n; } public void Reset(int n) { val = n; } public int Count() { if(val > 0) return val++; else return 0; } } } class NSDemo3 { static void Main() { // Тепер клас CountDown може бути використаний безпосередньо. CountDown cd1 = new CountDown(10); int i; do { i = cd1.Count(); Console.Write(i + " "); } while(i > 0); Console.WriteLine(); CountDown cd2 = new CountDown(20); do { i = cd2.Count(); Console.Write(i + " "); } while(i > 0); Console.WriteLine(); cd2.Reset(4); do { i = cd2.Count(); Console.Write(i + " "); } while(i > 0); Console.WriteLine(); } }
У цій версії програми внесено дві суттєві зміни. Перше з них полягає в застосуванні директиви using на початку програми, як показано нижче. using Counter; Завдяки цьому стає видимим простір імен Counter. Друга зміна полягає в тому, що клас CountDown більше не потрібно додатково визначати з допомогою простору імен Counter, як показано нижче в рядку коду з методу Main(). CountDown cd1 = new CountDown(10); Тепер простір імен Counter становиться видимим , і тому клас CountDown може бути використаний безпосередньо.
```

Розглянута тут програма ілюструє ще одну важливу обставину: застосування одного простору імен не скасовує дію іншого. Коли простір імен стає видимим, це просто дає можливість використовувати його вміст без додаткового визначення імені. Отже, у цьому прикладі обидва простори імен, System і Counter , стають видимими.

```csharp
Друга форма директиви using дозволяє визначити ще одне ім'я (так зване псевдонім ) типу даних або простору імен. Ця форма наведена нижче:
using псевдонім = ім'я;
```

Де псевдонім становиться ще одним ім'ям типу (наприклад, класу) або про стору імен, позначеного як ім'я. Після того, як псевдонім буде створений, його можна використовувати замість початкового імені. Нижче наведено варіант програми з попереднього прикладу, змінений з метою показати створення та використання псевдоніма MyCounter замість складеного імені Counter.CountDown.

Лістинг 16.05 - Приклад використання псевдоніма

```csharp
// Створити псевдонім для складеного імені Counter.CountDown. using MyCounter = Counter.CountDown; class NSDemo4 { static void Main() { // Тут і надалі псевдонім MyCounter використовується // замість складеного імені Counter.CountDown. MyCounter cd1 = new MyCounter(10); int i; do { i = cd1.Count(); Console.Write(i + " "); } while(i > 0); Console.WriteLine(); MyCounter cd2 = new MyCounter(20); do { i = cd2.Count(); Console.Write(i + " "); } while(i > 0); Console.WriteLine(); cd2.Reset(4); do { i = cd2.Count(); Console.Write(i + " "); } while(i > 0); Console.WriteLine(); } }
Псевдонім MyCounter створюється за допомогою наступного оператора. using MyCounter = Counter.CountDown; Після того, як псевдонім буде визначений як інше ім'я класу Counter.CountDown, його можна використовувати для оголошення об'єктів без додаткового визначення імені цього класу. Наприклад, у наступному рядку коду з розглянутої тут програми створюється об'єкт класу CountDown.
```

16.5 Вкладені простори імен

Один простір імен може бути вкладений в інший. Як приклад розглянемо наступну програму.

Лістинг 16.06 - Приклад вкладених просторів імен

```csharp
using System; namespace NS1 { class ClassA { public ClassA() { Console.WriteLine("Конструювання класу ClassA"); } } namespace NS2 { // вкладений простір імен class ClassB { public ClassB() { Console.WriteLine("Конструювання класу ClassB"); } } } } class NestedNSDemo { static void Main() { NS1.ClassA a = new NS1.ClassA(); // NS2.ClassB b = new NS2.ClassB(); // Неправильно !!! Простір NS2 невидимий NS1.NS2.ClassB b = new NS1.NS2.ClassB(); // Правильно! } }
```

У цій програмі простір імен NS2 вкладений в простір імен NS1. Тому для звернення до класу ClassB необхідно додатково вказати простори імен NS1 і NS2 . Вказання лише простору імен NS2 для цього недостатньо. Як випливає з наведеного вище прикладу, простори імен додатково вказуються через крапку. Отже, для звернення до класу ClassB в методі Main() необхідно вказати його повне ім'я — NS 1.NS2.ClassB.

16.6 Препроцесор

У C# існує ряд директив препроцесора, які впливають на інтерпретацію вихідного коду програми компілятором. Ці директиви визначають порядок під час інтерпретації тексту програми перед її трансляцією в об'єктний код у тому вихідному файлі, де вони з'являються. Термін директива препроцесора з'явився у зв'язку з тим, що подібні інструкції традиційно оброблялися на окремому етапі компіляції, який називався препроцесором. Обробляти директиви на окремому етапі препроцесора в сучасних компіляторах вже не потрібно, але саме її назва закріпилася.

Малюнок 16.1 - директиви препроцесора, визначені в С#

Всі директиви препроцесора починаються зі знака #. Крім того, кожна директи ва препроцесора повинна бути виділена в окремому рядку коду. Беручи до уваги сучасну об'єктно-орієнтовану архітектуру мови C#, потреба в директивах препроцесора в ній не така велика, як в мовах програмування попередніх поколінь. Тим не менш вони можуть бути іноді корисними, особливо для умовної компіляції. У цьому розділі всі директиви препроцесора розглядаються по черзі.

Директива #define визначає послідовність символів, яку називають ідентифікатором. Наявність або відсутність ідентифікатора може бути визначена за допомогою директиви #if або #elif і тому використовується для керування процесом компіляції.. Нижче наведена загальна форма директиви #define . #define ідентифікатор Зверніть увагу на відсутність крапки з комою в кінці цього оператора. Між директивою #defineі ідентифікатором може бути будь-яка кількість пробілів, але після самого ідентифікатора повинен слідувати лише символ нового рядка. Так, для визначення ідентифікатораEXPERIMENTAL використовується наступна директива. #define EXPERIMENTAL. У C/C++ директива #define може використовуватися для підстановки початкового тексту , наприклад, для визначення імені значення, а також для створення макрокоманд, схожих на функції. У C# таке застосування директиви #define не підтримується. У цій мові директива # define служить лише для визначення ідентифікатора.

Обидві директиви, #if і #endif , дозволяють умовну компіляцію послідовності коду залежно від правдивого результату обчислення виразу, що включає один або кілька ідентифікаторів. Ідентифікатор вважається правдивим, якщо він визначений, а інакше — хибним. Так, якщо ідентифікатор визначений директивою #define , то він буде оцінений як правдивий. Нижче наведена загальна форма директиви #if.

#if ідентифікаторне_вираз

послідовність операторів

#endif

Якщо ідентифікаторне_вираз,наступне після директиви #if, є істинним, то компілюється код ( послідовність операторів ), зазначений між ним і директивою #endif. В іншому випадку цей проміжний код пропускається. Директива #endif позначає кінець блоку директиви #if. Ідентифікаторний вираз може бути простим, як назва ідентифікатора. В той же час в ньому дозволяється застосування наступних операторів: ! , == , != , && і || , а також круглих дужок.

Лістинг 16.07 - Приклад застосування директив

```csharp
#define EXPERIMENTAL using System; class Test { static void Main() { #if EXPERIMENTAL Console.WriteLine("Компілюється для експериментальної версії."); #endif Console.WriteLine("Присутній у всіх версіях."); } }
```

У наведеному вище коді визначається ідентифікатор EXPERIMENTAL . Тому коли в цьому коді зустрічається директива #if , ідентифікаційний вираз обчислюється як істинний і потім компілюється перший оператор, що містить виклик методу WriteLine() . Якщо ж видалити визначення ідентифікатора EXPERIMENTAL і перекомпілювати цей код, то перший оператор, що містить виклик методу WriteLine() , не буде скомпільований, оскільки ідентифікаційний вираз директиви #if обчислюється як хибний. Але другий оператор, що містить виклик методу WriteLine() , компілюється в будь-якому випадку, оскільки він не входить до блоку директиви #if . Як пояснювалося вище, в директиві #if допускається вказувати ідентифікаторний вираз. Як приклад розглянемо наступну програму.

Директива #else діє аналогічно умовному оператору else мови C#, визначаючи альтернативний хід виконання програми, якщо цього не може зробити директива # if. З урахуванням директиви #else попередній приклад програми може бути розширений наступним чином.

Позначення #elif означає " інакше якщо " , а сама директива #elif визначає послідовність умовних операцій if-else-if для багатоваріантної компіляції. Після директиви #elif вказується ідентифікаторний вираз. Якщо цей вираз істинний, то компілюється наступний кодовий блок, а інші вирази директиви #elif не перевіряються. В іншому випадку перевіряється наступний за порядком блок. Якщо жодну з директив #elif не вдається виконати, то при наявності директиви #else виконується послідовність коду, пов'язана з цією директивою, а інакше не компілюється жоден з кодових блоків директиви #if . Нижче наведено загальна форма директиви #elif.

#if ідентифікаторне_вираз

послідовність операторів

#elif ідентифікаторне_вираз

послідовність операторів

#elif ідентифікаторне_вираз

послідовність операторів // ...

#endif

За допомогою директиви #undef видаляється попередньо визначений ідентифікатор. Це, по суті, означає, що він стає " невизначеним ". Нижче наведена загальна форма директиви #undef.

#undef ідентифікатор

#define SMALL

#if SMALL // ...

#undef SMALL // тепер ідентифікатор SMALL не визначений

Після директиви #undef ідентифікатор SMALL вже виявляється невизначеним. ленним. Директива #undef застосовується головним чином для локалізації ідентифікато рів тільки в тих фрагментах коду, в яких вони дійсно потрібні.

Директива #error змушує компілятор припинити компіляцію. Вона в основному використовується для відлагодження. Нижче наведена загальна форма директиви #error.

#error повідомлення_про_помилку

Коли в коді зустрічається директива #error, виводиться повідомлення про помилку. Наприклад, коли компілятору зустрічається рядок коду

#error Це тестова помилка!

компіляція припиняється і виводиться повідомлення"Це тестова помилка!".

Директива #warning діє аналогічно директиві #error, за винятком того, що вона виводить попередження, а не помилку. Отже, компіляція не переривається. Нижче наведена загальна форма директиви #warning.

#warning попереджувальне_повідомлення

Директива #line встановлює номер рядка і ім'я файлу, що містить цю директиву. Номер рядка і ім'я файлу використовуються при виведенні помилок або попереджень під час компіляції. Нижче наведена загальна форма директиви #line.

#line номер "ім'я_файлу"

Є ще два варіанти директиви #line. У першому з них вона вказується з ключовим словом default, що позначає повернення нумерації рядків до початкового стану, як у наведеному нижче прикладі.

#line default

А в другому варіанті директива #line вказується з ключовим словом hidden. При кроковому налагодженні програми рядки коду, що знаходяться між директивою

#line hidden

і наступною директивою #line без ключового слова hidden, пропускаються відлагоджувачем.

За допомогою директив #region та #endregion визначається область, яка розгортається або згортається при структуруванні вихідного коду в інтегрованому середовищі розробки Visual Studio. Нижче наведена загальна форма цих директив:

#region текст

// послідовність коду

#endregion текст

де текст позначає необов'язковий символьний рядок.

За допомогою директиви #pragmaінструкції задаються компілятору у вигляді опцій. Нижче наведена загальна форма цієї директиви:

#pragma опція

Де опція позначає інструкцію, передану компілятору. У поточній версії C# передбачено дві опції для директиви #pragma. Перше з них, warning, служить для розрішення або заборони окремих попереджень від боку компілятора. Вона має дві форми:

#pragma warning disable попередження

#pragma warning restore попередження

де попередження позначає роздільний комами список номерів попереджень. Для скасування попередження використовується опція disable, а для його роз блокування — опція restore.

16.7 Збірки і модифікатор доступу internal

Збірка є невід'ємною частиною програмування на С#. Вона представляє собою один або кілька файлів, що містять всю необхідну інформацію про розгор тання програми та її версію. Збірки складають основу середовища .NET. Вони надають механізми для надійної взаємодії компонентів, міжмовної можливості взаємодії та керування версіями. Крім того, збірки визначають область дії програмного коду.

Збірка складається з чотирьох розділів. Перший розділ представляє собою деклара цію збірки. Декларація містить інформацію про саму збірку. До цієї інформації від носиться, зокрема, ім'я збірки, номер її версії, інформація про відповідність типів і параметри культурного середовища (мова та регіональні стандарти). Другий розділ збірки містить метадані типів, тобто інформацію про типи даних, що використовуються в програмі. Серед інших переваг метадані типів сприяють міжмовній можливості взаємодії. Третій розділ збірки містить програмний код у форматі MSIL (Microsoft Intermediate Language — проміжний мова корпо рації Microsoft). І четвертий розділ збірки містить ресурси, що використовуються про грамою.

На жаль, при програмуванні на C# збірки створюються автоматично, вимагаючи від програміста лише мінімальних зусиль. Справа в тому, що виконуваний файл, створений під час компіляції програми на С#, насправді представляє собою збірку, що містить виконуваний код цієї програми, а також інші види інформації. Отже, коли компілюється програма на С#, збірка створюється автоматично. У збірках є багато інших особливостей, і з ними пов'язано багато актуальних питань програмування, але, на жаль, їх обговорення виходить за рамки цієї книги. Адже збірки є невід'ємною частиною процесу розробки програм ного забезпечення в середовищі .NET, але формально вони не відносяться до засобів мови С#. Тим не менш у C# є один засіб, безпосередньо пов'язаний зі збіркою. Це модифікатор доступу internal, розглянутий у наступному розділі.

Крім модифікаторів доступу public, private і protected, використаних у раніше наведених прикладах програм, в C# передбачений також модифікатор доступу internal. Цей модифікатор визначає доступність члена у всіх файлах збірки і його недоступність поза межами збірки. Проще кажучи, про член, позначений як internal відомо тільки у самій програмі, але не за її межами. Модифікатор доступу internal особливо корисний для створення програмних компонентів. Модифікатор доступу internal можна застосовувати до класів і їх членів, а також до структур і членів структур. Крім того, модифікатор internal дозволяє використовувати в оголошеннях інтерфейсів і перелічень. З модифікаторів protected і internal можна скласти спарений модифікатор доступу protected internal. Рівень доступу protected internal може бути заданий тільки для членів класу. Член, оголошений як protected internal доступний лише в межах власної збірки або для похідних типів. Нижче наведено приклад застосування модифікатора доступу internal.


---

[◀️ До змісту](../README.md)
