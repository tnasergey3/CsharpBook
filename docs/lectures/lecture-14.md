# Застосування засобів введення-виведення

[◀️ До змісту лекцій](README.md)

---

```csharp
У прикладах програм, які наводилися в попередніх главах, вже застосовувалися окремі частини системи введення-виведення в С#, наприклад метод Console.WriteLine() , але це робилося без будь-яких формальних пояснень. Система введення-виведення базується в C# на ієрархії класів, тому її функції та особливості не можна було уявити до тих пір, поки не були розглянуті класи, успадкування та винятки . А тепер настав черга для введення-виведення. В C# застосовується система введення-виведення і класи, визначені в середовищі .NET Framework, тому розгляд введення-виведення в цій мові відноситься до всієї системи введення-виведення середовища .NET в цілому. У цьому розділі йдеться про засоби консольного та файлового введення-виведення. Проте слід відразу попередити, що система введення-виведення в C# досить обширна. Тому в цьому розділі розглядаються лише найважливіші та найчастіше використовувані її засоби.
```

14.1 Організація системи введення виведення в C# на потоках

Введення-виведення в програмах на C# здійснюється за допомогою потоків. Потік – це певна абстракція виробництва або споживання інформації. С фізичним пристроєм потік зв'язує система введення-виведення. Всі потоки діють однаково — навіть якщо вони пов'язані з різними фізичними пристроями. Тому класи та методи введення-виведення можуть застосовуватися до найрізноманітніших типів пристроїв. Наприклад , методами виведення на консоль можна користуватися і для виведення в файл на диску.

На найнижчому рівні введення-виведення в С# здійснюється байтами. І це робиться тому, що багато пристроїв орієнтовані на операції введення-виведення окремими байтами. Але людині більше властиво спілкуватися символами. Нагадаємо, що в C# тип char є 16-розрядним, а тип byte – 8-розрядним. Так, якщо в цілях введення-виведення використовується набір символів в коді ASCII, то для перетворення типу char в тип byte достатньо відкинути старший байт значення типу char. Але це не підходить для набору символів в унікоді (Unicode), де символи потрібно представляти двома, а то й більше байтами. Отже, байтові потоки не зовсім підходять для організації введення-виведення окремими символами. З метою вирішити цю складність у середовищі .NET Framework визначено кілька класів, що виконують перетворення байтового потоку в символьний з автоматичним перетворенням типу byte в тип char і навпаки.

```csharp
Для всіх програм, в яких використовується простір імен System , доступні вбудовані потоки, які відкриваються за допомогою властивостей Console.In , Console.Out і Console.Error . Зокрема, властивість Console.Out пов'язана зі стандартним пото ком виведення. За замовчуванням це потік виведення на консоль. Так, якщо викликається метод Console.WriteLine() , інформація автоматично передається властивості Console.Out. Властивість Console.In пов'язана зі стандартним потоком введення, який за замов чуванням здійснюється з клавіатури. А властивість Console.Error пов'язана зі стан дартним потоком повідомлень про помилки, які за замовчуванням також виводяться на консоль. Але ці потоки можуть бути перенаправлені на будь-який інший сумісний пристрій введення-виведення. Стандартні потоки є символьними. Тому в ці потоки виводяться і вводяться з них символи.
```

14.2 Класи потоків

```csharp
У середовищі .NET Framework визначені класи як для байтових, так і для символь них потоків. Але насправді класи символьних потоків служать лише оболонками для перетворення заключеного в них байтового потоку в символьний, автоматично виконуючи будь-які необхідні перетворення типів даних. Отже, символьні потоки базуються на байтових, хоча вони і розділені логічно. Основні класи потоків визначені в просторі імен System.IO. Для того щоб скористатися цими класами, як правило, достатньо ввести наведений нижче оператор на початку програми. using System.IO; Простір імен System.IO не вказується для консольного введення-виведення, оскільки для нього визначений клас Console у просторі імен System.
```

Основним для потоків є клас System.IO.Stream . Він представляє байтовий потік і є базовим для всіх інших класів потоків. Крім того, він є абстрактним класом, що означає, що неможливо отримати екземпляр об'єкта класу Stream. У класі Stream визначається низка операцій зі стандартними потоками, представленими відповідними методами. перераховано низку найбільш часто використовуваних методів, визначених у класі Stream.

Малюнок 14.1 - методи класу Stream

Слід зазначити, що в класі Stream визначені методи для введення (або читання) і виведення (або запису) даних. Але не всі потоки підтримують обидві ці операції, оскільки потік можна відкривати тільки для читання або тільки для запису. Крім того, не всі потоки підтримують запит поточного положення в потоці за допомогою методу Seek(). Для того щоб визначити можливості потоку, доведеться скористатися одним, а то й кількома властивостями класу Stream. Ці властивості перераховані на малюнку 14.2 наряду з властивостями Length і Position, що містять довжину потоку і поточне положення в ньому.

Малюнок 14.2 - властивості класу Stream

Похідні від класу Stream є кілька конкретних класів байтових потоків. Ці класи визначені в просторі імен System.IO і перераховані нижче.

Малюнок 14.3 - Класи байтових потоків

У середовищі NET Framework підтримується також ряд інших конкретних класів потоків, включаючи для введення-виведення в стислі файли, сокети і канали. Крім того, можна створити свої власні похідні класи потоків, хоча для більшості додатків достатньо вбудованих потоків.

14.3 Класи-обгортки символьних потоків

Для створення символьного потоку достатньо заключити байтовий потік в один з класів-обгорток символьних потоків. На вершині ієрархії класів символь них потоків знаходяться абстрактні класи TextReader і TextWriter. Так, клас TextReader організує введення, а клас TextWriter — виведення. Методи, визначені в обох цих класах, доступні для всіх їх підкласів. Вони утворюють мінімальний набір функцій введення-виведення, якими повинні володіти всі символьні потоки. У табл. 14.3 перераховані методи введення, визначені в класі TextReader . У ці лому, ці методи здатні генерувати виняток IOException при появі помилки введення, а деякі з них — винятки інших типів. Особливий інтерес викликає метод ReadLine (), призначений для введення цілої текстової стрічки, повертаючи її у вигляді об' єкта типу string. Цей метод зручний для читання вхідних даних, що містять пробіли. У класі TextReader є також метод Close() , визначений наступним чином. void Close() Цей метод закриває читаючий потік і звільняє його ресурси.

Малюнок 14.4 - Методи введення, визначені в класі TextReader

У класі TextWriter також визначені варіанти методів Write() і WriteLine() , призначені для виведення даних всіх вбудованих типів. Нижче наведено лише деякі з перелічених варіантів цих методів.

Малюнок 14.5 - Методи запису для класу TextWriter

Всі ці методи генерують виняток IOException при виникненні помилки виведення. Крім того, в класі TextWriter визначені методи Close() і Flush() , наведені нижче.

Метод Flush() організовує вивід у фізичне середовище всіх даних, що залишилися у вихідному буфері. А метод Close() закриває записуючий потік і звільняє його ресурси. Класи TextReader і TextWriter реалізуються декількома класами символі чних потоків, включаючи ті, що перераховані нижче. Отже, в цих класах потоків надаються методи і властивості , визначені в класах TextReader і TextWriter.

Малюнок 14.6 - Класи потоку

14.3 Двійкові потоки

Крім класів байтових і символьних потоків, є ще два класи двійкові х потоків, які можуть служити для безпосереднього введення і виведення двійкових даних —BinaryReader і BinaryWriter. Детальніше про них буде сказано далі в цьому розділі, коли дійде черга до файлового введення-виведення. А тепер, коли представлена загальна структура системи введення-виведення в С# , звернемо увагу на залишок цього розділу, детальніше розглянувши різні частини цієї системи, починаючи з консольного введення-виведення.

```csharp
Консольний ввід-вивід здійснюється за допомогою стандартних потоків, які представлені властивостями Console.In, Console.Out і Console.Error. Приклади консольного введення -виведення були представлені ще в розділі 2, тому вони повинні бути вам вже знайомі. Як буде показано нижче, він має також і ряд інших додаткових можливостей. Але перед цим слід ще раз підкреслити, що більшість реальних додатків C# орієнтовані не на консольний ввід-вивід у текстовому вигляді, а на графічний віконний інтерфейс для взаємодії з користувачем, або вони представляють собою програмний код, що використовується на стороні сервера. Тому частина системи вводу-виводу, пов'язана з консоллю, не знаходить широкого практичного застосування. І хоча програми, орієнтовані на текстовий ввід-вивід, чудово підходять в якості навчальних прикладів, коротких сервісних програм або певного роду програмних компонентів, для більшості реальних додатків вони не підходять.
Потік Console.In є екземпляром об'єкта класу TextReader , і тому для доступу до нього можуть бути використані методи і властивості, визначені в класі TextReader. Але для цього зазвичай використовуються методи, надані класом Console, в якому автоматично організується читання даних з потоку Console.In. У класі Console визначені три методи введення. Два перших методи, Read() і ReadLine(), були доступні ще в версії .NET Framework 1.0. А третій метод, ReadKey(), був доданий в версію 2.0 цієї середи.
```

Для читання одного символу використовується наведений нижче метод Read(). static int Read() Метод Read() повертає наступний символ, зчитаний з консолі. Він очікує доки користувач не натисне клавішу, а потім повертає результат. Повернутий символ належить до типу int і тому повинен бути приведений до типу char . Якщо при введенні виникає помилка, то метод Read() повертає значення -1. Цей метод генерує виняток IOException при невдалих операціях вводу. Введення з консолі за допомогою методу Read() буферизується по рядкам, тому користувач повинен натиснути клавішу, перед тим як програма отримає будь-який символ , введений з консолі.

14.4 Клас FileStream і байтовий введення-виведення в файл

```csharp
У середовищі .NET Framework передбачені класи для організації введення-виведення в файли. Безумовно, це в основному файли дискового типу. На рівні операційної системи файли мають байтову організацію. І, як очікувалося, для введення і виведення байтів в файли є відповідні методи. Тому введення і виведення в файли байтовими потоками досить поширене. Крім того, байтовий потік вво ду або виведення в файл може бути укладений в відповідний об'єкт символьного потоку. Операції символьного введення-виведення в файл знаходять застосування при обра ботці тексту . Про символьні потоки буде розповідатися далі в цьому розділі, а тут розглядається байтовий введення-виведення. Для створення байтового потоку, пов'язаного з файлом, використовується клас FileStream . Цей клас є похідним від класу Stream і успадковує всі його функції. Нагадаємо, що класи потоків, включаючи FileStream , визначені в просторі імен System.IO . Тому на початку будь-якої програми, яка використовує їх, зазвичай вводиться наступний рядок коду. using System.IO;
```

Для формування байтового потоку, пов'язаного з файлом, створюється об'єкт класу FileStream . У цьому класі визначено кілька конструкторів. Нижче наведений, мабуть, найпоширеніший з них:

FileStream(string шлях, FileMode режим)

де шлях означає ім'я відкриваного файлу, включаючи повний шлях до нього; а режим — порядок відкриття файлу. У останньому випадку вказується одне зі значень, визначених у перерахуванні FileMode і наведених у табл. 14.4. Зазвичай, цей конструктор відкриває файл для доступу з метою читання або запису. Винятком з цього правила є відкриття файлу в режимі FileMode.Append , коли файл стає доступним тільки для запису.

Малюнок 14.7 - Значення з переліку FileMode

Якщо спроба відкрити файл виявляється невдалим, то генерується виняток. Якщо файл неможливо відкрити через те, що він не існує, генерується виняток FileNotFoundException. А якщо файл неможливо відкрити через яку- небудь помилку введення-виведення, то генерується виняток IOException. До чис ла інших винятків, які можуть бути згенеровані при відкритті файлу, відносяться наступні: ArgumentNullException (вказано порожнє ім'я файлу), ArgumentException (вказано невірне ім'я файлу), ArgumentOutOfRangeException (вказано невірний режим), SeaurityException (у користувача немає прав доступу до файлу), PathTooLongException (занадто довге ім'я файлу або шлях до нього), NotSupportedException (у імені файлу вказано пристрій, який не підтримується), а також DirectoryNotFoundException (вказано невірний каталог). Виключення PathTooLongException, DirectoryNotFoundException іFileNotFoundException належать до підкласів класу виключеньIOException. Тому всі вони можуть бути перехоплені, якщо перехоплюється виключення IOException.

Лістинг 14.01 - Нижче наведено один з способів відкриття файлу test.dat для вводу

FileStream fin;

try

fin = new FileStream("test", FileMode.Open);

catch (IOException exc)

```csharp
{ // перехопити всі виключення, пов'язані з введеннямвиведенням
Console.WriteLine(exc.Message);
```

// Обробити помилку.

```csharp
catch (Exception exc { // перехопити будь-яке інше виключення.
Console.WriteLine(exc.Message);
```

// Обробити помилку, якщо це можливо.

// Ще раз згенерувати неперехоплені виключення.

У першому блоку catch з цього прикладу обробляються помилки, що виникають у випадку, якщо файл не знайдено, шлях до нього занадто довгий, каталог не існує та інші помилки введення-виведення. У другому блоку catch , який є " універсальним " для всіх інших типів виключень, обробляються інші ймовірні помилки (можливо, навіть шляхом повторного генерування виключення). Крім того, кожну помилку можна перевірити окремо, повідомляючи більш детально про неї та приймаючи конкретні заходи щодо її виправлення. З метою спрощення прикладів, наведених у цій книзі, перехоплюється тільки виняток IOException , але у реальній програмі, ймовірно, знадобиться перехоплювати інші можливі винятки, пов'язані з введенням-виведенням, залежно від обставин. Крім того, у обробниках винятків, наведених у цьому розділі, просто повідомляється про помилку, але часто в них повинні бути запрограмовані конкретні заходи щодо виправлення помилок, якщо це взагалі можливо. Наприклад, можна запропонувати користувачеві знову ввести ім'я файлу, якщо раніше вказаний файл не був знайдений . Можливо, також знадобиться знову згенерувати виняток.

14.5 Читання байтів з потоку файлового введення-виведення

В класі FileStream визначені два методи для читання байтів з файлу : ReadByte() і Read(). Так, для читання одного байта з файлу використовується метод ReadByte(), загальна форма якого наведена нижче.

int ReadByte()

Кожного разу, коли цей метод викликається, з файлу зчитується один байт, який потім повертається у вигляді цілого значення. До числа ймовірних винятків, які генеруються при цьому, відносяться NotSupportedException (потік не відкритий для вводу) і ObjectDisposedException (потік закритий).

Для читання блоку байтів з файлу служить метод Read(), загальна форма якого виглядає так.

int Read(byte[ ] array, int offset, int count)

У методі Read() здійснюється спроба прочитати кількість count байтів в масив array, починаючи з елемента array [ offset ] . Він повертає кількість бай тів, успішно прочитаних з файлу. Якщо виникає помилка введення-виведення, то гене рується виняток IOException. До числа інших можливих винятків, які генеруються при цьому, відноситься NotSupportedException. Цей виняток гене рується у випадку, якщо читання з файлу не підтримується в потоці. У наведеному нижче прикладі програми метод ReadByte() використовується для введення та відображення вмісту текстового файлу, ім'я якого вказується в якості аргумента командного рядка. Зверніть увагу на те, що в цій програмі перевіряється, чи вказано ім'я файлу, перед тим як намагатися відкрити його.

Лістинг 14.2 - Відобразити вміст текстового файлу

```csharp
class ShowFile
static void Main(string[] args)
```

int i;

FileStream fin;

if (args.Length != 1)

```csharp
Console.WriteLine("Застосування: ShowFile Файл");
```

return;

try

fin = new FileStream(args[0], FileMode.Open);

catch (IOException exc)

```csharp
Console.WriteLine("Не вдається відкрити файл");
Console.WriteLine(exc.Message);
```

return; // Файл не відкривається, завершити програму

// Читати байти до кінця файлу.

try

i = fin.ReadByte();

```csharp
if (i != -1) Console.Write((char)i);
} while (i != -1);
```

catch (IOException exc)

```csharp
Console.WriteLine("Помилка читання файлу");
Console.WriteLine(exc.Message);
```

finally

fin.Close();

Зверніть увагу на те, що в наведеній вище програмі використовуються два блоки try. У першому з них перехоплюються винятки, що виникають при введенні- виведенні і можуть завадити відкриттю файлу. Якщо станеться помилка введення-виведення, виконання програми завершиться. У протилежному випадку в другому блоці try буде продовжено контроль винятків, що виникають у операціях введення- виведення. Отже, другий блок try виконується тільки у випадку, якщо в змінній fin міститься посилання на відкритий файл. Зверніть також увагу на те, що файл закривається в блоку finally , пов'язаному з другим блоком try . Це означа є, що незалежно від того, як завершиться цикл do-while (нормально або аварійно через помилку), файл все одно буде закритий. І хоча в даному конкретному прикладі це і так важливо, оскільки програма все одно завершиться в даній точці, перевага такого підходу, взагалі кажучи, полягає в тому, що файл закривається в за вершальному блоку finally у будь-якому випадку — навіть якщо виконання коду доступу до цього файлу завершується передчасно через який-небудь виняток.

14.5 Запис в файл

Для запису байта в файл використовується метод WriteByte() . Нижче наведена його простіша форма.

void WriteByte(byte value)

Цей метод виконує запис в файл байта, що позначається параметром value. Якщо базовий потік не відкривається для виводу, то генерується виняток NotSupportedException. А якщо потік закрито , то генерується виняток ObjectDisposedException.

Для запису в файл цілого масиву байтів може бути викликаний метод Write(). Нижче наведена його загальна форма.

void Write(byte[] array, int offset, int count)

У методі Write() приймається спроба записати в файл кількість count байтів з масиву array,починаючи з елемента array[offset]. Він повертає кількість байтів, успішно записаних в файл. Якщо під час запису виникає помилка, то генерується винятокIOException. А якщо базовий потік не відкривається для ви воду, то генерується виняток NotSupportedException. Крім того, може бути згенеровано ряд інших винятків. Вам, ймовірно, відомо, що при виводі в файл виводимі дані часто записуються на конкретному фізичному пристрої не одразу. Замість цього вони буферизуються на рівні операційної системи до тих пір, поки не накопичиться достатній обсяг даних , щоб записати їх одразу одним блоком. Це підвищує ефективність системи. Так, на диску файли організовані по секторах розміром від 128 байтів і більше. Тому виводимі дані зазвичай буферизуються до тих пір, поки не з'явиться можливість записати на диск одразу весь сектор. Але якщо дані потрібно записати на фізичний пристрій без попереднього накопичення в буфері, то для цього можна викликати метод Flush.

void Flush()

При невдалих наслідках цієї операції генерується виняток IOException. Якщо потік закритий, то генерується виняток ObjectDisposedException. Після завершення виводу в файл слід закрити його за допомогою методу Close(). Цим гарантується, що будь-які виведені дані, що залишилися в дисковому буфері, будуть записані на диск. У цьому випадку не потрібно викликати метод Flush()перед закриттям файлу.

Лістинг 14.03 - Записати дані у файл

```csharp
using System;
using System.IO;
class WriteToFile
static void Main(string[] args)
```

FileStream fout = null;

try

// Відкрити вихідний файл.

fout = new FileStream("test.txt", FileMode.CreateNew);

// Записати весь англійський алфавіт у файл.

for (char с = 'А'; с <= 'Z'; C++)

fout.WriteByte((byte)с);

catch (IOException exc)

```csharp
Console.WriteLine("Помилка введеннявиведення: " + exc.Message);
```

finally

if (fout != null) fout.Close();

У даній програмі спочатку створюється вихідний файл під назвою test.txt за допомогою перераховуваного значення FileMode.CreateNew. Це означає, що файл з таким самим ім'ям не повинен вже існувати. (У протилежному випадку генерується виняток IOException.) Після відкриття вихідного файлу в нього записуються прописні букви англійського алфавіту. Після завершення цієї програми вміст файлу test.txt відображається наступним чином. ABCDEFGHIJKLMNOPQRSTUVWXYZ.

14.6 Застосування класу StreamWriter

Для створення символьного потоку виведення достатньо обгорнути об'єкт класу Stream , наприклад FileStream , в оболонку класу StreamWriter . В класі StreamWriter визначено кілька конструкторів. Нижче наведений майже найпоширеніший серед них:

StreamWriter(Stream потік)

де потік означає ім'я відкритого потоку. Цей конструктор генерує виняток ArgumentException , якщо потік не відкритий для виводу, а також виняток ArgumentNullException , якщо потік показується порожнім. Після створення об'єкта класу StreamWriter відбувається автоматичне перетворення символів в байти.

Нижче наведено простий приклад сервісної програми введення з клавіатури та виведення на диск набраних текстових рядків, збережених у файлі test.txt . Введений текст вводиться до тих пір, поки в ньому не зустрінеться рядок " стоп " . Для символьного ви воду в файл у цій програмі використовується об'єкт класу FileStream , упакований у обгортку класу StreamWriter .

Лістинг 14.4 - Приклад StreamWriter

```csharp
class KtoD
static void Main()
```

string str;

FileStream fout;

// Спочатку відкрити потік файлового введеннявиведення.

try

fout = new FileStream("test.txt", FileMode.Create);

catch (IOException exc)

```csharp
Console.WriteLine("Помилка відкриття файлу: " + exc.Message);
```

return;

// Обгорнути потік файлового введеннявиведення в оболонку класу StreamWriter.

StreamWriter fstr_out = new StreamWriter(fout);

try

```csharp
Console.WriteLine("Введіть текст, а після закінчення - 'стоп'.");
Console.Write(": ");
str = Console.ReadLine();
```

if (str != "стоп")

str = str + " "; // додати новий рядок fstr_out.

Write(str);

```csharp
} while (str != "стоп");
```

catch (IOException exc)

```csharp
Console.WriteLine("Помилка введеннявиведення: " + exc.Message);
```

finally

fstr_out.Close();

14.7 Застосування класу StreamReader

Для створення символьного потоку вводу достатньо упакувати байтовий потік у обгортку класу StreamReader . У класі StreamReader визначено кілька конструкторів . Нижче наведено найчастіше використовуваний конструктор:

StreamReader(Stream потік)

Де потік означає ім'я відкритого потоку. Цей конструктор генерує виняток ArgumentNullException , якщо потік порожній, а також виняток ArgumentException, якщопотікне відкритий для вводу. Після свого створення об'єкт класу StreamReader виконує автоматичне перетворення байтів в символи. Після завершення вводу з потоку типу StreamReader його потрібно закрити. При цьому закривається й базовий потік. У наведеному нижче прикладі створюється проста сервісна програма вводу з дис ку і виводу на екран вмісту текстового файлу test.txt. Вона служить доповнен ням до раніше представленої сервісної програми вводу з клавіатури і виводу на диск.

Лістинг 14.05 - Приклад StreamReader

```csharp
class DtoS
static void Main()
```

FileStream fin;

string s;

try

fin = new FileStream("test.txt", FileMode.Open);

catch (IOException exc)

```csharp
Console.WriteLine("Помилка відкриття файлу: " + exc.Message);
```

return;

StreamReader fstr_in = new StreamReader(fin);

try

while ((s = fstr_in.ReadLine()) != null)

```csharp
Console.WriteLine(s);
```

catch (IOException exc)

```csharp
Console.WriteLine("Помилка введеннявиведення: " + exc.Message);
```

finally

fstr_in.Close();

Зверніть увагу на те, як у цій програмі визначається кінець файлу. Коли метод ReadLine() повертає порожнє посилання, це означає, що досягнуто кінець файлу. Такий спосіб є повністю працездатним, але в класі StreamReader надається ще один засіб для виявлення кінця потоку — EndOfStream. Ця властивість доступна для читання і має логічне значення true, коли досягнуто кінець потоку, в іншому випадку — логічне значення false. Отже, властивість EndOfStream можна використовувати для відстеження кінця файлу. Як приклад нижче наведено інший спосіб організації циклу while для читання з файлу.

```csharp
while(!fstr_in.EndOfStream) { s = fstr_in.ReadLine(); Console.WriteLine(s); }
```

У цьому випадку код трохи спрощується завдяки властивості EndOfStream , хоча загальний порядок виконання операції вводу з файлу не змінюється. Іноді застосування властивості EndOfStream дозволяє трохи спростити складну ситуацію, надаючи ясність і покращуючи структуру коду. Іноді файл легше відкрити , використовуючи безпосередньо клас StreamReader, аналогічно класуStreamWriter. Для цієї цілі слугує наступний конструктор:

StreamReader(string шлях)

де шлях — це ім'я відкриваного файлу, включаючи повний шлях до нього. Зазначений файл повинен існувати. У протилежному випадку генерується виняток FileNotFoundException. Якщо шлях виявляється порожнім, то генерується виняток ArgumentNullException. А якщо шлях містить порожній рядок, то генерується виняток ArgumentException. Крім того, можуть бути згенеровані винятки IOException і DirectoryNotFoundException.

14.8 Застосування класів StringReader і StringWriter

Для виконання операцій введення-виведення з запам'ятовуванням в деяких додатках нях в якості базової пам'яті іноді краще використовувати масив типу string, ніж масив типу byte . Саме для таких випадків і передбачені класи StringReader і StringWriter . Зокрема, клас StringReader успадковує від класу TextReader , а клас StringWriter — від класу TextWriter . Отже, вони представля ють собою потоки, які мають доступ до методів, визначених в цих двох базових класах, що дозволяє, наприклад, викликати метод ReadLine() для об'єкта класу StringReader а метод WriteLine() — для об'єкта класу StringWriter. Нижче наведено конструктор класуStringReader:

StringReader(string s)

де s позначає символьний рядок, з якого проводиться читання. У класі StringWriter визначено кілька конструкторів. Нижче представлено один з найбільш часто використовуваних.

StringWriter()

Цей конструктор створює записуючий потік, який поміщає виводимі дані в рядок. Для отримання вмісту цього рядка достатньо викликати метод ToString(). Нижче наведено приклад, що демонструє застосування класів StringReader і StringWriter.

Лістинг 14.06 - Приклад застосування класів StringReader і StringWriter

```csharp
class StrRdrWtrDemo
static void Main()
```

StringWriter strwtr = null;

StringReader strrdr = null;

try

// Створити об'єкт класу StringWriter.

strwtr = new StringWriter();

// Вивести дані в записуючий потік типу StringWriter.

for (int i = 0; i < 10; i++)

strwtr.WriteLine("Значення i дорівнює: " + i);

// Створити об'єкт класу StringReader.

strrdr = new StringReader(strwtr.ToString());

//А тепер ввести дані з читаючого потоку типу StringReader.

string str = strrdr.ReadLine();

while (str != null)

str = strrdr.ReadLine();

```csharp
Console.WriteLine(str);
```

catch (IOException exc)

```csharp
Console.WriteLine("Помилка введеннявиведення " + exc.Message);
```

finally

// Звільнити ресурси читаючого та записуючого потоків.

if (strrdr != null) strrdr.Close();

if (strwtr != null) strwtr.Close();

У даному прикладі спочатку створюється об'єкт strwtr класу StringWriter , в який виводяться дані за допомогою методу WriteLine() . Потім створюється об'єкт класу StringReader з використанням символьного рядка, що міститься в об'єкті strwtr . Цей рядок отримується в результаті виклику методу ToString()для об'єкта strwtr. І нарешті, вміст цього рядка зчитується за допомогою методу ReadLine().

14.9 Клас File

У середовищі .NET Framework визначений клас File , який може бути корисним для роботи з файлами, оскільки він містить кілька статичних методів, що виконують типові операції над файлами. Зокрема, в класі File є методи для копіювання та переміщення, шифрування та розшифрування, видалення файлів, а також для отримання та встановлення інформації про файли, включаючи дані про їх існування, час створення, останнього доступу та різні атрибути файлів (тільки для читання, прихованих тощо). Крім того, в класі File є кілька зручних ме тодів для читання з файлів та запису в них, відкриття файлу та отримання посилання типу FileStream на нього . У класі File міститься занадто багато методів для детального їх розгляду, тому ми зосередимося лише на трьох з них. Спочатку буде представлений метод Сору() , а потім — методи Exists() та GetLastAccessTime() . На прикладі цих методів ви зможете отримати чітке уявлення про те, наскільки зручні методи, доступні в класі File. І тоді вам стане зрозуміло, що клас File однозначно заслуговує більш докладного вивчення.

Раніше в цьому розділі був продемонстрований приклад програми, в якій файл копіювався вручну шляхом читання байтів з одного файлу та запису в інший. І хоча задача копіювання файлів не представляє особливих труднощів, її можна повністю автоматизувати за допомогою методу Copy() , визначеного в класі File . Нижче представлені дві форми його оголошення.

```csharp
static void Copy (string ім'я_вихідного_файлу, string ім'я_цільового_файлу)
static void Copy (string ім'я_вихідного_файлу, string ім'я_цільового_файлу, boolean overwrite)
```

Метод Copy() копіює файл, на який вказує ім'я_вихідного_файлу , в файл, на який вказує ім'я_цільового_файлу . У першій формі цей метод копіює файл тільки у випадку, якщо файл, на який вказує ім'я_цільово- го_файлу , ще не існує. А в другій формі копія замінює і перезаписує цільовий файл, якщо він існує і якщо параметр overwrite приймає логічне значення true. Але в обох випадках можуть бути згенеровані декілька видів винятків, включаючи IOException і FileNotFoundException.

За допомогою методів класу File дуже легко отримати потрібну інформацію про файл. Розглянемо два таких методи: Exists() і GetLastAccessTime() . Метод Exists() визначає, чи існує файл, а метод GetLastAccessTime() повертає дату і час останнього доступу до файлу. Нижче наведено форми оголошення обох методів

static bool Exists(string шлях)

static DateTime GetLastAccessTime(string шлях)

У обох методахшляхозначає файл, про який потрібно отримати інформацію. Метод Exists() повертає логічне значення true , якщо файл існує і доступний для викликаючого процесу. А метод GetLastAccessTime() повертає структуру DateTime , що містить дату і час останнього доступу до файлу. (Структура DateTime описується далі в цій книзі, але метод ToString() автоматично перетворює дату і час в зручний для читання вигляд.) З вказанням недійсних аргумен тів або прав доступу при виклику обох розглянутих тут методів може бути пов'язано ціле розмаїття винятків, але насправді генерується лише виняття IOException. У наведеному нижче прикладі програми методи Exists() і GetLastAccessTime() демонструються в дії. У цій програмі спочатку визначається, чи існує файл під назвою test.txt . Якщо він існує, то на екран виводиться час останнього доступу до нього.

Лістинг 14.7 - Застосувати методи Exists() і GetLastAccessTime()

```csharp
using System;
using System.IO;
class ExistsDemo
static void Main()
```

if (File.Exists("test.txt"))

```csharp
Console.WriteLine("Файл існує. Останній раз він був доступний " +
```

File.GetLastAccessTime("test.txt"));

else

```csharp
Console.WriteLine("Файл не існує");
```

Крім того, час створення файлу можна дізнатися, викликавши метод GetCreationTime (), а час останнього запису в файл, викликавши метод GetLastWriteTime(). Існують також варіанти цих методів для представлення даних про файл у форматі всесвітнього координованого часу (UTC). Спробуйте експериментувати з ними.


---

[◀️ До змісту](../README.md)
