# Цикли

[◀️ До змісту лекцій](README.md)

---

5.1 Оператор циклу for

Оператор for вже був представлений, а тут він розглядається більш детально. Вас повинна приємно здивувати ефективність і гнучкість цього оператора. Перш за все, звернемося до найбільш основних і традиційних форм оператора for.

Нижче наведена загальна форма оператора for для повторного виконання єдиного оператора.

for (ініціалізація; умова; ітерація) оператор;

Ось як виглядає його форма для повторного виконання кодового блоку:

for (ініціалізація; умова; ітерація)

послідовність операторів;

де ініціалізація, зазвичай, представлена оператором присвоєння, що задає початкове значення змінної, яка виконує роль лічильника і керує циклом; умова— це логічний вираз, що визначає необхідність повторення циклу; а ітерація— вираз, що визначає величину, на яку має змінюватися значення змінної, яка керує циклом, при кожному повторенні циклу.

Зверніть увагу на те, що ці три основні частини оператора циклу for повинні бути розділені крапкою з комою. Виконання циклу for буде тривати до тих пір, поки перевірка умови дає істинний результат. Як тільки ця перевірка дасть хибний результат, цикл завершиться, а виконання програми буде продовжено з оператора, наступного після циклу for. Цикл for може тривати як у позитивному, так і у від'ємному напрямку, змінюючи значення змінної управління циклом на будь-яку величину.

У наведеному нижче прикладі програми виводяться числа поступово зменшуються від 100 до -100 на величину 5 (лістинг 5.1).

Лістинг 5.1 – Вивід чисел від 100 до -100, зменшуючи на величину 5

// Виконання циклу for в негативному напрямку.

```csharp
using System;
class DecrFor
static void Main()
```

int x;

for (x = 100; x >= -100; x -= 5)

```csharp
Console.WriteLine(x);
```

Щодо циклів for слід особливо підкреслити, що умовний вираз завжди перевіряється на початку циклу. Це означає, що код у циклі може взагалі не виконуватися, якщо перевірочний вираз з самого початку є хибним. Розглянемо наступний приклад (лістинг 5.2).

Лістинг 5.2 – Приклад, коли оператор не виконується

for (count=10; count < 5; count++)

x += count; // цей оператор не буде виконуватися

Даний цикл взагалі не буде виконуватися, оскільки початкове значення змінної count, яка ним керує, відразу стає більше 5. Це означає, що умовний вираз count < 5 виявляється хибним з самого початку, тобто ще до виконання першого кроку циклу.

Оператор циклу for – найбільш корисний для повторного виконання операцій відому кількість разів. У наступному прикладі програми використовуються два цикли for для виявлення простих чисел в межах від 2 до 20. Якщо число виявляється не простим, то виводиться його найбільший множник (лістинг 5.3).

Лістинг 5.3 – Визначення чи є число простим

// Визначити, чи є число простим. Якщо воно

// непросте, вивести його найбільший множник.

```csharp
using System;
class FindPrimes
static void Main()
```

int num;

int i;

int factor;

bool isprime;

for (num = 2; num < 20; num++)

isprime = true;

factor = 0;

// Визначити, чи ділиться значення змінної num націло.

for (i = 2; i <= num / 2; i++)

if ((num % i) == 0)

// Значення змінної num ділиться націло.

// Отже, це непросте число.

isprime = false;

factor = i;

if (isprime)

```csharp
Console.WriteLine(num + " - просте число.");
```

else

```csharp
Console.WriteLine("Найбільший множник числа " + num +
```

" дорівнює " + factor);

Нижче наведено результат виконання цієї програми.

2 – просте число

3 – просте число

Найбільший множник числа 4 дорівнює 2

4 – просте число

Найбільший множник числа 6 дорівнює 3

7 – просте число

Найбільший множник числа 8 дорівнює 4

Найбільший множник числа 9 дорівнює 3

Найбільший множник числа 10 дорівнює 5

11 – просте число

Найбільший множник числа 12 дорівнює 6

13 – просте число

Найбільший множник числа 14 дорівнює 7

Найбільший множник числа 15 дорівнює 5

Найбільший множник числа 16 дорівнює 8

17 – просте число

Найбільший множник числа 18 дорівнює 9

19 – просте число

5.1.1 Різновиди оператора циклу for

Оператор циклу for відноситься до найбільш універсальних операторів мови С#, оскільки він допускає найрізноманітніші варіанти його застосування. Деякі різновидності оператора циклу for розглядаються нижче.

5.1.1.1 Застосування кількох змінних управління циклом

У операторі циклу for дозволяється використовувати дві або більше змінних для управління циклом. У цьому випадку оператори ініціалізації та інкремента кожної змінної розділяються комою. Розглянемо наступний приклад програми (лістинг 5.4).

Лістинг 5.4 – Використання ком у операторі циклу for

// Використання ком у операторі циклу for.

```csharp
using System;
class Comma
static void Main()
```

int i, j;

for (i = 0, j = 10; i < j; i++, j--)

```csharp
Console.WriteLine("i and j: " + i + " " + j);
```

Виконання цієї програми дає наступний результат.

i j: 0 10

i and j: 1 9

i and j: 2 8

i and j: 3 7

i and j: 4 6

У даному прикладі комами розділяються два оператори ініціалізації та ще два ітераційних вирази. Коли цикл починається, ініціалізуються обидві змінні, i і j . Кожного разу, коли цикл повторюється, змінна i інкрементується, а змінна j декрементується. Застосування кількох змінних управління циклом часто є зручним, спрощуючи деякі алгоритми. Теоретично у операторі циклу for може бути будь-яка кількість операторів ініціалізації та ітерації, але на практиці цикл виходить занадто громіздким, якщо застосовується більше двох подібних операторів.

Нижче наведено практичний приклад застосування кількох змінних управління циклом в операторі for . У цьому прикладі програми використовуються дві змінні управління одним циклом for для виявлення найбільшого і най меншого множника цілого числа (у даному випадку – 100). Зверніть особливу увагу на умову закінчення циклу. Вона базується на обох змінних управління циклом (лістинг 5.5).

Лістинг 5.5 – Виявлення найменшого та найбільшого множника числа

// Використовувати коми в операторі циклу for для

// виявлення найменшого і найбільшого множника числа.

```csharp
using System;
class Comma
static void Main()
```

int i, j;

int smallest, largest;

int num;

num = 100;

smallest = largest = 1;

for (i = 2, j = num / 2; (i <= num / 2) & (j >= 2); i++, j--)

if ((smallest == 1) & ((num % i) == 0))

smallest = i;

if ((largest == 1) & ((num % j) == 0))

largest = j;

```csharp
Console.WriteLine("Найбільший множник: " + largest);
Console.WriteLine("Найменший множник: " + smallest);
```

Нижче наведено результат виконання цієї програми.

Найбільший множник: 50

Найменший множник: 2

Завдяки застосуванню двох змінних управління циклом вдається виявити най менший і найбільший множники числа в одному циклі for . Зокрема, управляюча змінна i служить для виявлення найменшого множника. Спочатку її значення встановлюється рівним 2, а потім інкрементується до тих пір, поки не перевищить половину значення змінної num. А управляюча змінна j служить для виявлення найбільшого множника. Її значення спочатку встановлюється рів ним половині значення змінної num, а потім декрементується до тих пір, поки не стане менше 2. Цикл продовжує виконуватися до тих пір, поки обидві змінні, i і j , не досягнуть своїх кінцевих значень. Після завершення циклу обидва множники виявляються.

5.1.1.2 Умовний вираз

Умовним виразом, що керує циклом for, може бути будь-який дійсний вираз, що повертає значення типу bool. Він не обов'язково повинен містити змінну керування циклом. У наступному прикладі програми керування циклом for здійснюється за допомогою значення змінної done.

Лістинг 5.6 – Керування циклом for за допомогою значення змінної

// Умовою виконання циклу може бути будь-який вираз типу bool.

```csharp
using System;
class forDemo
static void Main()
```

int i, j;

bool done = false;

for (i = 0, j = 100; !done; i++, j--)

if (i * i >= j) done = true;

```csharp
Console.WriteLine("i, j: " + i + " " + j);
```

Нижче наведено результат виконання цієї програми.

i, j: 0 100

i, j: 1 99

i, j: 2 98

i, j: 3 97

i, j: 4 96

i, j: 5 95

i, j: 6 94

i, j: 7 93

i, j: 8 92

i, j: 9 91

i, j: 10 90

У даному прикладі цикл for повторюється до тих пір, поки значення змінної done типу не стане істинним ( true ). Істинне значення змінної done встановлюється в циклі, коли квадрат значення змінної i становиться більшим або рівним значенню змінної j.

5.1.1.3 Відсутні частини циклу

Ряд цікавих різновидностей циклу for виникає у випадку, якщо залишити порожніми окремі частини визначення циклу. У C# дозволяється залишати порожніми будь-які або всі частини ініціалізації, умови та ітерації в операторі циклу for. На прикладі розглянемо таку програму (лістинг 5.7).

Лістинг 5.7 – Окремі частини циклу for можуть залишатися порожніми.

// Окремі частини циклу for можуть залишатися порожніми.

```csharp
using System;
class Empty
static void Main()
```

int i;

for (i = 0; i < 10;)

```csharp
Console.WriteLine("Прохід #" + i);
```

i++; // інкрементувати змінну управління циклом

У даному прикладі ітераційний вираз в визначенні циклу for виявляється порожнім, тобто він взагалі відсутній. Замість цього змінна i, що керує циклом, інкрементується в тілі самого циклу. Це означає, що кожного разу, коли цикл повторюється , значення змінної i перевіряється на рівність числу 10, але жодних інших дій при цьому не відбувається. А оскільки змінна i інкрементується в тілі циклу, то сам цикл виконується звичайним чином, виводячи наведений нижче результат.

Прохід №0

Прохід №1

Прохід №2

Прохід №3

Прохід №4

Прохід №5

Прохід №6

Прохід №7

Прохід №8

Прохід №9

У наступному прикладі програми з визначення циклу for виключена ініціалізуюча частина (лістинг 5.8).

Лістинг 5.8 – Виключення ще одну частину з for

// Виключити ще одну частину з визначення циклу for.

```csharp
using System;
class Empty2
static void Main()
```

int i;

i = 0; // виключити ініціалізацію з визначення циклу

for (; i < 10;)

```csharp
Console.WriteLine("Прохід #" + i);
```

i++; // інкрементувати змінну управління циклом

У даному прикладі змінна i ініціалізується перед початком циклу, а не в самому циклі for. Зазвичай, змінна управління циклом ініціалізується в циклі for. Виведення ініціалізуючої частини за межі циклу зазвичай робиться лише у випадку, якщо початкове значення цієї змінної отримується в результаті складного процесу, який нецілеспрямовано вводити в операторі циклу for.

5.1.1.4 Нескінченний цикл

Якщо залишити порожнім вираз умови в операторі циклу for , то отримається нескінченний цикл, тобто такий цикл, який ніколи не закінчується. Як приклад в наступному фрагменті коду показано, яким чином у С# зазвичай створюється нескінченний цикл.

for ( ; ; ) // цикл, навмисно зроблений нескінченним

//...

Цей цикл буде виконуватися нескінченно. Незважаючи на те, що нескінченні цикли потрібні для вирішення деяких задач програмування, наприклад при розробці командних процесорів операційних систем, більшість так званих "нескінченних" циклів насправді представляють собою цикли зі спеціальними вимогами до завершення (докладніше про це - у розділі "Застосування оператора break для виходу з циклу" далі в цьому розділі).

5.1.1.5 Цикли без тіла

У C# допускається залишати порожнє тіло циклу for або будь-якого іншого циклу, оскільки порожній оператор з точки зору синтаксису цієї мови вважається дійсним. Цикли без тіла часто бувають корисними. Наприклад, у наступній програмі цикл без тіла використовується для отримання суми чисел від 1 до 5 (лістинг 5.9).

Лістинг 5.9 – Цикл без тіла для отримання суми чисел

// Тіло циклу може бути порожнім.

```csharp
using System;
class Empty3
static void Main()
```

int i;

int sum = 0;

// отримати суму чисел від 1 до 5

for (i = 1; i <= 5; sum += i++) ;

```csharp
Console.WriteLine("Сума дорівнює " + sum);
```

Виконання цієї програми дає наступний результат.

Сума дорівнює 15

Зверніть увагу на те, що процес сумування виконується повністю у операторі циклу for , і для цього тіло циклу не потрібне. У цьому циклі особливу увагу звертається на ітераційний вираз.

sum += i++;

Подібні оператори не повинні вас збивати з пантелику. Вони часто зустрічаються в програмах, професійно написаних на C#, і стають зрозумілими, якщо розібрати їх на частини. Дослівно наведений вище оператор означає наступне: додати до значення змінної sum результат сумування значень змінних sum та i, а потім інкрементувати значення змінної i. Отже, даний оператор еквівалентний наступній послідовності операторів.

sum = sum + i;

i++;

5.1.1.6 Оголошення керуючих змінних в циклі for

Часто змінна, що керує циклом for, потрібна лише для виконання самого циклу і ніде більше не використовується. У такому випадку керуючу змінну можна оголосити в ініціалізуючій частині оператора циклу for. Наприклад, у наведеній нижче програмі обчислюється сума і факторіал чисел від 1 до 5, а змінна i, що керує циклом for , оголошується в цьому циклі (лістинг 5.10).

Лістинг 5.10 – Обчислення суми та факторіалу чисел від 1 до 5

// Оголосити змінну керування циклом в самому циклі for.

```csharp
using System;
class ForVar
static void Main()
```

int sum = 0;

int fact = 1;

// обчислити факторіал чисел від 1 до 5

for (int i = 1; i <= 5; i++)

sum += i; // Змінна i діє в циклі.

fact *= i;

// А тут змінна i недоступна.

```csharp
Console.WriteLine("Сума дорівнює " + sum);
Console.WriteLine("Факторіал дорівнює " + fact);
```

Оголошуючи змінну в циклі for, не слід забувати, що область дії цієї змінної обмежується межами оператора циклу for. Це означає, що поза межами циклу дія даної змінної припиняється. Так, у наведеному вище прикладі змінна i виявляється недоступною поза межами циклу for. Для того щоб використовувати змінну управління циклом в якомусь іншому місці програми, її не можна оголошувати в циклі for.

Перш ніж переходити до наступного матеріалу, спробуйте експериментувати з власними варіантами оператора циклу for. Під час експерименту ви обов'язково виявите чудові властивості цього оператора циклу.

5.2 Оператор циклу while

Ще одним оператором циклу в C# є оператор while. Нижче наведена загальна форма цього оператора:

while ( умова) оператор;

де оператор - це єдиний оператор або блок операторів, а умова означає конкретну умову управління циклом і може бути будь-яким логічним виразом. У цьому циклі оператор виконується до тих пір, поки умова є істинною. Як тільки умова становиться хибною, управління програмою передається рядку коду, наступному безпосередньо після циклу.

Нижче наведено простий приклад програми, в якій цикл while використовується для обчислення порядку величини цілого числа (лістинг 5.11).

Лістинг 5.11 – Обчислення порядок величини цілого числа

// Обчислити порядок величини цілого числа.

```csharp
using System;
class WhileDemo
static void Main()
```

int num;

int mag;

num = 435679;

mag = 0;

```csharp
Console.WriteLine("Число: " + num);
```

while (num > 0)

mag++;

num = num / 10;

```csharp
Console.WriteLine("Порядок величини: " + mag);
```

Виконання цієї програми дає наступний результат.

Число: 435679

Порядок величини: 6

Наведений вище цикл while діє наступним чином. Спочатку перевіряється значення змінної num. Якщо воно більше нуля, то змінна mag , що виконує роль лічильника порядку величини, інкрементується, а значення змінної num ділиться на 10 . Цикл повторюється до тих пір, поки значення змінної num залишається більше нуля. Як тільки воно стане рівним нулю, цикл завершується, а в змінній mag залишається порядок величини початкового числового значення. Як і в циклі for , в циклі while перевіряється умовний вираз, вказаний у самому початку циклу. Це означає, що код у тілі циклу може взагалі не виконуватися, а також звільняє від необхідності виконувати окрему перевірку перед самим циклом. Ця властивість циклу while демонструється у наступному прикладі програми, де обчислюються цілі степені числа 2 від 0 до 9 (лістинг 5.12).

Лістинг 5.12 – Обчислення цілі степені числа 2

// Обчислити цілі степені числа 2.

```csharp
using System;
class Power
static void Main()
```

int e;

int result;

for (int i = 0; i < 10; i++)

result = 1;

e = i;

while (e > 0)

result *= 2;

e--;

```csharp
Console.WriteLine("2 в степені " + i + " дорівнює " + result);
```

Результат виконання цієї програми наведено нижче.

2 у степені дорівнює 1

2 у степені дорівнює 2

2 у степені дорівнює 4

2 у степені дорівнює 8

2 у степені дорівнює 16

2 у степені дорівнює 32

2 у степені дорівнює 64

2 у степені дорівнює 128

2 у степені дорівнює 256

2 у степені дорівнює 512

Зверніть увагу на те, що цикл while виконується тільки у випадку, якщо значення змінної е більше нуля. А коли воно дорівнює нулю, як це має місце на першому кроці циклу for, цикл while пропускається.

5.3 Оператор циклу do-while

Третім оператором циклу в C# є оператор do-while . На відміну від операторів циклу for і while, в яких умова перевірялась на початку циклу, у операторі do-while умова виконання циклу перевіряється в самому його кінці. Це означає, що цикл do-while завжди виконується хоча б один раз. Нижче наведена загальна форма оператора циклу do-while.

```csharp
do {
```

оператори;

```csharp
} while (умова );
```

При наявності лише одного оператора фігурні дужки в даній формі запису необов'язкові. Тим не менш вони часто використовуються для того, щоб зробити конструкцію do-while більш зручно читабельною і не плутати її з конструкцією циклу while. Цикл do-while виконується до тих пір, поки умовний вираз істинний.

У наведеному нижче прикладі програми цикл do-while використовується для представлення окремих цифр цілого числа в зворотному порядку (лістинг 5.13).

Лістинг 5.13 – Відображення цифр цілого числа в зворотному порядку

// Відобразити цифри цілого числа в зворотному порядку.

```csharp
using System;
class DoWhileDemo
static void Main()
```

int num;

int nextdigit;

num = 198;

```csharp
Console.WriteLine("Число: " + num);
Console.Write("Число в зворотному порядку: ");
```

nextdigit = num % 10;

```csharp
Console.Write(nextdigit);
```

num = num / 10;

```csharp
} while (num > 0);
Console.WriteLine();
```

Виконання цієї програми дає наступний результат.

Число: 198

Число в зворотному порядку: 891

Показаний цикл діє наступним чином. На кожному кроці ліва цифра отримується шляхом обчислення залишку від ділення цілого числа (значення змінної num ) на 10. Отримана цифра відображається. Потім значення змінної num ділиться на 10. Оскільки це цілочисельне ділення, то в його результаті ліва цифра відкидається. Цей процес повторюється до тих пір, поки значення змінної num не досягне нуля.

5.4 Оператор циклу foreach

Оператор циклу foreach використовується для циклічного звернення до елементів колекції, яка представляє собою групу об'єктів. У C# визначено кілька видів колекцій, до яких належить масив. Детальніше про цикл foreach буде розглянуто в розділі 6, де розглядаються масиви.

5.5 Застосування оператора break для виходу з циклу

За допомогою оператора break можна спеціально організувати негайний вихід з циклу, обходячи будь-який код, що залишився в тілі циклу, а також оминаючи перевірку умови циклу. Коли в тілі циклу зустрічається оператор break, цикл завершується, а виконання програми відновлюється з оператора, що йде після цього циклу. Розглянемо простий приклад програми (лістинг 5.14).

Лістинг 5.14 – Застосування оператора break для виходу з циклу

// Застосувати оператор break для виходу з циклу.

```csharp
using System;
class BreakDemo
static void Main()
```

// Використовувати оператор break для виходу з цього циклу.

for (int i = -10; i <= 10; i++)

if (i > 0) break; // завершити цикл, як тільки значення

// змінної i стане позитивним

```csharp
Console.Write(i + " ");
Console.WriteLine("Готово!");
```

Виконання цієї програми дає наступний результат.

-10 -9 -8 -7 -6 -5 -4 -3 -2 -1 0 Готово!

Як бачите, цикл for організований для виконання в межах від -10 до 10, але, не дивлячись на це, оператор break перериває його раніше, коли значення змінної i становиться позитивним.

Оператор break можна застосовувати в будь-якому циклі, передбаченому в С#. В якості прикладу нижче наведена версія попередньої програми, перероблена з метою використання циклу do-while (лістинг 5.15).

Лістинг 5.15 – Застосування оператора break для виходу з циклу do-while

// Застосувати оператор break для виходу з циклу do-while.

```csharp
using System;
class BreakDemo2
static void Main()
```

int i;

i = -10;

if (i > 0) break;

```csharp
Console.Write(i + " ");
```

i++;

```csharp
} while (i <= 10);
Console.WriteLine("Готово!");
```

А тепер розглянемо більш практичний приклад застосування оператора break. У наведеній нижче програмі виявляється найменший множник числа (лістинг 5.16).

Лістинг 5.16 – Виявлення найменшого множника числа

// Виявити найменший множник числа.

```csharp
using System;
class FindSmallestFactor
static void Main()
```

int factor = 1;

int num = 1000;

for (int i = 2; i <= num / i; i++)

if ((num % i) == 0)

factor = i;

break; // перервати цикл, як тільки буде

// виявлений найменший множник числа

```csharp
Console.WriteLine("Найменший множник дорівнює " + factor);
```

Результат виконання цієї програми виглядає наступним чином.

Найменший множник дорівнює 2

Оператор break перериває виконання циклу for, як тільки буде виявлений найменший множник числа. Завдяки такому застосуванню оператора break виключається перевірка будь-яких інших значень після виявлення найменшого множника числа, а отже, і неефективне виконання коду.

Якщо оператор break застосовується в цілому ряді вкладених циклів, то він перериває виконання тільки найвнутрішнього циклу. Як приклад розглянемо наступну програму (лістинг 5.17).

Лістинг 5.17 – Застосування оператора break у вкладених циклах

// Застосувати оператор break у вкладених циклах.

```csharp
using System;
class BreakNested
static void Main()
```

for (int i = 0; i < 3; i++)

```csharp
Console.WriteLine("Підрахунок у зовнішньому циклі: " + i);
Console.Write(" Підрахунок у внутрішньому циклі: ");
```

int t = 0;

while (t < 100)

if (t == 10) break; // перервати цикл, якщо t дорівнює 10

```csharp
Console.Write(t + " ");
```

t++;

```csharp
Console.WriteLine();
Console.WriteLine("Цикли завершено.");
```

Виконання цієї програми дає наступний результат.

Підрахунок у зовнішньому циклі: 0

Підрахунок у внутрішньому циклі: 0 1 2 3 4 5 6 7 8 9

Підрахунок у зовнішньому циклі: 1

Підрахунок у внутрішньому циклі: 0 1 2 3 4 5 6 1 8 9

Підрахунок у зовнішньому циклі: 2

Підрахунок у внутрішньому циклі: 0 1 2 3 4 5 6 1 8 9

Цикли завершено.

Як бачите, оператор break з внутрішнього циклу викликає переривання тільки цього циклу, а на виконання зовнішнього циклу він не має жодного впливу.

Щодо оператора break також слід мати на увазі наступне. По-перше, в тілі циклу може бути кілька операторів break, але застосовувати їх слід дуже обережно, оскільки надмірна кількість операторів break зазвичай призводить до порушення нормальної структури коду. І по-друге, оператор break, що виконує вихід з оператора switch, впливає тільки на цей оператор, але не на охоплюючі його цикли.

5.6 Застосування оператора continue

За допомогою оператора continue можна організувати передчасне завершення кроку ітерації циклу, обходячи звичайну структуру управління циклом. Оператор continue здійснює примусовий перехід до наступного кроку циклу, пропускаючи будь-який код, який залишився невиконаним. Таким чином, оператор continue служить своєрідним доповненням оператора break. У наведеному нижче прикладі програми оператор continue використовується як допоміжний засіб для виведення парних чисел в межах від 0 до 100 (лістинг 5.18).

Лістинг 5.18 – Застосування оператора break у вкладених циклах

// Застосувати оператор continue.

```csharp
using System;
class ContDemo
static void Main()
```

// вивести парні числа від 0 до 100.

for (int i = 0; i <= 100; i++)

if ((i % 2) != 0) continue; // перейти до наступного кроку

//ітерації

```csharp
Console.WriteLine(i);
```

У даному прикладі виводяться лише парні числа, оскільки при виявленні непарного числа крок ітерації циклу завершується передчасно обходом виклику методу WriteLine().

У циклах while і do-while оператор continue викликає передачу управління не прямо умовному виразу, після чого продовжується процес виконання циклу. А в циклі for спочатку обчислюється ітераційний вираз, потім умовний вираз, після чого цикл продовжується. Оператор continue рідко знаходить вдале застосування, зокрема, через те, що в C# надається багатий набір операторів циклу, що задовольняють більшість прикладних потреб. Але в тих особливих випадках, коли потрібно передчасне переривання кроку ітерації циклу, оператор continue надає структурований спосіб здійснення такого переривання.

5.7 Оператор return

Оператор return організовує повернення з методу. Його також можна використовувати для повернення значення. Докладніше він буде розглянутий при вивчені класів.


---

[◀️ До змісту](../README.md)
